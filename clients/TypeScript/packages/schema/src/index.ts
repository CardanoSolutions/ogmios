/* tslint:disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

/**
 * The origin of the blockchain. This point is special in the sense that it doesn't point to any existing slots, but is preceding any existing other point.
 */
export type Origin = "origin";
export type GenesisHash = "genesis";
/**
 * A Blake2b 28-byte hash digest, encoded in base16.
 */
export type Base16 = string;
/**
 * A Blake2b 28-byte hash digest of a verification key or script.
 */
export type Bech32 = string;
/**
 * A stake address (a.k.a reward account)
 */
export type StakeAddress = string;
export type Neutral = "neutral";

export interface Ogmios {
  FindIntersection: FindIntersection;
  FindIntersectionResponse: IntersectionFound | IntersectionNotFound;
  NextBlock: NextBlock;
  NextBlockResponse: NextBlockResponse;
  SubmitTransaction: SubmitTransaction;
  SubmitTransactionResponse: SubmitTransactionSuccess | SubmitTransactionFailure;
  EvaluateTransaction: EvaluateTransaction;
  EvaluateTransactionResponse: EvaluateTransactionSuccess | EvaluateTransactionFailure;
  AcquireLedgerState: AcquireLedgerState;
  AcquireLedgerStateResponse: AcquireLedgerStateSuccess | AcquireLedgerStateFailure;
  ReleaseLedgerState: ReleaseLedgerState;
  ReleaseLedgerStateResponse: ReleaseLedgerStateResponse;
  QueryLedgerStateEraMismatch?: QueryLedgerStateEraMismatch;
  QueryLedgerStateUnavailableInCurrentEra?: QueryLedgerStateUnavailableInCurrentEra;
  QueryLedgerStateAcquiredExpire?: QueryLedgerStateAcquiredExpired;
  QueryLedgerStateEpoch: QueryLedgerStateEpoch;
  QueryLedgerStateEpochResponse:
    | QueryLedgerStateEpochResponse
    | QueryLedgerStateEraMismatch
    | QueryLedgerStateUnavailableInCurrentEra
    | QueryLedgerStateAcquiredExpired;
  QueryLedgerStateEraStart: QueryLedgerStateEraStart;
  QueryLedgerStateEraStartResponse:
    | QueryLedgerStateEraStartResponse
    | QueryLedgerStateEraMismatch
    | QueryLedgerStateUnavailableInCurrentEra
    | QueryLedgerStateAcquiredExpired;
  QueryLedgerStateEraSummaries: QueryLedgerStateEraSummaries;
  QueryLedgerStateEraSummariesResponse:
    | QueryLedgerStateEraSummariesResponse
    | QueryLedgerStateEraMismatch
    | QueryLedgerStateUnavailableInCurrentEra
    | QueryLedgerStateAcquiredExpired;
  QueryLedgerStateLiveStakeDistribution: QueryLedgerStateLiveStakeDistribution;
  QueryLedgerStateLiveStakeDistributionResponse:
    | QueryLedgerStateLiveStakeDistributionResponse
    | QueryLedgerStateEraMismatch
    | QueryLedgerStateUnavailableInCurrentEra
    | QueryLedgerStateAcquiredExpired;
  QueryLedgerStateProjectedRewards: QueryLedgerStateProjectedRewards;
  QueryLedgerStateProjectedRewardsResponse:
    | QueryLedgerStateProjectedRewardsResponse
    | QueryLedgerStateEraMismatch
    | QueryLedgerStateUnavailableInCurrentEra
    | QueryLedgerStateAcquiredExpired;
  QueryLedgerStateProposedProtocolParameters: QueryLedgerStateProposedProtocolParameters;
  QueryLedgerStateProposedProtocolParametersResponse:
    | QueryLedgerStateProposedProtocolParametersResponse
    | QueryLedgerStateEraMismatch
    | QueryLedgerStateUnavailableInCurrentEra
    | QueryLedgerStateAcquiredExpired;
  QueryLedgerStateProtocolParameters: QueryLedgerStateProtocolParameters;
  QueryLedgerStateProtocolParametersResponse:
    | QueryLedgerStateProtocolParametersResponse
    | QueryLedgerStateEraMismatch
    | QueryLedgerStateUnavailableInCurrentEra
    | QueryLedgerStateAcquiredExpired;
  QueryLedgerStateRewardAccountSummaries: QueryLedgerStateRewardAccountSummaries;
  QueryLedgerStateRewardAccountSummariesResponse:
    | QueryLedgerStateRewardAccountSummariesResponse
    | QueryLedgerStateEraMismatch
    | QueryLedgerStateUnavailableInCurrentEra
    | QueryLedgerStateAcquiredExpired;
  QueryLedgerStateRewardsProvenance: QueryLedgerStateRewardsProvenance;
  QueryLedgerStateRewardsProvenanceResponse:
    | QueryLedgerStateRewardsProvenanceResponse
    | QueryLedgerStateEraMismatch
    | QueryLedgerStateUnavailableInCurrentEra
    | QueryLedgerStateAcquiredExpired;
  QueryLedgerStateStakePools: QueryLedgerStateStakePools;
  QueryLedgerStateStakePoolsResponse:
    | QueryLedgerStateStakePoolsResponse
    | QueryLedgerStateEraMismatch
    | QueryLedgerStateUnavailableInCurrentEra
    | QueryLedgerStateAcquiredExpired;
  QueryLedgerStateStakePoolParameters: QueryLedgerStateStakePoolParameters;
  QueryLedgerStateStakePoolParametersResponse:
    | QueryLedgerStateStakePoolParametersResponse
    | QueryLedgerStateEraMismatch
    | QueryLedgerStateUnavailableInCurrentEra
    | QueryLedgerStateAcquiredExpired;
  QueryLedgerStateTip: QueryLedgerStateTip;
  QueryLedgerStateTipResponse:
    | QueryLedgerStateTipResponse
    | QueryLedgerStateEraMismatch
    | QueryLedgerStateUnavailableInCurrentEra
    | QueryLedgerStateAcquiredExpired;
  QueryLedgerStateUtxo: QueryLedgerStateUtxo;
  QueryLedgerStateUtxoResponse:
    | QueryLedgerStateUtxoResponse
    | QueryLedgerStateEraMismatch
    | QueryLedgerStateUnavailableInCurrentEra
    | QueryLedgerStateAcquiredExpired;
  QueryNetworkBlockHeight: QueryNetworkBlockHeight;
  QueryNetworkBlockHeightResponse: QueryNetworkBlockHeightResponse;
  QueryNetworkGenesisConfiguration: QueryNetworkGenesisConfiguration;
  QueryNetworkGenesisConfigurationResponse: QueryNetworkGenesisConfigurationResponse;
  QueryNetworkStartTime: QueryNetworkStartTime;
  QueryNetworkStartTimeResponse: QueryNetworkStartTimeResponse;
  QueryNetworkTip: QueryNetworkTip;
  QueryNetworkTipResponse: QueryNetworkTipResponse;
  AcquireMempool: AcquireMempool;
  AcquireMempoolResponse: AcquireMempoolResponse;
  NextTransaction: NextTransaction;
  NextTransactionResponse: NextTransactionResponse;
  HasTransaction: HasTransaction;
  HasTransactionResponse: HasTransactionResponse;
  SizeOfMempool: SizeOfMempool;
  SizeOfMempoolResponse?: SizeOfMempoolResponse;
  ReleaseMempool: ReleaseMempool;
  ReleaseMempoolResponse: ReleaseMempoolResponse;
  RpcError: RpcError;
}
/**
 * Ask cardano-node to find an intersection between its local chain and the given points.
 */
export interface FindIntersection {
  jsonrpc: "2.0";
  method: "findIntersection";
  params: {
    points?: (Point | Origin)[];
  };
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * A point on the chain, identified by a slot and a block header hash.
 */
export interface Point {
  /**
   * An absolute slot number.
   */
  slot: number;
  /**
   * A Blake2b 32-byte hash digest, encoded in base16.
   */
  hash: string;
}
export interface IntersectionFound {
  jsonrpc: "2.0";
  result: {
    intersection: Point | Origin;
    tip: Tip | Origin;
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface Tip {
  /**
   * An absolute slot number.
   */
  slot: number;
  /**
   * A Blake2b 32-byte hash digest, encoded in base16.
   */
  hash: string;
  /**
   * A block number, the i-th block to be minted is number i.
   */
  blockNo: number;
}
export interface IntersectionNotFound {
  jsonrpc: "2.0";
  error: {
    code: 1000;
    message: string;
    data: {
      tip: Tip | Origin;
    };
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Request next block from the current cardano-node's cursor.
 */
export interface NextBlock {
  jsonrpc: "2.0";
  method: "nextBlock";
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Response to a 'nextBlock' request.
 */
export interface NextBlockResponse {
  jsonrpc: "2.0";
  result: RollForward | RollBackward;
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface RollForward {
  direction: "forward";
  tip: Tip;
  block: BlockEBB | BlockBFT | BlockPraos;
}
export interface BlockEBB {
  era: "byron";
  header: {
    /**
     * A Blake2b 32-byte hash digest, encoded in base16.
     */
    hash: string;
  };
  /**
   * A Blake2b 32-byte hash digest, encoded in base16.
   */
  ancestor: string;
  /**
   * A block number, the i-th block to be minted is number i.
   */
  height: number;
}
export interface BlockBFT {
  era: "byron";
  header: {
    /**
     * A Blake2b 32-byte hash digest, encoded in base16.
     */
    hash: string;
  };
  /**
   * A Blake2b 32-byte hash digest, encoded in base16.
   */
  ancestor: string;
  /**
   * A block number, the i-th block to be minted is number i.
   */
  height: number;
  /**
   * An absolute slot number.
   */
  slot: number;
  /**
   * The size of the block in bytes.
   */
  size: number;
  transactions?: Transaction[];
  operationalCertificates?: BootstrapOperationalCertificate[];
  governanceAction?: BootstrapGovernanceAction;
  protocol: {
    magic: number;
    version: {
      major: number;
      minor: number;
      patch?: number;
    };
    software: {
      appName: string;
      number: number;
    };
  };
  issuer: {
    /**
     * An Ed25519-BIP32 Byron genesis delegate verification key with chain-code.
     */
    verificationKey: string;
  };
  delegate: {
    /**
     * An Ed25519-BIP32 Byron genesis delegate verification key with chain-code.
     */
    verificationKey: string;
  };
}
export interface Transaction {
  /**
   * A Blake2b 32-byte hash digest, encoded in base16.
   */
  id: string;
  inputSource: "inputs" | "collaterals";
  inputs: {
    /**
     * A Blake2b 32-byte hash digest of a transaction body, CBOR-encoded.
     */
    txId: string;
    index: number;
  }[];
  references?: {
    /**
     * A Blake2b 32-byte hash digest of a transaction body, CBOR-encoded.
     */
    txId: string;
    index: number;
  }[];
  collaterals?: {
    /**
     * A Blake2b 32-byte hash digest of a transaction body, CBOR-encoded.
     */
    txId: string;
    index: number;
  }[];
  /**
   * A number of lovelace, possibly large when summed up.
   */
  collateral?: bigint;
  /**
   * A transaction output. Since Mary, 'value' always return a multi-asset value. Since Alonzo, 'datumHash' is always present (albeit sometimes 'null'). Since Babbage, 'datum' & 'script' are always present (albeit sometimes 'null').
   */
  collateralReturn?: {
    /**
     * A Cardano address (either legacy format or new format).
     */
    address: string;
    value: {
      /**
       * A number of lovelace, possibly large when summed up.
       */
      coins: bigint;
      assets?: {
        /**
         * A number of asset, can be negative went burning assets.
         */
        [k: string]: bigint;
      };
    };
    /**
     * A Blake2b 32-byte hash digest, encoded in base16.
     */
    datumHash?: string;
    datum?: string;
    script?: Native | PlutusV1 | PlutusV2;
  };
  outputs: {
    /**
     * A Cardano address (either legacy format or new format).
     */
    address: string;
    value: {
      /**
       * A number of lovelace, possibly large when summed up.
       */
      coins: bigint;
      assets?: {
        /**
         * A number of asset, can be negative went burning assets.
         */
        [k: string]: bigint;
      };
    };
    /**
     * A Blake2b 32-byte hash digest, encoded in base16.
     */
    datumHash?: string;
    datum?: string;
    script?: Native | PlutusV1 | PlutusV2;
  }[];
  certificates?: (
    | StakeDelegation
    | StakeKeyRegistration
    | StakeKeyDeregistration
    | PoolRegistration
    | PoolRetirement
    | GenesisDelegation
    | MoveInstantaneousRewards
  )[];
  withdrawals?: {
    /**
     * A number of lovelace, possibly large when summed up.
     */
    [k: string]: bigint;
  };
  /**
   * A number of lovelace, possibly large when summed up.
   */
  fee?: bigint;
  validityInterval?: {
    /**
     * An absolute slot number.
     */
    invalidBefore?: number;
    /**
     * An absolute slot number.
     */
    invalidAfter?: number;
  };
  mint?: {
    /**
     * A number of lovelace, possibly large when summed up.
     */
    coins: bigint;
    assets?: {
      /**
       * A number of asset, can be negative went burning assets.
       */
      [k: string]: bigint;
    };
  };
  /**
   * A network target, as defined since the Shelley era.
   */
  network?: "mainnet" | "testnet";
  /**
   * A Blake2b 32-byte hash digest, encoded in base16.
   */
  scriptIntegrityHash?: string;
  requiredExtraSignatories?: string[];
  governanceActions?: UpdateProposalBabbage[];
  metadata?: {
    /**
     * A Blake2b 32-byte hash digest, encoded in base16.
     */
    hash: string;
    labels: {
      [k: string]: Int | String | Bytes | List | Map;
    };
  };
  signatories: unknown[];
  scripts?: {
    [k: string]: Native | PlutusV1 | PlutusV2;
  };
  datums?: {
    [k: string]: string;
  };
  redeemers?: {
    [k: string]: {
      /**
       * Plutus data, CBOR-serialised.
       */
      redeemer: string;
      executionUnits: {
        memory: number;
        steps: number;
      };
    };
  };
  /**
   * The raw serialized (CBOR) transaction, as found on-chain.
   */
  cbor: string;
}
export interface Native {
  /**
   * A phase-1 monetary script. Timelocks constraints are only supported since Allegra.
   */
  native: string | Any | All | NOf | ExpiresAt | StartsAt;
}
export interface Any {
  any: (string | Any | All | NOf | ExpiresAt | StartsAt)[];
}
export interface All {
  all: (string | Any | All | NOf | ExpiresAt | StartsAt)[];
}
export interface NOf {
  [k: string]: (string | Any | All | NOf | ExpiresAt | StartsAt)[];
}
export interface ExpiresAt {
  /**
   * An absolute slot number.
   */
  expiresAt: number;
}
export interface StartsAt {
  /**
   * An absolute slot number.
   */
  startsAt: number;
}
export interface PlutusV1 {
  /**
   * A phase-2 Plutus script; or said differently, a serialized Plutus-core program.
   */
  "plutus:v1": string;
}
export interface PlutusV2 {
  /**
   * A phase-2 Plutus script; or said differently, a serialized Plutus-core program.
   */
  "plutus:v2": string;
}
/**
 * A stake delegation certificate, from a delegator to a stake pool.
 */
export interface StakeDelegation {
  stakeDelegation: {
    /**
     * A Blake2b 28-byte hash digest, encoded in base16.
     */
    delegator: string;
    /**
     * A Blake2b 32-byte hash digest of a pool's verification key.
     */
    delegatee: string;
  };
}
/**
 * A stake key registration certificate.
 */
export interface StakeKeyRegistration {
  /**
   * A Blake2b 28-byte hash digest, encoded in base16.
   */
  stakeKeyRegistration: string;
}
/**
 * A stake key de-registration certificate.
 */
export interface StakeKeyDeregistration {
  /**
   * A Blake2b 28-byte hash digest, encoded in base16.
   */
  stakeKeyDeregistration: string;
}
/**
 * A pool registration certificate.
 */
export interface PoolRegistration {
  poolRegistration: {
    /**
     * A Blake2b 32-byte hash digest of a pool's verification key.
     */
    id: string;
    owners: string[];
    /**
     * A number of lovelace, possibly large when summed up.
     */
    cost: bigint;
    /**
     * A ratio of two integers, to express exact fractions.
     */
    margin: string;
    /**
     * A number of lovelace, possibly large when summed up.
     */
    pledge: bigint;
    /**
     * A Blake2b 32-byte hash digest, encoded in base16.
     */
    vrf: string;
    metadata?: PoolMetadata;
    relays: (ByAddress | ByName)[];
    /**
     * A reward account, also known as 'stake address'.
     */
    rewardAccount: string;
  };
}
export interface PoolMetadata {
  /**
   * A hash digest from an unspecified algorithm and length.
   */
  hash: string;
  url: string;
}
export interface ByAddress {
  ipv4?: string;
  ipv6?: string;
  port?: number;
}
export interface ByName {
  hostname: string;
  port?: number;
}
/**
 * A pool retirement certificate.
 */
export interface PoolRetirement {
  poolRetirement: {
    /**
     * An epoch number or length.
     */
    retirementEpoch: number;
    /**
     * A Blake2b 32-byte hash digest of a pool's verification key.
     */
    poolId: string;
  };
}
export interface GenesisDelegation {
  genesisDelegation: {
    /**
     * A Blake2b 28-byte hash digest, encoded in base16.
     */
    delegateKeyHash: string;
    /**
     * A Blake2b 28-byte hash digest, encoded in base16.
     */
    verificationKeyHash: string;
    /**
     * A Blake2b 32-byte hash digest, encoded in base16.
     */
    vrfVerificationKeyHash: string;
  };
}
/**
 * Either `value` or `rewards` will be present, but never both.
 */
export interface MoveInstantaneousRewards {
  moveInstantaneousRewards: {
    rewards?: {
      /**
       * An amount, possibly negative, in Lovelace (1e6 Lovelace = 1 Ada).
       */
      [k: string]: number;
    };
    /**
     * A number of lovelace, possibly large when summed up.
     */
    value?: bigint;
    /**
     * Source of rewards as defined by the protocol parameters.
     */
    pot: "reserves" | "treasury";
  };
}
export interface UpdateProposalBabbage {
  /**
   * An epoch number or length.
   */
  epoch: number;
  proposal: {
    [k: string]: {
      minFeeCoefficient?: number;
      minFeeConstant?: number;
      maxBlockBodySize?: number;
      maxBlockHeaderSize?: number;
      maxTxSize?: number;
      stakeKeyDeposit?: number;
      poolDeposit?: number;
      poolRetirementEpochBound?: number;
      desiredNumberOfPools?: number;
      /**
       * A ratio of two integers, to express exact fractions.
       */
      poolInfluence?: string;
      /**
       * A ratio of two integers, to express exact fractions.
       */
      monetaryExpansion?: string;
      /**
       * A ratio of two integers, to express exact fractions.
       */
      treasuryExpansion?: string;
      minPoolCost?: number;
      coinsPerUtxoByte?: number;
      maxValueSize?: number;
      collateralPercentage?: number;
      maxCollateralInputs?: number;
      protocolVersion?: {
        major: number;
        minor: number;
        patch?: number;
      };
      costModels?: {
        [k: string]: {
          [k: string]: number;
        };
      };
      prices?: {
        /**
         * A ratio of two integers, to express exact fractions.
         */
        memory: string;
        /**
         * A ratio of two integers, to express exact fractions.
         */
        steps: string;
      };
      maxExecutionUnitsPerTransaction?: {
        memory: number;
        steps: number;
      };
      maxExecutionUnitsPerBlock?: {
        memory: number;
        steps: number;
      };
    };
  };
}
export interface Int {
  int: bigint;
}
export interface String {
  string: string;
}
export interface Bytes {
  bytes: string;
}
export interface List {
  list: (Int | String | Bytes | List | Map)[];
}
export interface Map {
  map: {
    k: Int | String | Bytes | List | Map;
    v: Int | String | Bytes | List | Map;
  }[];
}
/**
 * A (Byron) delegation certificate.
 */
export interface BootstrapOperationalCertificate {
  issuer: {
    /**
     * An Ed25519 verification key.
     */
    verificationKey: string;
  };
  delegate: {
    /**
     * An Ed25519 verification key.
     */
    verificationKey: string;
  };
}
export interface BootstrapGovernanceAction {
  proposal?: {
    protocol: {
      version: {
        major: number;
        minor: number;
        patch?: number;
      };
      software: {
        appName: string;
        number: number;
      };
    };
    metadata: {
      [k: string]: string;
    };
    parameters: {
      /**
       * A ratio of two integers, to express exact fractions.
       */
      heavyDlgThreshold?: string;
      maxBlockSize?: number;
      maxHeaderSize?: number;
      maxProposalSize?: number;
      maxTxSize?: number;
      /**
       * A ratio of two integers, to express exact fractions.
       */
      mpcThreshold?: string;
      scriptVersion?: number;
      slotDuration?: number;
      unlockStakeEpoch?: number;
      /**
       * A ratio of two integers, to express exact fractions.
       */
      updateProposalThreshold?: string;
      updateProposalTimeToLive?: number;
      /**
       * A ratio of two integers, to express exact fractions.
       */
      updateVoteThreshold?: string;
      txFeePolicy?: {
        /**
         * A ratio of two integers, to express exact fractions.
         */
        coefficient: string;
        constant: number;
      };
      softforkRule?: {
        /**
         * A ratio of two integers, to express exact fractions.
         */
        initThreshold: string;
        /**
         * A ratio of two integers, to express exact fractions.
         */
        minThreshold: string;
        /**
         * A ratio of two integers, to express exact fractions.
         */
        decrementThreshold: string;
      };
    };
    issuer: {
      /**
       * An Ed25519-BIP32 Byron genesis delegate verification key with chain-code.
       */
      verificationKey: string;
    };
  };
  votes: {
    voter: {
      /**
       * An Ed25519 verification key.
       */
      verificationKey: string;
    };
    proposal: {
      /**
       * A Blake2b 32-byte hash digest, encoded in base16.
       */
      hash: string;
    };
  }[];
}
export interface BlockPraos {
  era: "shelley" | "allegra" | "mary" | "alonzo" | "babbage";
  header: {
    /**
     * A Blake2b 32-byte hash digest, encoded in base16.
     */
    hash: string;
  };
  ancestor: string | GenesisHash;
  nonce?: {
    proof?: string;
    output?: string;
  };
  /**
   * A block number, the i-th block to be minted is number i.
   */
  height: number;
  /**
   * The size of the block in bytes.
   */
  size: number;
  /**
   * An absolute slot number.
   */
  slot: number;
  transactions?: Transaction[];
  protocol: {
    version: {
      major: number;
      minor: number;
      patch?: number;
    };
  };
  issuer: {
    /**
     * An Ed25519 verification key.
     */
    verificationKey: string;
    /**
     * An Ed25519 verification key.
     */
    vrfVerificationKey: string;
    /**
     * Certificate identifying a stake pool operator.
     */
    operationalCertificate: {
      count: number;
      kes: {
        period: number;
        verificationKey: string;
      };
    };
    leaderValue: {
      proof?: string;
      output?: string;
    };
  };
}
export interface RollBackward {
  direction: "backward";
  tip: Tip | Origin;
  point: Point | Origin;
}
/**
 * Submit a signed and serialized transaction to the network.
 */
export interface SubmitTransaction {
  jsonrpc: "2.0";
  method: "submitTransaction";
  params: {
    /**
     * CBOR-serialized signed transaction (base16)
     */
    transaction: string;
  };
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface SubmitTransactionSuccess {
  jsonrpc: "2.0";
  result: {
    transaction: {
      /**
       * A Blake2b 32-byte hash digest of a transaction body, CBOR-encoded.
       */
      id: string;
    };
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface SubmitTransactionFailure {
  jsonrpc: "2.0";
  error: {
    code: 3005;
    message: string;
    data: (
      | {
          queryEra: "Byron" | "Shelley" | "Allegra" | "Mary" | "Alonzo" | "Babbage";
          ledgerEra: "Byron" | "Shelley" | "Allegra" | "Mary" | "Alonzo" | "Babbage";
        }
      | InvalidWitnesses
      | MissingVkWitnesses
      | MissingScriptWitnesses
      | ScriptWitnessNotValidating
      | InsufficientGenesisSignatures
      | MissingTxMetadata
      | MissingTxMetadataHash
      | TxMetadataHashMismatch
      | BadInputs
      | ExpiredUtxo
      | OutsideOfValidityInterval
      | TxTooLarge
      | MissingAtLeastOneInputUtxo
      | InvalidMetadata
      | FeeTooSmall
      | ValueNotConserved
      | NetworkMismatch
      | OutputTooSmall
      | TooManyAssetsInOutput
      | AddressAttributesTooLarge
      | TriesToForgeAda
      | DelegateNotRegistered
      | UnknownOrIncompleteWithdrawals
      | StakePoolNotRegistered
      | WrongRetirementEpoch
      | WrongPoolCertificate
      | StakeKeyAlreadyRegistered
      | PoolCostTooSmall
      | PoolMetadataHashTooBig
      | StakeKeyNotRegistered
      | RewardAccountNotExisting
      | RewardAccountNotEmpty
      | WrongCertificateType
      | UnknownGenesisKey
      | AlreadyDelegating
      | InsufficientFundsForMir
      | TooLateForMir
      | MirTransferNotCurrentlyAllowed
      | MirNegativeTransferNotCurrentlyAllowed
      | MirProducesNegativeUpdate
      | DuplicateGenesisVrf
      | NonGenesisVoters
      | UpdateWrongEpoch
      | ProtocolVersionCannotFollow
      | MissingRequiredRedeemers
      | MissingRequiredDatums
      | UnspendableDatums
      | ExtraDataMismatch
      | MissingRequiredSignatures
      | UnspendableScriptInputs
      | ExtraRedeemers
      | MissingDatumHashesForInputs
      | MissingCollateralInputs
      | CollateralTooSmall
      | CollateralIsScript
      | CollateralHasNonAdaAssets
      | TooManyCollateralInputs
      | ExecutionUnitsTooLarge
      | OutsideForecast
      | ValidationTagMismatch
      | CollectErrors
      | ExtraScriptWitnesses
      | MirNegativeTransfer
      | TotalCollateralMismatch
      | MalformedReferenceScripts
      | MalformedScriptWitnesses
    )[];
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface InvalidWitnesses {
  invalidWitnesses: string[];
}
export interface MissingVkWitnesses {
  missingVkWitnesses: string[];
}
export interface MissingScriptWitnesses {
  missingScriptWitnesses: string[];
}
export interface ScriptWitnessNotValidating {
  scriptWitnessNotValidating: string[];
}
export interface InsufficientGenesisSignatures {
  insufficientGenesisSignatures: string[];
}
export interface MissingTxMetadata {
  /**
   * A Blake2b 32-byte hash digest, encoded in base16.
   */
  missingTxMetadata: string;
}
export interface MissingTxMetadataHash {
  /**
   * A Blake2b 32-byte hash digest, encoded in base16.
   */
  missingTxMetadataHash: string;
}
export interface TxMetadataHashMismatch {
  txMetadataHashMismatch: {
    /**
     * A Blake2b 32-byte hash digest, encoded in base16.
     */
    includedHash: string;
    /**
     * A Blake2b 32-byte hash digest, encoded in base16.
     */
    expectedHash: string;
  };
}
export interface BadInputs {
  badInputs: {
    /**
     * A Blake2b 32-byte hash digest of a transaction body, CBOR-encoded.
     */
    txId: string;
    index: number;
  }[];
}
/**
 * Only in Shelley. Replaced with 'outsideOfValidityInterval' since Allegra.
 */
export interface ExpiredUtxo {
  expiredUtxo: {
    /**
     * An absolute slot number.
     */
    currentSlot: number;
    /**
     * An absolute slot number.
     */
    transactionTimeToLive: number;
  };
}
/**
 * Since Allegra. Replaces 'expiredUtxo'.
 */
export interface OutsideOfValidityInterval {
  outsideOfValidityInterval: {
    /**
     * An absolute slot number.
     */
    currentSlot: number;
    interval: {
      /**
       * An absolute slot number.
       */
      invalidBefore?: number;
      /**
       * An absolute slot number.
       */
      invalidAfter?: number;
    };
  };
}
export interface TxTooLarge {
  txTooLarge: {
    maximumSize: number;
    actualSize: number;
  };
}
export interface MissingAtLeastOneInputUtxo {
  missingAtLeastOneInputUtxo: null;
}
export interface InvalidMetadata {
  invalidMetadata: null;
}
export interface FeeTooSmall {
  feeTooSmall: {
    /**
     * A number of lovelace, possibly large when summed up.
     */
    requiredFee: bigint;
    /**
     * A number of lovelace, possibly large when summed up.
     */
    actualFee: bigint;
  };
}
/**
 * Returns 'Value' since Mary, and 'LovelaceDelta' before.
 */
export interface ValueNotConserved {
  valueNotConserved: {
    consumed:
      | number
      | {
          /**
           * A number of lovelace, possibly large when summed up.
           */
          coins: bigint;
          assets?: {
            /**
             * A number of asset, can be negative went burning assets.
             */
            [k: string]: bigint;
          };
        };
    produced:
      | number
      | {
          /**
           * A number of lovelace, possibly large when summed up.
           */
          coins: bigint;
          assets?: {
            /**
             * A number of asset, can be negative went burning assets.
             */
            [k: string]: bigint;
          };
        };
  };
}
export interface NetworkMismatch {
  networkMismatch: {
    /**
     * A network target, as defined since the Shelley era.
     */
    expectedNetwork: "mainnet" | "testnet";
    invalidEntities: (
      | {
          type: "address";
          /**
           * A Cardano address (either legacy format or new format).
           */
          entity: string;
        }
      | {
          type: "poolRegistration";
          /**
           * A Blake2b 32-byte hash digest of a pool's verification key.
           */
          entity: string;
        }
      | {
          type: "rewardAccount";
          /**
           * A reward account, also known as 'stake address'.
           */
          entity: string;
        }
    )[];
  };
}
export interface OutputTooSmall {
  outputTooSmall: (
    | {
        /**
         * A Cardano address (either legacy format or new format).
         */
        address: string;
        value: {
          /**
           * A number of lovelace, possibly large when summed up.
           */
          coins: bigint;
          assets?: {
            /**
             * A number of asset, can be negative went burning assets.
             */
            [k: string]: bigint;
          };
        };
        /**
         * A Blake2b 32-byte hash digest, encoded in base16.
         */
        datumHash?: string;
        datum?: string;
        script?: Native | PlutusV1 | PlutusV2;
      }
    | {
        /**
         * A transaction output. Since Mary, 'value' always return a multi-asset value. Since Alonzo, 'datumHash' is always present (albeit sometimes 'null'). Since Babbage, 'datum' & 'script' are always present (albeit sometimes 'null').
         */
        output: {
          /**
           * A Cardano address (either legacy format or new format).
           */
          address: string;
          value: {
            /**
             * A number of lovelace, possibly large when summed up.
             */
            coins: bigint;
            assets?: {
              /**
               * A number of asset, can be negative went burning assets.
               */
              [k: string]: bigint;
            };
          };
          /**
           * A Blake2b 32-byte hash digest, encoded in base16.
           */
          datumHash?: string;
          datum?: string;
          script?: Native | PlutusV1 | PlutusV2;
        };
        /**
         * A number of lovelace, possibly large when summed up.
         */
        minimumRequiredValue: bigint;
      }
  )[];
}
/**
 * Only since Mary.
 */
export interface TooManyAssetsInOutput {
  tooManyAssetsInOutput: {
    /**
     * A Cardano address (either legacy format or new format).
     */
    address: string;
    value: {
      /**
       * A number of lovelace, possibly large when summed up.
       */
      coins: bigint;
      assets?: {
        /**
         * A number of asset, can be negative went burning assets.
         */
        [k: string]: bigint;
      };
    };
    /**
     * A Blake2b 32-byte hash digest, encoded in base16.
     */
    datumHash?: string;
    datum?: string;
    script?: Native | PlutusV1 | PlutusV2;
  }[];
}
export interface AddressAttributesTooLarge {
  addressAttributesTooLarge: string[];
}
/**
 * Only since Mary.
 */
export interface TriesToForgeAda {
  triesToForgeAda: null;
}
export interface DelegateNotRegistered {
  /**
   * A Blake2b 32-byte hash digest of a pool's verification key.
   */
  delegateNotRegistered: string;
}
export interface UnknownOrIncompleteWithdrawals {
  unknownOrIncompleteWithdrawals: {
    /**
     * A number of lovelace, possibly large when summed up.
     */
    [k: string]: bigint;
  };
}
export interface StakePoolNotRegistered {
  /**
   * A Blake2b 32-byte hash digest of a pool's verification key.
   */
  stakePoolNotRegistered: string;
}
export interface WrongRetirementEpoch {
  wrongRetirementEpoch: {
    /**
     * An epoch number or length.
     */
    currentEpoch: number;
    /**
     * An epoch number or length.
     */
    requestedEpoch: number;
    /**
     * An epoch number or length.
     */
    firstUnreachableEpoch: number;
  };
}
export interface WrongPoolCertificate {
  wrongPoolCertificate: number;
}
export interface StakeKeyAlreadyRegistered {
  /**
   * A Blake2b 28-byte hash digest, encoded in base16.
   */
  stakeKeyAlreadyRegistered: string;
}
export interface PoolCostTooSmall {
  poolCostTooSmall: {
    /**
     * A number of lovelace, possibly large when summed up.
     */
    minimumCost: bigint;
  };
}
export interface PoolMetadataHashTooBig {
  poolMetadataHashTooBig: {
    /**
     * A Blake2b 32-byte hash digest of a pool's verification key.
     */
    poolId: string;
    measuredSize: number;
  };
}
export interface StakeKeyNotRegistered {
  /**
   * A Blake2b 28-byte hash digest, encoded in base16.
   */
  stakeKeyNotRegistered: string;
}
export interface RewardAccountNotExisting {
  rewardAccountNotExisting: null;
}
export interface RewardAccountNotEmpty {
  rewardAccountNotEmpty: {
    /**
     * A number of lovelace, possibly large when summed up.
     */
    balance: bigint;
  };
}
export interface WrongCertificateType {
  wrongCertificateType: null;
}
export interface UnknownGenesisKey {
  /**
   * A Blake2b 28-byte hash digest, encoded in base16.
   */
  unknownGenesisKey: string;
}
export interface AlreadyDelegating {
  /**
   * A Blake2b 28-byte hash digest, encoded in base16.
   */
  alreadyDelegating: string;
}
export interface InsufficientFundsForMir {
  insufficientFundsForMir: {
    /**
     * Source of rewards as defined by the protocol parameters.
     */
    rewardSource: "reserves" | "treasury";
    /**
     * A number of lovelace, possibly large when summed up.
     */
    sourceSize: bigint;
    /**
     * A number of lovelace, possibly large when summed up.
     */
    requestedAmount: bigint;
  };
}
export interface TooLateForMir {
  tooLateForMir: {
    /**
     * An absolute slot number.
     */
    currentSlot: number;
    /**
     * An absolute slot number.
     */
    lastAllowedSlot: number;
  };
}
export interface MirTransferNotCurrentlyAllowed {
  mirTransferNotCurrentlyAllowed: null;
}
export interface MirNegativeTransferNotCurrentlyAllowed {
  mirNegativeTransferNotCurrentlyAllowed: null;
}
export interface MirProducesNegativeUpdate {
  mirProducesNegativeUpdate: null;
}
export interface DuplicateGenesisVrf {
  /**
   * A Blake2b 28-byte hash digest, encoded in base16.
   */
  duplicateGenesisVrf: string;
}
export interface NonGenesisVoters {
  nonGenesisVoters: {
    currentlyVoting: string[];
    shouldBeVoting: string[];
  };
}
export interface UpdateWrongEpoch {
  updateWrongEpoch: {
    /**
     * An epoch number or length.
     */
    currentEpoch: number;
    /**
     * An epoch number or length.
     */
    requestedEpoch: number;
    votingPeriod: "voteForThisEpoch" | "voteForNextEpoch";
  };
}
export interface ProtocolVersionCannotFollow {
  protocolVersionCannotFollow: {
    major: number;
    minor: number;
    patch?: number;
  };
}
export interface MissingRequiredRedeemers {
  missingRequiredRedeemers: {
    missing: {
      [k: string]: Spend | Mint | Certificate | Withdrawal;
    }[];
  };
}
export interface Spend {
  spend: {
    /**
     * A Blake2b 32-byte hash digest of a transaction body, CBOR-encoded.
     */
    txId: string;
    index: number;
  };
}
export interface Mint {
  /**
   * A Blake2b 28-byte hash digest, encoded in base16.
   */
  mint: string;
}
export interface Certificate {
  certificate:
    | StakeDelegation
    | StakeKeyRegistration
    | StakeKeyDeregistration
    | PoolRegistration
    | PoolRetirement
    | GenesisDelegation
    | MoveInstantaneousRewards;
}
export interface Withdrawal {
  /**
   * A reward account, also known as 'stake address'.
   */
  withdrawal: string;
}
export interface MissingRequiredDatums {
  missingRequiredDatums: {
    provided?: string[];
    missing: string[];
  };
}
export interface UnspendableDatums {
  unspendableDatums: {
    nonSpendable: string[];
    acceptable: string[];
  };
}
export interface ExtraDataMismatch {
  extraDataMismatch: {
    /**
     * A Blake2b 32-byte hash digest, encoded in base16.
     */
    provided?: string;
    /**
     * A Blake2b 32-byte hash digest, encoded in base16.
     */
    inferredFromParameters?: string;
  };
}
export interface MissingRequiredSignatures {
  missingRequiredSignatures: string[];
}
export interface UnspendableScriptInputs {
  unspendableScriptInputs: {
    /**
     * A Blake2b 32-byte hash digest of a transaction body, CBOR-encoded.
     */
    txId: string;
    index: number;
  }[];
}
export interface ExtraRedeemers {
  extraRedeemers: string[];
}
export interface MissingDatumHashesForInputs {
  missingDatumHashesForInputs: {
    /**
     * A Blake2b 32-byte hash digest of a transaction body, CBOR-encoded.
     */
    txId: string;
    index: number;
  }[];
}
/**
 * Only since Alonzo.
 */
export interface MissingCollateralInputs {
  missingCollateralInputs: null;
}
export interface CollateralTooSmall {
  collateralTooSmall: {
    /**
     * A number of lovelace, possibly large when summed up.
     */
    requiredCollateral: bigint;
    /**
     * A number of lovelace, possibly large when summed up.
     */
    actualCollateral: bigint;
  };
}
export interface CollateralIsScript {
  collateralIsScript: [
    {
      /**
       * A Blake2b 32-byte hash digest of a transaction body, CBOR-encoded.
       */
      txId: string;
      index: number;
    },
    {
      /**
       * A Cardano address (either legacy format or new format).
       */
      address: string;
      value: {
        /**
         * A number of lovelace, possibly large when summed up.
         */
        coins: bigint;
        assets?: {
          /**
           * A number of asset, can be negative went burning assets.
           */
          [k: string]: bigint;
        };
      };
      /**
       * A Blake2b 32-byte hash digest, encoded in base16.
       */
      datumHash?: string;
      datum?: string;
      script?: Native | PlutusV1 | PlutusV2;
    }
  ][];
}
export interface CollateralHasNonAdaAssets {
  collateralHasNonAdaAssets: {
    /**
     * A number of lovelace, possibly large when summed up.
     */
    coins: bigint;
    assets?: {
      /**
       * A number of asset, can be negative went burning assets.
       */
      [k: string]: bigint;
    };
  };
}
export interface TooManyCollateralInputs {
  tooManyCollateralInputs: {
    maximumCollateralInputs: number;
    actualCollateralInputs: number;
  };
}
export interface ExecutionUnitsTooLarge {
  executionUnitsTooLarge: {
    maximumExecutionUnits: {
      memory: number;
      steps: number;
    };
    actualExecutionUnits: {
      memory: number;
      steps: number;
    };
  };
}
export interface OutsideForecast {
  /**
   * An absolute slot number.
   */
  outsideForecast: number;
}
/**
 * Only since Alonzo.
 */
export interface ValidationTagMismatch {
  validationTagMismatch: null;
}
export interface CollectErrors {
  collectErrors: (NoRedeemer | NoWitness | NoCostModel | BadTranslation)[];
}
export interface NoRedeemer {
  noRedeemer: Spend | Mint | Certificate | Withdrawal;
}
export interface NoWitness {
  /**
   * A Blake2b 28-byte hash digest, encoded in base16.
   */
  noWitness: string;
}
export interface NoCostModel {
  noCostModel: "plutus:v1" | "plutus:v2";
}
export interface BadTranslation {
  /**
   * An (hopefully) informative error about the transaction execution failure.
   */
  badTranslation: string;
}
export interface ExtraScriptWitnesses {
  extraScriptWitnesses: string[];
}
export interface MirNegativeTransfer {
  mirNegativeTransfer: {
    /**
     * Source of rewards as defined by the protocol parameters.
     */
    rewardSource: "reserves" | "treasury";
    /**
     * A number of lovelace, possibly large when summed up.
     */
    attemptedTransfer: bigint;
  };
}
export interface TotalCollateralMismatch {
  totalCollateralMismatch: {
    /**
     * A number of lovelace, possibly large when summed up.
     */
    computedFromDelta: bigint;
    /**
     * A number of lovelace, possibly large when summed up.
     */
    declaredInField: bigint;
  };
}
export interface MalformedReferenceScripts {
  malformedReferenceScripts: string[];
}
export interface MalformedScriptWitnesses {
  malformedScriptWitnesses: string[];
}
/**
 * Evaluate execution units for which redeemers's budget hasn't yet been set.
 */
export interface EvaluateTransaction {
  jsonrpc: "2.0";
  method: "evaluateTransaction";
  params: {
    /**
     * CBOR-serialized signed transaction (base16)
     */
    transaction: string;
    additionalUtxoSet?: [
      {
        /**
         * A Blake2b 32-byte hash digest of a transaction body, CBOR-encoded.
         */
        txId: string;
        index: number;
      },
      {
        /**
         * A Cardano address (either legacy format or new format).
         */
        address: string;
        value: {
          /**
           * A number of lovelace, possibly large when summed up.
           */
          coins: bigint;
          assets?: {
            /**
             * A number of asset, can be negative went burning assets.
             */
            [k: string]: bigint;
          };
        };
        /**
         * A Blake2b 32-byte hash digest, encoded in base16.
         */
        datumHash?: string;
        datum?: string;
        script?: Native | PlutusV1 | PlutusV2;
      }
    ][];
  };
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface EvaluateTransactionSuccess {
  jsonrpc: "2.0";
  result: {
    budgets: {
      [k: string]: {
        memory: number;
        steps: number;
      };
    };
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Happens when attempting to evaluate execution units on a node that isn't enough synchronized.
 */
export interface EvaluateTransactionFailure {
  jsonrpc: "2.0";
  error:
    | EvaluateTransactionFailureIncompatibleEra
    | EvaluateTransactionFailureOverlappingAdditionalUtxo
    | EvaluateTransactionFailureNodeTipTooOld
    | EvaluateTransactionFailureCannotCreateEvaluationContext
    | EvaluateTransactionFailureScriptExecutionFailure;
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Returned when trying to evaluate execution units of a pre-Alonzo transaction. Note that this isn't possible with Ogmios because transactions are always de-serialized as Alonzo transactions.
 */
export interface EvaluateTransactionFailureIncompatibleEra {
  code: 3000;
  message: string;
  data: IncompatibleEra;
}
/**
 * The era in which the transaction has been identified.
 */
export interface IncompatibleEra {
  incompatibleEra: "Byron" | "Shelley" | "Allegra" | "Mary";
}
/**
 * Happens when providing an additional UTXO set which overlaps with the UTXO on-chain.
 */
export interface EvaluateTransactionFailureOverlappingAdditionalUtxo {
  code: 3001;
  message: string;
  data: OverlappingAdditionalUtxo;
}
export interface OverlappingAdditionalUtxo {
  overlappingOutputReferences: {
    /**
     * A Blake2b 32-byte hash digest of a transaction body, CBOR-encoded.
     */
    txId: string;
    index: number;
  }[];
}
/**
 * Happens when attempting to evaluate execution units on a node that isn't enough synchronized.
 */
export interface EvaluateTransactionFailureNodeTipTooOld {
  code: 3002;
  message: string;
  data: NodeTipTooOld;
}
export interface NodeTipTooOld {
  minimumRequiredEra: "Byron" | "Shelley" | "Allegra" | "Mary" | "Alonzo" | "Babbage";
  currentNodeEra: "Byron" | "Shelley" | "Allegra" | "Mary" | "Alonzo" | "Babbage";
}
/**
 * The transaction is malformed or missing information; making evaluation impossible.
 */
export interface EvaluateTransactionFailureCannotCreateEvaluationContext {
  code: 3003;
  message: string;
  data: CannotCreateEvaluationContext;
}
export interface CannotCreateEvaluationContext {
  reason: string;
}
/**
 * One or more script execution terminated with an error.
 */
export interface EvaluateTransactionFailureScriptExecutionFailure {
  code: 3004;
  message: string;
  data: ScriptExecutionFailure;
}
/**
 * Some script in the transaction terminated with an error.
 */
export interface ScriptExecutionFailure {
  [k: string]: (
    | ExtraRedeemers
    | MissingRequiredDatums
    | MissingRequiredScripts
    | ValidatorFailed
    | UnknownInputReferencedByRedeemer
    | NonScriptInputReferencedByRedeemer
    | IllFormedExecutionBudget
    | NoCostModelForLanguage
  )[];
}
/**
 * Missing scripts required for validating script inputs.
 */
export interface MissingRequiredScripts {
  missingRequiredScripts: {
    missing: string[];
    resolved: {
      /**
       * A Blake2b 28-byte hash digest, encoded in base16.
       */
      [k: string]: string;
    };
  };
}
/**
 * Plutus interpreter error. Returns additional traces produced by the validator.
 */
export interface ValidatorFailed {
  validatorFailed: {
    error: string;
    traces: string[];
  };
}
/**
 * Non-existing input referenced by a redeemer pointer.
 */
export interface UnknownInputReferencedByRedeemer {
  unknownInputReferencedByRedeemer: {
    /**
     * A Blake2b 32-byte hash digest of a transaction body, CBOR-encoded.
     */
    txId: string;
    index: number;
  };
}
/**
 * Input not locked by a Plutus referenced by a redeemer pointer.
 */
export interface NonScriptInputReferencedByRedeemer {
  nonScriptInputReferencedByRedeemer: {
    /**
     * A Blake2b 32-byte hash digest of a transaction body, CBOR-encoded.
     */
    txId: string;
    index: number;
  };
}
/**
 * Invalid execution budget set for a redeemer. In principle, cannot happen in the context of Ogmios.
 */
export interface IllFormedExecutionBudget {
  illFormedExecutionBudget?: {
    memory: number;
    steps: number;
  };
}
/**
 * Input locked by a script which language has no cost model in current protocol parameters. In principle, cannot happen in the context of Ogmios.
 */
export interface NoCostModelForLanguage {
  noCostModelForLanguage: "plutus:v1" | "plutus:v2";
}
/**
 * Acquire a point on chain from which to run ledger-state queries.
 */
export interface AcquireLedgerState {
  jsonrpc: "2.0";
  method: "acquireLedgerState";
  params: {
    point: Point | Origin;
  };
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Response to an 'acquireLedgerState' request.
 */
export interface AcquireLedgerStateSuccess {
  jsonrpc: "2.0";
  result: AcquireLedgerStateSuccess1;
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface AcquireLedgerStateSuccess1 {
  acquired: "ledgerState";
  point: Point | Origin;
}
/**
 * Unable to acquire the ledger state at the request point.
 */
export interface AcquireLedgerStateFailure {
  jsonrpc: "2.0";
  error: AcquireLedgerStateFailure1;
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface AcquireLedgerStateFailure1 {
  code: 2000;
  message: string;
  /**
   * A reason for the failure.
   */
  data: string;
}
/**
 * Release a previously acquired ledger state.
 */
export interface ReleaseLedgerState {
  jsonrpc: "2.0";
  method: "releaseLedgerState";
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Response to a 'releaseLedgerState' request.
 */
export interface ReleaseLedgerStateResponse {
  jsonrpc: "2.0";
  result: {
    released: "ledgerState";
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * An era mismatch between a client request and the era the ledger is in. This may occur when running queries on a syncing node and/or when the node is crossing an era.
 */
export interface QueryLedgerStateEraMismatch {
  jsonrpc: "2.0";
  error: {
    code: 2001;
    message: string;
    data: {
      queryEra: "Byron" | "Shelley" | "Allegra" | "Mary" | "Alonzo" | "Babbage";
      ledgerEra: "Byron" | "Shelley" | "Allegra" | "Mary" | "Alonzo" | "Babbage";
    };
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Some query is not available for the requested ledger era.
 */
export interface QueryLedgerStateUnavailableInCurrentEra {
  jsonrpc: "2.0";
  error: {
    code: 2002;
    message: string;
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Previously acquired ledger state is no longer available.
 */
export interface QueryLedgerStateAcquiredExpired {
  jsonrpc: "2.0";
  error: {
    code: 2003;
    message: string;
    /**
     * A reason for the failure.
     */
    data: string;
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Query the current epoch number the ledger is at.
 */
export interface QueryLedgerStateEpoch {
  jsonrpc: "2.0";
  method: "queryLedgerState/epoch";
  params?: unknown;
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface QueryLedgerStateEpochResponse {
  jsonrpc: "2.0";
  result: {
    /**
     * An epoch number or length.
     */
    epoch: number;
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Query the start of the current ledger era.
 */
export interface QueryLedgerStateEraStart {
  jsonrpc: "2.0";
  method: "queryLedgerState/eraStart";
  params?: unknown;
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface QueryLedgerStateEraStartResponse {
  jsonrpc: "2.0";
  result: {
    /**
     * An era bound which captures the time, slot and epoch at which the era start. The time is relative to the start time of the network.
     */
    eraStart: {
      /**
       * A time in seconds relative to another one (typically, system start or era start). Starting from v5.5.4, this can be a floating number. Before v5.5.4, the floating value would be rounded to the nearest second.
       */
      time: number;
      /**
       * An absolute slot number.
       */
      slot: number;
      /**
       * An epoch number or length.
       */
      epoch: number;
    };
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Query a summary of the slotting parameters and boundaries for each known era. Useful for doing slot-arithmetic and time conversions.
 */
export interface QueryLedgerStateEraSummaries {
  jsonrpc: "2.0";
  method: "queryLedgerState/eraSummaries";
  params?: unknown;
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface QueryLedgerStateEraSummariesResponse {
  jsonrpc: "2.0";
  result: {
    eraSummaries: {
      /**
       * An era bound which captures the time, slot and epoch at which the era start. The time is relative to the start time of the network.
       */
      start: {
        /**
         * A time in seconds relative to another one (typically, system start or era start). Starting from v5.5.4, this can be a floating number. Before v5.5.4, the floating value would be rounded to the nearest second.
         */
        time: number;
        /**
         * An absolute slot number.
         */
        slot: number;
        /**
         * An epoch number or length.
         */
        epoch: number;
      };
      end: {
        /**
         * A time in seconds relative to another one (typically, system start or era start). Starting from v5.5.4, this can be a floating number. Before v5.5.4, the floating value would be rounded to the nearest second.
         */
        time: number;
        /**
         * An absolute slot number.
         */
        slot: number;
        /**
         * An epoch number or length.
         */
        epoch: number;
      } | null;
      /**
       * Parameters that can vary across hard forks.
       */
      parameters: {
        /**
         * An epoch number or length.
         */
        epochLength: number;
        /**
         * A slot length, in seconds. Starting from v5.5.4, this can be a floating number. Before v5.5.4, the floating value would be rounded to the nearest second.
         */
        slotLength: number;
        safeZone: number | null;
      };
    }[];
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Query the current distribution of the stake across all known stake pools, relative to the TOTAL stake in the network.
 */
export interface QueryLedgerStateLiveStakeDistribution {
  jsonrpc: "2.0";
  method: "queryLedgerState/liveStakeDistribution";
  params?: unknown;
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface QueryLedgerStateLiveStakeDistributionResponse {
  jsonrpc: "2.0";
  result: {
    liveStakeDistribution: LiveStakeDistribution;
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Distribution of stake across registered stake pools. Each key in the map corresponds to a pool id.
 */
export interface LiveStakeDistribution {
  [k: string]: {
    /**
     * A ratio of two integers, to express exact fractions.
     */
    stake: string;
    /**
     * A Blake2b 32-byte hash digest, encoded in base16.
     */
    vrf: string;
  };
}
/**
 * Query the projected rewards of an account in a context where the top stake pools are fully saturated. This projection gives, in principle, a ranking of stake pools that maximizes delegator rewards.
 */
export interface QueryLedgerStateProjectedRewards {
  jsonrpc: "2.0";
  method: "queryLedgerState/projectedRewards";
  params: {
    stake?: bigint[];
    scripts?: (Base16 | Bech32 | StakeAddress)[];
    keys?: (Base16 | Bech32 | StakeAddress)[];
  };
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface QueryLedgerStateProjectedRewardsResponse {
  jsonrpc: "2.0";
  result: {
    projectedRewards: ProjectedRewards;
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Rewards that can be expected assuming a pool is fully saturated. Such rewards are said non-myopic, in opposition to short-sighted rewards looking at immediate benefits. Keys of the map can be either Lovelace amounts or account credentials depending on the query.
 */
export interface ProjectedRewards {
  [k: string]: {
    [k: string]: number;
  };
}
/**
 * Query the last update proposal w.r.t. protocol parameters, if any.
 */
export interface QueryLedgerStateProposedProtocolParameters {
  jsonrpc: "2.0";
  method: "queryLedgerState/proposedProtocolParameters";
  params?: unknown;
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface QueryLedgerStateProposedProtocolParametersResponse {
  jsonrpc: "2.0";
  result: {
    proposedProtocolParameters:
      | ProposedProtocolParametersShelley
      | ProposedProtocolParametersAlonzo
      | ProposedProtocolParametersBabbage;
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface ProposedProtocolParametersShelley {
  [k: string]: {
    minFeeCoefficient?: number;
    minFeeConstant?: number;
    maxBlockBodySize?: number;
    maxBlockHeaderSize?: number;
    maxTxSize?: number;
    stakeKeyDeposit?: number;
    poolDeposit?: number;
    poolRetirementEpochBound?: number;
    desiredNumberOfPools?: number;
    /**
     * A ratio of two integers, to express exact fractions.
     */
    poolInfluence?: string;
    /**
     * A ratio of two integers, to express exact fractions.
     */
    monetaryExpansion?: string;
    /**
     * A ratio of two integers, to express exact fractions.
     */
    treasuryExpansion?: string;
    /**
     * A ratio of two integers, to express exact fractions.
     */
    decentralizationParameter?: string;
    minUtxoValue?: number;
    minPoolCost?: number;
    extraEntropy?: Neutral | string;
    protocolVersion?: {
      major: number;
      minor: number;
      patch?: number;
    };
  };
}
export interface ProposedProtocolParametersAlonzo {
  [k: string]: {
    minFeeCoefficient?: number;
    minFeeConstant?: number;
    maxBlockBodySize?: number;
    maxBlockHeaderSize?: number;
    maxTxSize?: number;
    stakeKeyDeposit?: number;
    poolDeposit?: number;
    poolRetirementEpochBound?: number;
    desiredNumberOfPools?: number;
    /**
     * A ratio of two integers, to express exact fractions.
     */
    poolInfluence?: string;
    /**
     * A ratio of two integers, to express exact fractions.
     */
    monetaryExpansion?: string;
    /**
     * A ratio of two integers, to express exact fractions.
     */
    treasuryExpansion?: string;
    /**
     * A ratio of two integers, to express exact fractions.
     */
    decentralizationParameter?: string;
    minPoolCost?: number;
    coinsPerUtxoWord?: number;
    maxValueSize?: number;
    collateralPercentage?: number;
    maxCollateralInputs?: number;
    extraEntropy?: Neutral | string;
    protocolVersion?: {
      major: number;
      minor: number;
      patch?: number;
    };
    costModels?: {
      [k: string]: {
        [k: string]: number;
      };
    };
    prices?: {
      /**
       * A ratio of two integers, to express exact fractions.
       */
      memory: string;
      /**
       * A ratio of two integers, to express exact fractions.
       */
      steps: string;
    };
    maxExecutionUnitsPerTransaction?: {
      memory: number;
      steps: number;
    };
    maxExecutionUnitsPerBlock?: {
      memory: number;
      steps: number;
    };
  };
}
export interface ProposedProtocolParametersBabbage {
  [k: string]: {
    minFeeCoefficient?: number;
    minFeeConstant?: number;
    maxBlockBodySize?: number;
    maxBlockHeaderSize?: number;
    maxTxSize?: number;
    stakeKeyDeposit?: number;
    poolDeposit?: number;
    poolRetirementEpochBound?: number;
    desiredNumberOfPools?: number;
    /**
     * A ratio of two integers, to express exact fractions.
     */
    poolInfluence?: string;
    /**
     * A ratio of two integers, to express exact fractions.
     */
    monetaryExpansion?: string;
    /**
     * A ratio of two integers, to express exact fractions.
     */
    treasuryExpansion?: string;
    minPoolCost?: number;
    coinsPerUtxoByte?: number;
    maxValueSize?: number;
    collateralPercentage?: number;
    maxCollateralInputs?: number;
    protocolVersion?: {
      major: number;
      minor: number;
      patch?: number;
    };
    costModels?: {
      [k: string]: {
        [k: string]: number;
      };
    };
    prices?: {
      /**
       * A ratio of two integers, to express exact fractions.
       */
      memory: string;
      /**
       * A ratio of two integers, to express exact fractions.
       */
      steps: string;
    };
    maxExecutionUnitsPerTransaction?: {
      memory: number;
      steps: number;
    };
    maxExecutionUnitsPerBlock?: {
      memory: number;
      steps: number;
    };
  };
}
/**
 * Query the current protocol parameters.
 */
export interface QueryLedgerStateProtocolParameters {
  jsonrpc: "2.0";
  method: "queryLedgerState/protocolParameters";
  params?: unknown;
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface QueryLedgerStateProtocolParametersResponse {
  jsonrpc: "2.0";
  result: {
    protocolParameters:
      | {
          minFeeCoefficient?: number;
          minFeeConstant?: number;
          maxBlockBodySize?: number;
          maxBlockHeaderSize?: number;
          maxTxSize?: number;
          stakeKeyDeposit?: number;
          poolDeposit?: number;
          poolRetirementEpochBound?: number;
          desiredNumberOfPools?: number;
          /**
           * A ratio of two integers, to express exact fractions.
           */
          poolInfluence?: string;
          /**
           * A ratio of two integers, to express exact fractions.
           */
          monetaryExpansion?: string;
          /**
           * A ratio of two integers, to express exact fractions.
           */
          treasuryExpansion?: string;
          /**
           * A ratio of two integers, to express exact fractions.
           */
          decentralizationParameter?: string;
          minUtxoValue?: number;
          minPoolCost?: number;
          extraEntropy?: Neutral | string;
          protocolVersion?: {
            major: number;
            minor: number;
            patch?: number;
          };
        }
      | {
          minFeeCoefficient?: number;
          minFeeConstant?: number;
          maxBlockBodySize?: number;
          maxBlockHeaderSize?: number;
          maxTxSize?: number;
          stakeKeyDeposit?: number;
          poolDeposit?: number;
          poolRetirementEpochBound?: number;
          desiredNumberOfPools?: number;
          /**
           * A ratio of two integers, to express exact fractions.
           */
          poolInfluence?: string;
          /**
           * A ratio of two integers, to express exact fractions.
           */
          monetaryExpansion?: string;
          /**
           * A ratio of two integers, to express exact fractions.
           */
          treasuryExpansion?: string;
          /**
           * A ratio of two integers, to express exact fractions.
           */
          decentralizationParameter?: string;
          minPoolCost?: number;
          coinsPerUtxoWord?: number;
          maxValueSize?: number;
          collateralPercentage?: number;
          maxCollateralInputs?: number;
          extraEntropy?: Neutral | string;
          protocolVersion?: {
            major: number;
            minor: number;
            patch?: number;
          };
          costModels?: {
            [k: string]: {
              [k: string]: number;
            };
          };
          prices?: {
            /**
             * A ratio of two integers, to express exact fractions.
             */
            memory: string;
            /**
             * A ratio of two integers, to express exact fractions.
             */
            steps: string;
          };
          maxExecutionUnitsPerTransaction?: {
            memory: number;
            steps: number;
          };
          maxExecutionUnitsPerBlock?: {
            memory: number;
            steps: number;
          };
        }
      | {
          minFeeCoefficient?: number;
          minFeeConstant?: number;
          maxBlockBodySize?: number;
          maxBlockHeaderSize?: number;
          maxTxSize?: number;
          stakeKeyDeposit?: number;
          poolDeposit?: number;
          poolRetirementEpochBound?: number;
          desiredNumberOfPools?: number;
          /**
           * A ratio of two integers, to express exact fractions.
           */
          poolInfluence?: string;
          /**
           * A ratio of two integers, to express exact fractions.
           */
          monetaryExpansion?: string;
          /**
           * A ratio of two integers, to express exact fractions.
           */
          treasuryExpansion?: string;
          minPoolCost?: number;
          coinsPerUtxoByte?: number;
          maxValueSize?: number;
          collateralPercentage?: number;
          maxCollateralInputs?: number;
          protocolVersion?: {
            major: number;
            minor: number;
            patch?: number;
          };
          costModels?: {
            [k: string]: {
              [k: string]: number;
            };
          };
          prices?: {
            /**
             * A ratio of two integers, to express exact fractions.
             */
            memory: string;
            /**
             * A ratio of two integers, to express exact fractions.
             */
            steps: string;
          };
          maxExecutionUnitsPerTransaction?: {
            memory: number;
            steps: number;
          };
          maxExecutionUnitsPerBlock?: {
            memory: number;
            steps: number;
          };
        };
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Query current delegation settings and rewards of some given reward accounts.
 */
export interface QueryLedgerStateRewardAccountSummaries {
  jsonrpc: "2.0";
  method: "queryLedgerState/rewardAccountSummaries";
  params: {
    scripts?: (Base16 | Bech32 | StakeAddress)[];
    keys?: (Base16 | Bech32 | StakeAddress)[];
  };
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface QueryLedgerStateRewardAccountSummariesResponse {
  jsonrpc: "2.0";
  result: {
    rewardAccountSummaries: RewardAccountSummaries;
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface RewardAccountSummaries {
  [k: string]: RewardAccountSummary;
}
export interface RewardAccountSummary {
  /**
   * A Blake2b 32-byte hash digest of a pool's verification key.
   */
  delegate?: string;
  /**
   * A number of lovelace, possibly large when summed up.
   */
  rewards?: bigint;
}
/**
 * Query details about rewards calculation for the ongoing epoch.
 */
export interface QueryLedgerStateRewardsProvenance {
  jsonrpc: "2.0";
  method: "queryLedgerState/rewardsProvenance";
  params?: unknown;
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface QueryLedgerStateRewardsProvenanceResponse {
  jsonrpc: "2.0";
  result: {
    rewardsProvenance: RewardsProvenance;
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Details about how rewards are calculated for the ongoing epoch.
 */
export interface RewardsProvenance {
  /**
   * Desired number of stake pools.
   */
  desiredNumberOfPools: number;
  /**
   * Influence of the pool owner's pledge on rewards, as a ratio of two integers.
   */
  poolInfluence: string;
  /**
   * Total rewards available for the given epoch.
   */
  totalRewards: bigint;
  /**
   * The total amount of staked Lovelace during this epoch.
   */
  activeStake: bigint;
  pools: {
    [k: string]: StakePoolSummary;
  };
}
export interface StakePoolSummary {
  /**
   * A number of lovelace, possibly large when summed up.
   */
  stake: bigint;
  /**
   * A number of lovelace, possibly large when summed up.
   */
  ownerStake: bigint;
  /**
   * Number of blocks produced divided by expected number of blocks (based on stake and epoch progress). Can be larger than 1.0 for pools that get lucky.
   */
  approximatePerformance: number;
  /**
   * Some of the pool parameters relevant for the reward calculation.
   */
  poolParameters: {
    /**
     * A number of lovelace, possibly large when summed up.
     */
    cost: bigint;
    /**
     * A ratio of two integers, to express exact fractions.
     */
    margin: string;
    /**
     * A number of lovelace, possibly large when summed up.
     */
    pledge: bigint;
  };
}
/**
 * Query the list of all stake pool identifiers currently registered and active.
 */
export interface QueryLedgerStateStakePools {
  jsonrpc: "2.0";
  method: "queryLedgerState/stakePools";
  params?: unknown;
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface QueryLedgerStateStakePoolsResponse {
  jsonrpc: "2.0";
  result: {
    stakePools: {
      /**
       * A Blake2b 32-byte hash digest of a pool's verification key.
       */
      id: string;
    }[];
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Query registered parameters for given stake pools.
 */
export interface QueryLedgerStateStakePoolParameters {
  jsonrpc: "2.0";
  method: "queryLedgerState/stakePoolParameters";
  params: {
    stakePools: (string | string)[];
  };
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface QueryLedgerStateStakePoolParametersResponse {
  jsonrpc: "2.0";
  result: {
    stakePoolParameters: {
      [k: string]: {
        /**
         * A Blake2b 32-byte hash digest of a pool's verification key.
         */
        id: string;
        owners: string[];
        /**
         * A number of lovelace, possibly large when summed up.
         */
        cost: bigint;
        /**
         * A ratio of two integers, to express exact fractions.
         */
        margin: string;
        /**
         * A number of lovelace, possibly large when summed up.
         */
        pledge: bigint;
        /**
         * A Blake2b 32-byte hash digest, encoded in base16.
         */
        vrf: string;
        metadata?: PoolMetadata;
        relays: (ByAddress | ByName)[];
        /**
         * A reward account, also known as 'stake address'.
         */
        rewardAccount: string;
      };
    };
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Query the current tip the ledger is at. Said differently, the slot number and header hash of the last block that has been processed by the ledger.
 */
export interface QueryLedgerStateTip {
  jsonrpc: "2.0";
  method: "queryLedgerState/tip";
  params?: unknown;
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface QueryLedgerStateTipResponse {
  jsonrpc: "2.0";
  result: {
    tip: Point | Origin;
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Query the current Utxo set, restricted to some output references or addresses.
 */
export interface QueryLedgerStateUtxo {
  jsonrpc: "2.0";
  method: "queryLedgerState/utxo";
  params?: UtxoByOutputReferences | UtxoByAddresses | WholeUtxo;
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface UtxoByOutputReferences {
  outputReferences: {
    /**
     * A Blake2b 32-byte hash digest of a transaction body, CBOR-encoded.
     */
    txId: string;
    index: number;
  }[];
}
export interface UtxoByAddresses {
  addresses: string[];
}
export interface WholeUtxo {}
export interface QueryLedgerStateUtxoResponse {
  jsonrpc: "2.0";
  result: {
    utxo: [
      {
        /**
         * A Blake2b 32-byte hash digest of a transaction body, CBOR-encoded.
         */
        txId: string;
        index: number;
      },
      {
        /**
         * A Cardano address (either legacy format or new format).
         */
        address: string;
        value: {
          /**
           * A number of lovelace, possibly large when summed up.
           */
          coins: bigint;
          assets?: {
            /**
             * A number of asset, can be negative went burning assets.
             */
            [k: string]: bigint;
          };
        };
        /**
         * A Blake2b 32-byte hash digest, encoded in base16.
         */
        datumHash?: string;
        datum?: string;
        script?: Native | PlutusV1 | PlutusV2;
      }
    ][];
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Query the network’s highest block number.
 */
export interface QueryNetworkBlockHeight {
  jsonrpc: "2.0";
  method: "queryNetwork/blockHeight";
  params?: unknown;
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface QueryNetworkBlockHeightResponse {
  jsonrpc: "2.0";
  result: {
    blockHeight: number | Origin;
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Query the genesis configuration of a given era.
 */
export interface QueryNetworkGenesisConfiguration {
  jsonrpc: "2.0";
  method: "queryNetwork/genesisConfiguration";
  params: {
    era: "byron" | "shelley" | "alonzo";
  };
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface QueryNetworkGenesisConfigurationResponse {
  jsonrpc: "2.0";
  result: {
    genesisConfiguration:
      | {
          /**
           * A Byron genesis configuration, with information used to bootstrap the era. Some parameters are also updatable across the era.
           */
          byron: {
            genesisKeyHashes: string[];
            genesisDelegations: {
              [k: string]: BootstrapOperationalCertificate;
            };
            systemStart: string;
            initialFunds: {
              /**
               * A number of lovelace, possibly large when summed up.
               */
              [k: string]: bigint;
            };
            initialCoinOffering: {
              /**
               * A number of lovelace, possibly large when summed up.
               */
              [k: string]: bigint;
            };
            securityParameter: number;
            /**
             * A magic number for telling networks apart. (e.g. 764824073)
             */
            networkMagic: number;
            protocolParameters: {
              /**
               * A ratio of two integers, to express exact fractions.
               */
              heavyDlgThreshold?: string;
              maxBlockSize?: number;
              maxHeaderSize?: number;
              maxProposalSize?: number;
              maxTxSize?: number;
              /**
               * A ratio of two integers, to express exact fractions.
               */
              mpcThreshold?: string;
              scriptVersion?: number;
              slotDuration?: number;
              unlockStakeEpoch?: number;
              /**
               * A ratio of two integers, to express exact fractions.
               */
              updateProposalThreshold?: string;
              updateProposalTimeToLive?: number;
              /**
               * A ratio of two integers, to express exact fractions.
               */
              updateVoteThreshold?: string;
              txFeePolicy?: {
                /**
                 * A ratio of two integers, to express exact fractions.
                 */
                coefficient: string;
                constant: number;
              };
              softforkRule?: {
                /**
                 * A ratio of two integers, to express exact fractions.
                 */
                initThreshold: string;
                /**
                 * A ratio of two integers, to express exact fractions.
                 */
                minThreshold: string;
                /**
                 * A ratio of two integers, to express exact fractions.
                 */
                decrementThreshold: string;
              };
            };
          };
        }
      | {
          /**
           * A Shelley genesis configuration, with information used to bootstrap the era. Some parameters are also updatable across the era.
           */
          shelley: {
            systemStart: string;
            /**
             * A magic number for telling networks apart. (e.g. 764824073)
             */
            networkMagic: number;
            /**
             * A network target, as defined since the Shelley era.
             */
            network: "mainnet" | "testnet";
            /**
             * A ratio of two integers, to express exact fractions.
             */
            activeSlotsCoefficient: string;
            securityParameter: number;
            /**
             * An epoch number or length.
             */
            epochLength: number;
            slotsPerKesPeriod: number;
            maxKesEvolutions: number;
            /**
             * A slot length, in seconds. Starting from v5.5.4, this can be a floating number. Before v5.5.4, the floating value would be rounded to the nearest second.
             */
            slotLength: number;
            updateQuorum: number;
            maxLovelaceSupply: number;
            protocolParameters: {
              minFeeCoefficient?: number;
              minFeeConstant?: number;
              maxBlockBodySize?: number;
              maxBlockHeaderSize?: number;
              maxTxSize?: number;
              stakeKeyDeposit?: number;
              poolDeposit?: number;
              poolRetirementEpochBound?: number;
              desiredNumberOfPools?: number;
              /**
               * A ratio of two integers, to express exact fractions.
               */
              poolInfluence?: string;
              /**
               * A ratio of two integers, to express exact fractions.
               */
              monetaryExpansion?: string;
              /**
               * A ratio of two integers, to express exact fractions.
               */
              treasuryExpansion?: string;
              /**
               * A ratio of two integers, to express exact fractions.
               */
              decentralizationParameter?: string;
              minUtxoValue?: number;
              minPoolCost?: number;
              extraEntropy?: Neutral | string;
              protocolVersion?: {
                major: number;
                minor: number;
                patch?: number;
              };
            };
            initialDelegates: InitialDelegates;
            initialFunds: InitialFunds;
            /**
             * A Genesis stake pools configuration; primarily used for bootstrapping test networks.
             */
            initialPools: {
              pools: {
                [k: string]: {
                  /**
                   * A Blake2b 32-byte hash digest of a pool's verification key.
                   */
                  id: string;
                  owners: string[];
                  /**
                   * A number of lovelace, possibly large when summed up.
                   */
                  cost: bigint;
                  /**
                   * A ratio of two integers, to express exact fractions.
                   */
                  margin: string;
                  /**
                   * A number of lovelace, possibly large when summed up.
                   */
                  pledge: bigint;
                  /**
                   * A Blake2b 32-byte hash digest, encoded in base16.
                   */
                  vrf: string;
                  metadata?: PoolMetadata;
                  relays: (ByAddress | ByName)[];
                  /**
                   * A reward account, also known as 'stake address'.
                   */
                  rewardAccount: string;
                };
              };
              delegators: {
                /**
                 * A Blake2b 32-byte hash digest of a pool's verification key.
                 */
                [k: string]: string;
              };
            };
          };
        }
      | {
          /**
           * An Alonzo genesis configuration, with information used to bootstrap the era. Some parameters are also updatable across the era.
           */
          alonzo: {
            coinsPerUtxoWord: number;
            collateralPercentage: number;
            costModels: {
              [k: string]: {
                [k: string]: number;
              };
            };
            maxCollateralInputs: number;
            maxExecutionUnitsPerBlock: {
              memory: number;
              steps: number;
            };
            maxExecutionUnitsPerTransaction: {
              memory: number;
              steps: number;
            };
            maxValueSize: number;
            prices: {
              /**
               * A ratio of two integers, to express exact fractions.
               */
              memory: string;
              /**
               * A ratio of two integers, to express exact fractions.
               */
              steps: string;
            };
          };
        };
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface InitialDelegates {
  /**
   * A Genesis delegate, in charge of Cardano's governance.
   */
  [k: string]: {
    /**
     * A Blake2b 28-byte hash digest, encoded in base16.
     */
    delegate: string;
    /**
     * A Blake2b 32-byte hash digest, encoded in base16.
     */
    vrf: string;
  };
}
export interface InitialFunds {
  /**
   * A number of lovelace, possibly large when summed up.
   */
  [k: string]: bigint;
}
/**
 * Query the network start time.
 */
export interface QueryNetworkStartTime {
  jsonrpc: "2.0";
  method: "queryNetwork/startTime";
  params?: unknown;
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface QueryNetworkStartTimeResponse {
  jsonrpc: "2.0";
  result: {
    startTime: string;
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Get the current network tip. Said differently, this is the most recent slot and block header hash that the node it aware of.
 */
export interface QueryNetworkTip {
  jsonrpc: "2.0";
  method: "queryNetwork/tip";
  params?: unknown;
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface QueryNetworkTipResponse {
  jsonrpc: "2.0";
  result: {
    tip: Point | Origin;
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Acquire a mempool snapshot. This is blocking until a new (i.e different) snapshot is available.
 */
export interface AcquireMempool {
  jsonrpc: "2.0";
  method: "acquireMempool";
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Response to a 'acquireMempool' request.
 */
export interface AcquireMempoolResponse {
  jsonrpc: "2.0";
  result: {
    acquired: "mempool";
    /**
     * An absolute slot number.
     */
    slot: number;
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Request the next transaction from an acquired mempools napshot.
 */
export interface NextTransaction {
  jsonrpc: "2.0";
  method: "nextTransaction";
  params?: {
    fields?: "all";
  };
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Response to a 'nextTransaction' request.
 */
export interface NextTransactionResponse {
  jsonrpc: "2.0";
  /**
   * A transaction (or id) or an empty object if there's no more transactions.
   */
  result: {
    transaction:
      | {
          /**
           * A Blake2b 32-byte hash digest of a transaction body, CBOR-encoded.
           */
          id: string;
        }
      | Transaction
      | null;
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Ask whether a given transaction is present in the acquired mempool snapshot.
 */
export interface HasTransaction {
  jsonrpc: "2.0";
  method: "hasTransaction";
  params: {
    /**
     * A Blake2b 32-byte hash digest of a transaction body, CBOR-encoded.
     */
    id: string;
  };
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Response to a 'HasTransaction' request.
 */
export interface HasTransactionResponse {
  jsonrpc: "2.0";
  result: {
    hasTransaction: boolean;
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Get size and capacities of the mempool (acquired snapshot).
 */
export interface SizeOfMempool {
  jsonrpc: "2.0";
  method: "sizeOfMempool";
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Response to a 'sizeOfMempool' request.
 */
export interface SizeOfMempoolResponse {
  jsonrpc: "2.0";
  result: {
    mempool: MempoolSizeAndCapacity;
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface MempoolSizeAndCapacity {
  maxCapacity: {
    bytes: number;
  };
  currentSize: {
    bytes: number;
  };
  transactions: {
    count: number;
  };
}
/**
 * Release a previously acquired mempool snapshot.
 */
export interface ReleaseMempool {
  jsonrpc: "2.0";
  method: "releaseMempool";
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Response to a 'releaseMempool' request.
 */
export interface ReleaseMempoolResponse {
  jsonrpc: "2.0";
  result: {
    released: "mempool";
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * A generic error in the JSON-RPC protocol. This is returned by the server when a request from clients is deemed invalid or, when the server was unable to reply to a well-formed request.
 */
export interface RpcError {
  jsonrpc: "2.0";
  error: {
    /**
     * An error code telling about the nature of the error.
     */
    code: number;
    /**
     * A descriptive error message giving hints about the error.
     */
    message?: string;
    /**
     * Some optional data / context about the error. The exact type of this (optional) field depends on the error.
     */
    data?: {
      [k: string]: unknown;
    };
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
