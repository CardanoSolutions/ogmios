/* tslint:disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type PointOrOrigin = Point | Origin;
/**
 * An absolute slot number.
 */
export type Slot = number;
/**
 * A Blake2b 32-byte hash digest, encoded in base16.
 */
export type DigestBlake2B256 = string;
/**
 * The origin of the blockchain. This point is special in the sense that it doesn't point to any existing slots, but is preceding any existing other point.
 */
export type Origin = "origin";
export type TipOrOrigin = Tip | Origin;
/**
 * A block number, the i-th block to be minted is number i.
 */
export type BlockHeight = number;
export type Block = BlockEBB | BlockBFT | BlockPraos;
/**
 * The size of the block in bytes.
 */
export type BlockSize = number;
/**
 * A Blake2b 32-byte hash digest of a transaction body
 */
export type TransactionId = string;
export type UInt32 = number;
/**
 * A Cardano address (either legacy format or new format).
 */
export type Address = string;
/**
 * A number of asset, can be negative went burning assets.
 */
export type AssetQuantity = bigint;
export type Datum = string;
export type Script = Native | Plutus;
/**
 * A phase-1 monetary script. Timelocks constraints are only supported since Allegra.
 */
export type ScriptNative = Signatory | Any | All | Some | Before | After;
/**
 * A Blake2b 28-byte hash digest, encoded in base16.
 */
export type DigestBlake2B224 = string;
export type Certificate =
  | StakeDelegation
  | StakeCredentialRegistration
  | StakeCredentialDeregistration
  | StakePoolRegistration
  | StakePoolRetirement
  | GenesisDelegation
  | TreasuryTransfer;
/**
 * A Blake2b 32-byte hash digest of a pool's verification key.
 */
export type StakePoolId = string;
/**
 * A ratio of two integers, to express exact fractions.
 */
export type Ratio = string;
/**
 * A reward account, also known as 'stake address'.
 */
export type RewardAccount = string;
/**
 * A hash digest from an unspecified algorithm and length.
 */
export type DigestAny = string;
export type Relay = ByAddress | ByName;
/**
 * An epoch number or length.
 */
export type Epoch = number;
/**
 * An amount, possibly negative, in Lovelace (1e6 Lovelace = 1 Ada).
 */
export type LovelaceDelta = number;
/**
 * A network target, as defined since the Shelley era.
 */
export type Network = "mainnet" | "testnet";
export type UInt64 = number;
export type Nonce = Neutral | DigestBlake2B256;
export type Neutral = "neutral";
export type UInt321 = number;
export type Int64 = number;
export type CostModel = Int64[];
export type Metadatum =
  | bigint
  | string
  | Metadatum[]
  | {
      [k: string]: Metadatum;
    };
/**
 * Plutus data, CBOR-serialised.
 */
export type RedeemerData = string;
/**
 * An Ed25519 verification key.
 */
export type VerificationKey = string;
/**
 * An Ed25519-BIP32 Byron genesis delegate verification key with chain-code.
 */
export type ExtendedVerificationKey = string;
export type ProtocolMagicId = number;
export type GenesisHash = "genesis";
export type VrfProof = string;
export type VrfOutput = string;
export type KesVerificationKey = string;
export type SubmitTransactionFailure =
  | SubmitTransactionFailureEraMismatch
  | SubmitTransactionFailureInvalidSignatories
  | SubmitTransactionFailureMissingSignatories
  | SubmitTransactionFailureMissingScripts
  | SubmitTransactionFailureFailingNativeScript
  | SubmitTransactionFailureExtraneousScripts
  | SubmitTransactionFailureMissingMetadataHash
  | SubmitTransactionFailureMissingMetadata
  | SubmitTransactionFailureMetadataHashMismatch
  | SubmitTransactionFailureInvalidMetadata
  | SubmitTransactionFailureMissingRedeemers
  | SubmitTransactionFailureExtraneousRedeemers
  | SubmitTransactionFailureMissingDatums
  | SubmitTransactionFailureExtraneousDatums
  | SubmitTransactionFailureScriptIntegrityHashMismatch
  | SubmitTransactionFailureOrphanScriptInputs
  | SubmitTransactionFailureMissingCostModels
  | SubmitTransactionFailureMalformedScripts
  | SubmitTransactionFailureUnknownOutputReferences
  | SubmitTransactionFailureOutsideOfValidityInterval
  | SubmitTransactionFailureTransactionTooLarge
  | SubmitTransactionFailureValueTooLarge
  | SubmitTransactionFailureEmptyInputSet
  | SubmitTransactionFailureTransactionFeeTooSmall
  | SubmitTransactionFailureValueNotConserved
  | SubmitTransactionFailureNetworkMismatch
  | SubmitTransactionFailureInsufficientlyFundedOutputs
  | SubmitTransactionFailureBootstrapAttributesTooLarge
  | SubmitTransactionFailureMintingOrBurningAda
  | SubmitTransactionFailureInsufficientCollateral
  | SubmitTransactionFailureCollateralLockedByScript
  | SubmitTransactionFailureUnforeseeableSlot
  | SubmitTransactionFailureTooManyCollateralInputs
  | SubmitTransactionFailureMissingCollateralInputs
  | SubmitTransactionFailureNonAdaCollateral
  | SubmitTransactionFailureExecutionUnitsTooLarge
  | SubmitTransactionFailureTotalCollateralMismatch
  | SubmitTransactionFailureInputSourceMismatch
  | SubmitTransactionFailureUnauthorizedVote
  | SubmitTransactionFailureUnknownGovernanceAction
  | SubmitTransactionFailureInvalidProtocolParametersUpdate
  | SubmitTransactionFailureUnknownStakePool
  | SubmitTransactionFailureIncompleteWithdrawals
  | SubmitTransactionFailureRetirementTooLate
  | SubmitTransactionFailureStakePoolCostTooLow
  | SubmitTransactionFailureMetadataHashTooLarge
  | SubmitTransactionFailureCredentialAlreadyRegistered
  | SubmitTransactionFailureUnknownCredential
  | SubmitTransactionFailureNonEmptyRewardAccount
  | SubmitTransactionFailureInvalidGenesisDelegation
  | SubmitTransactionFailureInvalidMIRTransfer
  | SubmitTransactionFailureUnrecognizedCertificateType
  | SubmitTransactionFailureInternalLedgerTypeConversionError;
export type Era = "byron" | "shelley" | "allegra" | "mary" | "alonzo" | "babbage";
export type ScriptPurpose = Spend | Mint | Publish | Withdraw;
/**
 * A Blake2b 28-byte hash digest, encoded in base16.
 */
export type PolicyId = string;
export type RedeemerPointer = string;
export type Language = "plutus:v1" | "plutus:v2" | "plutus:v3";
export type VoterRole = "constitutionalCommittee" | "delegateRepresentative" | "stakePoolOperator";
export type Utxo = [TransactionOutputReference, TransactionOutput][];
export type EvaluateTransactionFailure =
  | EvaluateTransactionFailureIncompatibleEra
  | EvaluateTransactionFailureUnsupportedEra
  | EvaluateTransactionFailureOverlappingAdditionalUtxo
  | EvaluateTransactionFailureNodeTipTooOld
  | EvaluateTransactionFailureCannotCreateEvaluationContext
  | EvaluateTransactionFailureScriptExecutionFailure;
export type ScriptExecutionFailure =
  | ScriptExecutionFailureMissingScript
  | ScriptExecutionFailureValidationFailure
  | ScriptExecutionFailureUnsuitableOutputReference
  | SubmitTransactionFailureExtraneousRedeemers
  | SubmitTransactionFailureMissingDatums
  | SubmitTransactionFailureUnknownOutputReferences
  | SubmitTransactionFailureMissingCostModels
  | SubmitTransactionFailureInternalLedgerTypeConversionError;
/**
 * A time in seconds relative to another one (typically, system start or era start).
 */
export type RelativeTime = number;
/**
 * A slot length, in seconds, possibly with decimals.
 */
export type SlotLength = number;
/**
 * Number of slots from the tip of the ledger in which it is guaranteed that no hard fork can take place. This should be (at least) the number of slots in which we are guaranteed to have k blocks.
 */
export type SafeZone = number;
export type AnyStakeCredential = DigestBlake2B2241 | Bech32 | StakeAddress;
/**
 * A Blake2b 28-byte hash digest, encoded in base16.
 */
export type DigestBlake2B2241 = string;
/**
 * A Blake2b 28-byte hash digest of a verification key or script.
 */
export type Bech32 = string;
/**
 * A stake address (a.k.a reward account)
 */
export type StakeAddress = string;
export type EraWithGenesis = "byron" | "shelley" | "alonzo";
export type UtcTime = string;
/**
 * A magic number for telling networks apart. (e.g. 764824073)
 */
export type NetworkMagic = number;

export interface Ogmios {
  FindIntersection: FindIntersection;
  FindIntersectionResponse: IntersectionFound | IntersectionNotFound;
  NextBlock: NextBlock;
  NextBlockResponse: NextBlockResponse;
  SubmitTransaction: SubmitTransaction;
  SubmitTransactionResponse: SubmitTransactionSuccess | SubmitTransactionError | SubmitTransactionDeserialisationError;
  EvaluateTransaction: EvaluateTransaction;
  EvaluateTransactionResponse:
    | EvaluateTransactionSuccess
    | EvaluateTransactionError
    | EvaluateTransactionDeserialisationError;
  AcquireLedgerState: AcquireLedgerState;
  AcquireLedgerStateResponse: AcquireLedgerStateSuccess | AcquireLedgerStateFailure;
  ReleaseLedgerState: ReleaseLedgerState;
  ReleaseLedgerStateResponse: ReleaseLedgerStateResponse;
  QueryLedgerStateEraMismatch?: QueryLedgerStateEraMismatch;
  QueryLedgerStateUnavailableInCurrentEra?: QueryLedgerStateUnavailableInCurrentEra;
  QueryLedgerStateAcquiredExpire?: QueryLedgerStateAcquiredExpired;
  QueryLedgerStateEpoch: QueryLedgerStateEpoch;
  QueryLedgerStateEpochResponse:
    | QueryLedgerStateEpochResponse
    | QueryLedgerStateEraMismatch
    | QueryLedgerStateUnavailableInCurrentEra
    | QueryLedgerStateAcquiredExpired;
  QueryLedgerStateEraStart: QueryLedgerStateEraStart;
  QueryLedgerStateEraStartResponse:
    | QueryLedgerStateEraStartResponse
    | QueryLedgerStateEraMismatch
    | QueryLedgerStateUnavailableInCurrentEra
    | QueryLedgerStateAcquiredExpired;
  QueryLedgerStateEraSummaries: QueryLedgerStateEraSummaries;
  QueryLedgerStateEraSummariesResponse:
    | QueryLedgerStateEraSummariesResponse
    | QueryLedgerStateEraMismatch
    | QueryLedgerStateUnavailableInCurrentEra
    | QueryLedgerStateAcquiredExpired;
  QueryLedgerStateLiveStakeDistribution: QueryLedgerStateLiveStakeDistribution;
  QueryLedgerStateLiveStakeDistributionResponse:
    | QueryLedgerStateLiveStakeDistributionResponse
    | QueryLedgerStateEraMismatch
    | QueryLedgerStateUnavailableInCurrentEra
    | QueryLedgerStateAcquiredExpired;
  QueryLedgerStateProjectedRewards: QueryLedgerStateProjectedRewards;
  QueryLedgerStateProjectedRewardsResponse:
    | QueryLedgerStateProjectedRewardsResponse
    | QueryLedgerStateEraMismatch
    | QueryLedgerStateUnavailableInCurrentEra
    | QueryLedgerStateAcquiredExpired;
  QueryLedgerStateProposedProtocolParameters: QueryLedgerStateProposedProtocolParameters;
  QueryLedgerStateProposedProtocolParametersResponse:
    | QueryLedgerStateProposedProtocolParametersResponse
    | QueryLedgerStateEraMismatch
    | QueryLedgerStateUnavailableInCurrentEra
    | QueryLedgerStateAcquiredExpired;
  QueryLedgerStateProtocolParameters: QueryLedgerStateProtocolParameters;
  QueryLedgerStateProtocolParametersResponse:
    | QueryLedgerStateProtocolParametersResponse
    | QueryLedgerStateEraMismatch
    | QueryLedgerStateUnavailableInCurrentEra
    | QueryLedgerStateAcquiredExpired;
  QueryLedgerStateRewardAccountSummaries: QueryLedgerStateRewardAccountSummaries;
  QueryLedgerStateRewardAccountSummariesResponse:
    | QueryLedgerStateRewardAccountSummariesResponse
    | QueryLedgerStateEraMismatch
    | QueryLedgerStateUnavailableInCurrentEra
    | QueryLedgerStateAcquiredExpired;
  QueryLedgerStateRewardsProvenance: QueryLedgerStateRewardsProvenance;
  QueryLedgerStateRewardsProvenanceResponse:
    | QueryLedgerStateRewardsProvenanceResponse
    | QueryLedgerStateEraMismatch
    | QueryLedgerStateUnavailableInCurrentEra
    | QueryLedgerStateAcquiredExpired;
  QueryLedgerStateStakePools: QueryLedgerStateStakePools;
  QueryLedgerStateStakePoolsResponse:
    | QueryLedgerStateStakePoolsResponse
    | QueryLedgerStateEraMismatch
    | QueryLedgerStateUnavailableInCurrentEra
    | QueryLedgerStateAcquiredExpired;
  QueryLedgerStateStakePoolParameters: QueryLedgerStateStakePoolParameters;
  QueryLedgerStateStakePoolParametersResponse:
    | QueryLedgerStateStakePoolParametersResponse
    | QueryLedgerStateEraMismatch
    | QueryLedgerStateUnavailableInCurrentEra
    | QueryLedgerStateAcquiredExpired;
  QueryLedgerStateTip: QueryLedgerStateTip;
  QueryLedgerStateTipResponse:
    | QueryLedgerStateTipResponse
    | QueryLedgerStateEraMismatch
    | QueryLedgerStateUnavailableInCurrentEra
    | QueryLedgerStateAcquiredExpired;
  QueryLedgerStateUtxo: QueryLedgerStateUtxo;
  QueryLedgerStateUtxoResponse:
    | QueryLedgerStateUtxoResponse
    | QueryLedgerStateEraMismatch
    | QueryLedgerStateUnavailableInCurrentEra
    | QueryLedgerStateAcquiredExpired;
  QueryNetworkBlockHeight: QueryNetworkBlockHeight;
  QueryNetworkBlockHeightResponse: QueryNetworkBlockHeightResponse;
  QueryNetworkGenesisConfiguration: QueryNetworkGenesisConfiguration;
  QueryNetworkGenesisConfigurationResponse: QueryNetworkGenesisConfigurationResponse;
  QueryNetworkStartTime: QueryNetworkStartTime;
  QueryNetworkStartTimeResponse: QueryNetworkStartTimeResponse;
  QueryNetworkTip: QueryNetworkTip;
  QueryNetworkTipResponse: QueryNetworkTipResponse;
  AcquireMempool: AcquireMempool;
  AcquireMempoolResponse: AcquireMempoolResponse;
  NextTransaction: NextTransaction;
  NextTransactionResponse: NextTransactionResponse;
  HasTransaction: HasTransaction;
  HasTransactionResponse: HasTransactionResponse;
  SizeOfMempool: SizeOfMempool;
  SizeOfMempoolResponse?: SizeOfMempoolResponse;
  ReleaseMempool: ReleaseMempool;
  ReleaseMempoolResponse: ReleaseMempoolResponse;
  RpcError: RpcError;
}
/**
 * Ask cardano-node to find an intersection between its local chain and the given points.
 */
export interface FindIntersection {
  jsonrpc: "2.0";
  method: "findIntersection";
  params: {
    points?: PointOrOrigin[];
  };
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * A point on the chain, identified by a slot and a block header hash.
 */
export interface Point {
  slot: Slot;
  hash: DigestBlake2B256;
}
export interface IntersectionFound {
  jsonrpc: "2.0";
  method: "findIntersection";
  result: {
    intersection: PointOrOrigin;
    tip: TipOrOrigin;
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface Tip {
  slot: Slot;
  hash: DigestBlake2B256;
  blockNo: BlockHeight;
}
export interface IntersectionNotFound {
  jsonrpc: "2.0";
  method: "findIntersection";
  error: {
    code: 1000;
    message: string;
    data: {
      tip: TipOrOrigin;
    };
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Request next block from the current cardano-node's cursor.
 */
export interface NextBlock {
  jsonrpc: "2.0";
  method: "nextBlock";
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Response to a 'nextBlock' request.
 */
export interface NextBlockResponse {
  jsonrpc: "2.0";
  method: "nextBlock";
  result: RollForward | RollBackward;
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface RollForward {
  direction: "forward";
  tip: Tip;
  block: Block;
}
export interface BlockEBB {
  type: "ebb";
  era: "byron";
  header: {
    hash: DigestBlake2B256;
  };
  ancestor: DigestBlake2B256;
  height: BlockHeight;
}
export interface BlockBFT {
  type: "bft";
  era: "byron";
  header: {
    hash: DigestBlake2B256;
  };
  ancestor: DigestBlake2B256;
  height: BlockHeight;
  slot: Slot;
  size: BlockSize;
  transactions?: Transaction[];
  operationalCertificates?: BootstrapOperationalCertificate[];
  governanceAction?: BootstrapGovernanceAction;
  protocol: {
    magic: ProtocolMagicId;
    version: ProtocolVersion;
    software: SoftwareVersion;
  };
  issuer: {
    verificationKey: ExtendedVerificationKey;
  };
  delegate: {
    verificationKey: ExtendedVerificationKey;
  };
}
export interface Transaction {
  id: DigestBlake2B256;
  inputSource: "inputs" | "collaterals";
  inputs: TransactionOutputReference[];
  references?: TransactionOutputReference[];
  collaterals?: TransactionOutputReference[];
  collateral?: Lovelace;
  collateralReturn?: TransactionOutput;
  outputs: TransactionOutput[];
  certificates?: Certificate[];
  withdrawals?: Withdrawals;
  fee?: Lovelace;
  validityInterval?: ValidityInterval;
  mint?: Assets;
  network?: Network;
  scriptIntegrityHash?: DigestBlake2B256;
  requiredExtraSignatories?: DigestBlake2B224[];
  governanceActions?: UpdateProposalShelley[] | UpdateProposalAlonzo[] | UpdateProposalBabbage[];
  metadata?: Metadata;
  signatories: unknown[];
  scripts?: {
    [k: string]: Script;
  };
  datums?: {
    [k: string]: Datum;
  };
  redeemers?: {
    [k: string]: Redeemer;
  };
  /**
   * The raw serialized (CBOR) transaction, as found on-chain.
   */
  cbor: string;
}
export interface TransactionOutputReference {
  transaction: {
    id: TransactionId;
  };
  output: {
    index: UInt32;
  };
}
export interface Lovelace {
  /**
   * A number of lovelace, possibly large when summed up.
   */
  lovelace: bigint;
}
/**
 * A transaction output. Since Mary, 'value' always return a multi-asset value. Since Alonzo, 'datumHash' is always present (albeit sometimes 'null'). Since Babbage, 'datum' & 'script' are always present (albeit sometimes 'null').
 */
export interface TransactionOutput {
  address: Address;
  value: Value;
  datumHash?: DigestBlake2B256;
  datum?: Datum;
  script?: Script;
}
export interface Value {
  ada: {
    lovelace: bigint;
  };
  [k: string]: {
    [k: string]: AssetQuantity;
  };
}
export interface Native {
  language: "native";
  json: ScriptNative;
  cbor: string;
}
export interface Signatory {
  clause: "signature";
  from: DigestBlake2B224;
}
export interface Any {
  clause: "any";
  from: ScriptNative[];
}
export interface All {
  clause: "all";
  from: ScriptNative[];
}
export interface Some {
  clause: "some";
  atLeast: bigint;
  from: ScriptNative[];
}
export interface Before {
  clause: "before";
  slot: Slot;
}
export interface After {
  clause: "after";
  slot: Slot;
}
export interface Plutus {
  language: "plutus:v1" | "plutus:v2" | "plutus:v3";
  cbor: string;
}
/**
 * A stake delegation certificate, from a delegator to a stake pool.
 */
export interface StakeDelegation {
  type: "stakeDelegation";
  credential: DigestBlake2B224;
  stakePool: {
    id: StakePoolId;
  };
}
/**
 * A stake credential (key or script) registration certificate.
 */
export interface StakeCredentialRegistration {
  type: "stakeCredentialRegistration";
  credential: DigestBlake2B224;
}
/**
 * A stake key de-registration certificate.
 */
export interface StakeCredentialDeregistration {
  type: "stakeCredentialDeregistration";
  credential: DigestBlake2B224;
}
/**
 * A stake pool registration certificate.
 */
export interface StakePoolRegistration {
  type: "stakePoolRegistration";
  stakePool: {
    id: StakePoolId;
    parameters: StakePoolParameters;
  };
}
export interface StakePoolParameters {
  owners: DigestBlake2B224[];
  vrfVerificationKeyHash: DigestBlake2B256;
  cost: Lovelace;
  margin: Ratio;
  pledge: Lovelace;
  rewardAccount: RewardAccount;
  metadata?: PoolMetadata;
  relays: Relay[];
}
export interface PoolMetadata {
  hash: DigestAny;
  url: string;
}
export interface ByAddress {
  type: "ipAddress";
  ipv4?: string;
  ipv6?: string;
  port?: number;
}
export interface ByName {
  type: "hostname";
  hostname: string;
  port?: number;
}
/**
 * A stake pool retirement certificate.
 */
export interface StakePoolRetirement {
  type: "stakePoolRetirement";
  stakePool: {
    retirementEpoch: Epoch;
    id: StakePoolId;
  };
}
export interface GenesisDelegation {
  type: "genesisDelegation";
  delegate: {
    verificationKeyHash: DigestBlake2B224;
  };
  issuer: {
    verificationKeyHash: DigestBlake2B224;
    vrfVerificationKeyHash: DigestBlake2B256;
  };
}
/**
 * A transfer from or to the treasury / reserves authored by genesis delegates. 'rewards' is only present when target is 'rewardsAccounts'; 'value' is only present when target is 'reserves' or 'treasury'.
 */
export interface TreasuryTransfer {
  type: "treasuryTransfer";
  source: "reserves" | "treasury";
  target: "reserves" | "treasury" | "rewardAccounts";
  rewards?: RewardTransfer;
  value?: Lovelace;
}
export interface RewardTransfer {
  [k: string]: LovelaceDelta;
}
export interface Withdrawals {
  [k: string]: Lovelace;
}
export interface ValidityInterval {
  invalidBefore?: Slot;
  invalidAfter?: Slot;
}
export interface Assets {
  [k: string]: {
    [k: string]: AssetQuantity;
  };
}
export interface UpdateProposalShelley {
  epoch: Epoch;
  proposal: {
    [k: string]: ProtocolParametersShelley;
  };
}
export interface ProtocolParametersShelley {
  minFeeCoefficient?: UInt64;
  minFeeConstant?: Lovelace;
  maxBlockBodySize?: UInt64;
  maxBlockHeaderSize?: UInt64;
  maxTxSize?: UInt64;
  stakeKeyDeposit?: Lovelace;
  poolDeposit?: Lovelace;
  poolRetirementEpochBound?: UInt64;
  desiredNumberOfPools?: UInt64;
  poolInfluence?: Ratio;
  monetaryExpansion?: Ratio;
  treasuryExpansion?: Ratio;
  decentralizationParameter?: Ratio;
  minUtxoValue?: Lovelace;
  minPoolCost?: Lovelace;
  extraEntropy?: Nonce;
  protocolVersion?: ProtocolVersion;
}
export interface ProtocolVersion {
  major: UInt321;
  minor: UInt321;
  patch?: UInt321;
}
export interface UpdateProposalAlonzo {
  epoch: Epoch;
  proposal: {
    [k: string]: ProtocolParametersAlonzo;
  };
}
export interface ProtocolParametersAlonzo {
  minFeeCoefficient?: UInt64;
  minFeeConstant?: Lovelace;
  maxBlockBodySize?: UInt64;
  maxBlockHeaderSize?: UInt64;
  maxTxSize?: UInt64;
  stakeKeyDeposit?: Lovelace;
  poolDeposit?: Lovelace;
  poolRetirementEpochBound?: UInt64;
  desiredNumberOfPools?: UInt64;
  poolInfluence?: Ratio;
  monetaryExpansion?: Ratio;
  treasuryExpansion?: Ratio;
  decentralizationParameter?: Ratio;
  minPoolCost?: Lovelace;
  coinsPerUtxoWord?: UInt64;
  maxValueSize?: UInt64;
  collateralPercentage?: UInt64;
  maxCollateralInputs?: UInt64;
  extraEntropy?: Nonce;
  protocolVersion?: ProtocolVersion;
  costModels?: CostModels;
  prices?: Prices;
  maxExecutionUnitsPerTransaction?: ExecutionUnits;
  maxExecutionUnitsPerBlock?: ExecutionUnits;
}
export interface CostModels {
  [k: string]: CostModel;
}
export interface Prices {
  memory: Ratio;
  steps: Ratio;
}
export interface ExecutionUnits {
  memory: UInt64;
  steps: UInt64;
}
export interface UpdateProposalBabbage {
  epoch: Epoch;
  proposal: {
    [k: string]: ProtocolParametersBabbage;
  };
}
export interface ProtocolParametersBabbage {
  minFeeCoefficient?: UInt64;
  minFeeConstant?: Lovelace;
  maxBlockBodySize?: UInt64;
  maxBlockHeaderSize?: UInt64;
  maxTxSize?: UInt64;
  stakeKeyDeposit?: Lovelace;
  poolDeposit?: Lovelace;
  poolRetirementEpochBound?: UInt64;
  desiredNumberOfPools?: UInt64;
  poolInfluence?: Ratio;
  monetaryExpansion?: Ratio;
  treasuryExpansion?: Ratio;
  minPoolCost?: Lovelace;
  coinsPerUtxoByte?: UInt64;
  maxValueSize?: UInt64;
  collateralPercentage?: UInt64;
  maxCollateralInputs?: UInt64;
  protocolVersion?: ProtocolVersion;
  costModels?: CostModels;
  prices?: Prices;
  maxExecutionUnitsPerTransaction?: ExecutionUnits;
  maxExecutionUnitsPerBlock?: ExecutionUnits;
}
export interface Metadata {
  hash: DigestBlake2B256;
  labels: MetadataLabels;
}
export interface MetadataLabels {
  /**
   * An associated metadatum, as a CBOR bytestring or a JSON object if possible. Some binary representations cannot be represented in plain JSON and the 'json' field is therefore omitted.
   */
  [k: string]: {
    cbor: string;
    json?: Metadatum;
  };
}
export interface Redeemer {
  redeemer: RedeemerData;
  executionUnits: ExecutionUnits;
}
/**
 * A (Byron) delegation certificate.
 */
export interface BootstrapOperationalCertificate {
  issuer: {
    verificationKey: VerificationKey;
  };
  delegate: {
    verificationKey: VerificationKey;
  };
}
export interface BootstrapGovernanceAction {
  proposal?: {
    protocol: {
      version: ProtocolVersion;
      software: SoftwareVersion;
    };
    metadata: {
      [k: string]: string;
    };
    parameters: ProtocolParametersByron;
    issuer: {
      verificationKey: ExtendedVerificationKey;
    };
  };
  votes: BootstrapVote[];
}
export interface SoftwareVersion {
  appName: string;
  number: UInt321;
}
export interface ProtocolParametersByron {
  heavyDlgThreshold?: Ratio;
  maxBlockSize?: UInt64;
  maxHeaderSize?: UInt64;
  maxProposalSize?: UInt64;
  maxTxSize?: UInt64;
  mpcThreshold?: Ratio;
  scriptVersion?: UInt64;
  slotDuration?: UInt64;
  unlockStakeEpoch?: UInt64;
  updateProposalThreshold?: Ratio;
  updateProposalTimeToLive?: UInt64;
  updateVoteThreshold?: Ratio;
  txFeePolicy?: TxFeePolicy;
  softforkRule?: SoftForkRule;
}
export interface TxFeePolicy {
  coefficient: Ratio;
  constant: Lovelace;
}
export interface SoftForkRule {
  initThreshold: Ratio;
  minThreshold: Ratio;
  decrementThreshold: Ratio;
}
export interface BootstrapVote {
  voter: {
    verificationKey: VerificationKey;
  };
  proposal: {
    hash: DigestBlake2B256;
  };
}
export interface BlockPraos {
  type: "praos";
  era: "shelley" | "allegra" | "mary" | "alonzo" | "babbage";
  header: {
    hash: DigestBlake2B256;
  };
  ancestor: DigestBlake2B256 | GenesisHash;
  nonce?: CertifiedVrf;
  height: BlockHeight;
  size: BlockSize;
  slot: Slot;
  transactions?: Transaction[];
  protocol: {
    version: ProtocolVersion;
  };
  issuer: {
    verificationKey: VerificationKey;
    vrfVerificationKey: VerificationKey;
    operationalCertificate: OperationalCertificate;
    leaderValue: CertifiedVrf;
  };
}
export interface CertifiedVrf {
  proof?: VrfProof;
  output?: VrfOutput;
}
/**
 * Certificate identifying a stake pool operator.
 */
export interface OperationalCertificate {
  count: UInt64;
  kes: {
    period: UInt64;
    verificationKey: KesVerificationKey;
  };
}
export interface RollBackward {
  direction: "backward";
  tip: TipOrOrigin;
  point: PointOrOrigin;
}
/**
 * Submit a signed and serialized transaction to the network.
 */
export interface SubmitTransaction {
  jsonrpc: "2.0";
  method: "submitTransaction";
  params: {
    /**
     * CBOR-serialized signed transaction (base16)
     */
    transaction: string;
  };
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface SubmitTransactionSuccess {
  jsonrpc: "2.0";
  method: "submitTransaction";
  result: {
    transaction: {
      id: TransactionId;
    };
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface SubmitTransactionError {
  jsonrpc: "2.0";
  method: "submitTransaction";
  error: SubmitTransactionFailure;
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Failed to submit the transaction in the current era. This may happen when trying to submit a transaction near an era boundary (i.e. at the moment of a hard-fork).
 */
export interface SubmitTransactionFailureEraMismatch {
  code: 3005;
  message: string;
  data: EraMismatch;
}
export interface EraMismatch {
  queryEra: Era;
  ledgerEra: Era;
}
export interface SubmitTransactionFailureInvalidSignatories {
  code: 3100;
  message: string;
  data: {
    invalidSignatories: VerificationKey[];
  };
}
export interface SubmitTransactionFailureMissingSignatories {
  code: 3101;
  message: string;
  data: {
    missingSignatories: DigestBlake2B224[];
  };
}
export interface SubmitTransactionFailureMissingScripts {
  code: 3102;
  message: string;
  data: {
    missingScripts: DigestBlake2B224[];
  };
}
export interface SubmitTransactionFailureFailingNativeScript {
  code: 3103;
  message: string;
  data: {
    failingNativeScripts: DigestBlake2B224[];
  };
}
export interface SubmitTransactionFailureExtraneousScripts {
  code: 3104;
  message: string;
  data: {
    extraneousScripts: DigestBlake2B224[];
  };
}
export interface SubmitTransactionFailureMissingMetadataHash {
  code: 3105;
  message: string;
  data: {
    metadata: {
      hash: DigestBlake2B256;
    };
  };
}
export interface SubmitTransactionFailureMissingMetadata {
  code: 3106;
  message: string;
  data: {
    metadata: {
      hash: DigestBlake2B256;
    };
  };
}
export interface SubmitTransactionFailureMetadataHashMismatch {
  code: 3107;
  message: string;
  data: {
    provided: {
      hash: DigestBlake2B256;
    };
    computed: {
      hash: DigestBlake2B256;
    };
  };
}
export interface SubmitTransactionFailureInvalidMetadata {
  code: 3108;
  message: string;
}
export interface SubmitTransactionFailureMissingRedeemers {
  code: 3109;
  message: string;
  data: {
    missingRedeemers: ScriptPurpose[];
  };
}
export interface Spend {
  purpose: "spend";
  outputReference: TransactionOutputReference;
}
export interface Mint {
  purpose: "mint";
  policy: PolicyId;
}
export interface Publish {
  purpose: "publish";
  certificate: Certificate;
}
export interface Withdraw {
  purpose: "withdraw";
  rewardAccount: RewardAccount;
}
export interface SubmitTransactionFailureExtraneousRedeemers {
  code: 3110;
  message: string;
  data: {
    extraneousRedeemers: RedeemerPointer[];
  };
}
export interface SubmitTransactionFailureMissingDatums {
  code: 3111;
  message: string;
  data: {
    missingDatums: DigestBlake2B256[];
  };
}
export interface SubmitTransactionFailureExtraneousDatums {
  code: 3112;
  message: string;
  data: {
    extraneousDatums: DigestBlake2B256[];
  };
}
export interface SubmitTransactionFailureScriptIntegrityHashMismatch {
  code: 3113;
  message: string;
  data: {
    providedScriptIntegrity: DigestBlake2B256 | null;
    computedScriptIntegrity: DigestBlake2B256 | null;
  };
}
export interface SubmitTransactionFailureOrphanScriptInputs {
  code: 3114;
  message: string;
  data: {
    orphanInputs?: TransactionOutputReference[];
  };
}
export interface SubmitTransactionFailureMissingCostModels {
  code: 3115;
  message: string;
  data: {
    missingCostModels: Language[];
  };
}
export interface SubmitTransactionFailureMalformedScripts {
  code: 3116;
  message: string;
  data: {
    malformedScripts: DigestBlake2B224[];
  };
}
export interface SubmitTransactionFailureUnknownOutputReferences {
  code: 3117;
  message: string;
  data: {
    unknownOutputReferences: TransactionOutputReference[];
  };
}
export interface SubmitTransactionFailureOutsideOfValidityInterval {
  code: 3118;
  message: string;
  data: {
    validityInterval: ValidityInterval;
    currentSlot: Slot;
  };
}
export interface SubmitTransactionFailureTransactionTooLarge {
  code: 3119;
  message: string;
  data: {
    measuredTransactionSize: NumberOfBytes;
    maximumTransactionSize: {
      [k: string]: unknown;
    };
  };
}
export interface NumberOfBytes {
  bytes: Int64;
}
export interface SubmitTransactionFailureValueTooLarge {
  code: 3120;
  message: string;
  data: {
    excessivelyLargeOutputs: TransactionOutput[];
  };
}
export interface SubmitTransactionFailureEmptyInputSet {
  code: 3121;
  message: string;
}
export interface SubmitTransactionFailureTransactionFeeTooSmall {
  code: 3122;
  message: string;
  data: {
    minimumRequiredFee: Lovelace;
    providedFee: Lovelace;
  };
}
export interface SubmitTransactionFailureValueNotConserved {
  code: 3123;
  message: string;
  data: {
    valueConsumed: Value;
    valueProduced: Value;
  };
}
export interface SubmitTransactionFailureNetworkMismatch {
  code: 3124;
  message: string;
  data:
    | {
        expectedNetwork: Network;
        discriminatedType: "address";
        invalidEntities: Address[];
      }
    | {
        expectedNetwork: Network;
        discriminatedType: "rewardAccount";
        invalidEntities: RewardAccount[];
      }
    | {
        expectedNetwork: Network;
        discriminatedType: "stakePoolCertificate";
        invalidEntities: StakePoolId[];
      }
    | {
        expectedNetwork: Network;
        discriminatedType: "transaction";
      };
}
export interface SubmitTransactionFailureInsufficientlyFundedOutputs {
  code: 3125;
  message: string;
  data: {
    insufficientlyFundedOutputs: {
      output: TransactionOutput;
      minimumRequiredValue?: Lovelace;
    }[];
  };
}
export interface SubmitTransactionFailureBootstrapAttributesTooLarge {
  code: 3126;
  message: string;
  data: {
    bootstrapOutputs: TransactionOutput[];
  };
}
export interface SubmitTransactionFailureMintingOrBurningAda {
  code: 3127;
  message: string;
}
export interface SubmitTransactionFailureInsufficientCollateral {
  code: 3128;
  message: string;
  data: {
    providedCollateral: Lovelace;
    minimumRequiredCollateral: Lovelace;
  };
}
export interface SubmitTransactionFailureCollateralLockedByScript {
  code: 3129;
  message: string;
  data: {
    unsuitableCollateralInputs: TransactionOutputReference[];
  };
}
export interface SubmitTransactionFailureUnforeseeableSlot {
  code: 3130;
  message: string;
  data: {
    unforeseeableSlot: Slot;
  };
}
export interface SubmitTransactionFailureTooManyCollateralInputs {
  code: 3131;
  message: string;
  data: {
    maximumCollateralInputs: UInt321;
    countedCollateralInputs: UInt321;
  };
}
export interface SubmitTransactionFailureMissingCollateralInputs {
  code: 3132;
  message: string;
}
export interface SubmitTransactionFailureNonAdaCollateral {
  code: 3133;
  message: string;
  data: {
    "unsuitableCollateralInputs'"?: Value;
  };
}
export interface SubmitTransactionFailureExecutionUnitsTooLarge {
  code: 3134;
  message: string;
  data: {
    providedExecutionUnits: ExecutionUnits;
    maximumExecutionUnits: ExecutionUnits;
  };
}
export interface SubmitTransactionFailureTotalCollateralMismatch {
  code: 3135;
  message: string;
  data: {
    declaredTotalCollateral: Lovelace;
    computedTotalCollateral: Lovelace;
  };
}
export interface SubmitTransactionFailureInputSourceMismatch {
  code: 3136;
  message: string;
  data: {
    inputSource: "inputs" | "collaterals";
    mismatchReason: string;
  };
}
export interface SubmitTransactionFailureUnauthorizedVote {
  code: 3137;
  message: string;
  data: {
    unauthorizedVoter: DigestBlake2B224;
    requiredRole: VoterRole;
  };
}
export interface SubmitTransactionFailureUnknownGovernanceAction {
  code: 3138;
  message: string;
  data: {
    unknownGovernanceAction: GovernanceActionReference;
  };
}
export interface GovernanceActionReference {
  transaction: {
    id: TransactionId;
  };
  governanceAction: {
    index: UInt32;
  };
}
export interface SubmitTransactionFailureInvalidProtocolParametersUpdate {
  code: 3139;
  message: string;
}
export interface SubmitTransactionFailureUnknownStakePool {
  code: 3140;
  message: string;
  data: {
    unknownStakePool: StakePoolId;
  };
}
export interface SubmitTransactionFailureIncompleteWithdrawals {
  code: 3141;
  message: string;
  data: {
    incompleteWithdrawals: Withdrawals;
  };
}
export interface SubmitTransactionFailureRetirementTooLate {
  code: 3142;
  message: string;
  data: {
    currentEpoch: Epoch;
    declaredEpoch: Epoch;
    firstInvalidEpoch: Epoch;
  };
}
export interface SubmitTransactionFailureStakePoolCostTooLow {
  code: 3143;
  message: string;
  data: {
    minimumStakePoolCost: Lovelace;
    declaredStakePoolCost: Lovelace;
  };
}
export interface SubmitTransactionFailureMetadataHashTooLarge {
  code: 3144;
  message: string;
  data: {
    infringingStakePool: StakePoolId;
    computedMetadataHashSize: NumberOfBytes;
  };
}
export interface SubmitTransactionFailureCredentialAlreadyRegistered {
  code: 3145;
  message: string;
  data: {
    knownCredential: DigestBlake2B224;
  };
}
export interface SubmitTransactionFailureUnknownCredential {
  code: 3146;
  message: string;
  data: {
    unknownCredential: DigestBlake2B224;
  };
}
export interface SubmitTransactionFailureNonEmptyRewardAccount {
  code: 3147;
  message: string;
  data: {
    nonEmptyRewardAccountBalance: Lovelace;
  };
}
export interface SubmitTransactionFailureInvalidGenesisDelegation {
  code: 3148;
  message: string;
}
export interface SubmitTransactionFailureInvalidMIRTransfer {
  code: 3149;
  message: string;
}
export interface SubmitTransactionFailureUnrecognizedCertificateType {
  code: 3998;
  message: string;
}
export interface SubmitTransactionFailureInternalLedgerTypeConversionError {
  code: 3999;
  message: string;
}
export interface SubmitTransactionDeserialisationError {
  jsonrpc: "2.0";
  method: "submitTransaction";
  error: DeserialisationFailure;
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * The input failed to deserialize in any of the known era.
 */
export interface DeserialisationFailure {
  code: -32602;
  message: string;
  data: {
    shelley: string;
    allegra: string;
    mary: string;
    alonzo: string;
    babbage: string;
    conway: string;
  };
}
/**
 * Evaluate execution units for which redeemers's budget hasn't yet been set.
 */
export interface EvaluateTransaction {
  jsonrpc: "2.0";
  method: "evaluateTransaction";
  params: {
    /**
     * CBOR-serialized signed transaction (base16)
     */
    transaction: string;
    additionalUtxoSet?: Utxo;
  };
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface EvaluateTransactionSuccess {
  jsonrpc: "2.0";
  method: "evaluateTransaction";
  result: {
    validator: RedeemerPointer;
    budget: ExecutionUnits;
  }[];
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Happens when attempting to evaluate execution units on a node that isn't enough synchronized.
 */
export interface EvaluateTransactionError {
  jsonrpc: "2.0";
  method: "evaluateTransaction";
  error: EvaluateTransactionFailure;
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Returned when trying to evaluate execution units of a pre-Alonzo transaction. Note that this isn't possible with Ogmios because transactions are always de-serialized as Alonzo transactions.
 */
export interface EvaluateTransactionFailureIncompatibleEra {
  code: 3000;
  message: string;
  /**
   * The era in which the transaction has been identified.
   */
  data: {
    incompatibleEra: Era;
  };
}
/**
 * Returned when trying to evaluate execution units of an era that is now considered too old and is no longer supported. This can solved by using a more recent transaction format.
 */
export interface EvaluateTransactionFailureUnsupportedEra {
  code: 3001;
  message: string;
  /**
   * The era in which the transaction has been identified.
   */
  data: {
    unsupportedEra: Era;
  };
}
/**
 * Happens when providing an additional UTXO set which overlaps with the UTXO on-chain.
 */
export interface EvaluateTransactionFailureOverlappingAdditionalUtxo {
  code: 3002;
  message: string;
  data: {
    overlappingOutputReferences: TransactionOutputReference[];
  };
}
/**
 * Happens when attempting to evaluate execution units on a node that isn't enough synchronized.
 */
export interface EvaluateTransactionFailureNodeTipTooOld {
  code: 3003;
  message: string;
  data: {
    minimumRequiredEra: Era;
    currentNodeEra: Era;
  };
}
/**
 * The transaction is malformed or missing information; making evaluation impossible.
 */
export interface EvaluateTransactionFailureCannotCreateEvaluationContext {
  code: 3004;
  message: string;
  data: {
    reason: string;
  };
}
/**
 * One or more script execution terminated with an error.
 */
export interface EvaluateTransactionFailureScriptExecutionFailure {
  code: 3010;
  message: string;
  data: {
    validator: RedeemerPointer;
    error: ScriptExecutionFailure;
  }[];
}
export interface ScriptExecutionFailureMissingScript {
  code: 3011;
  message: string;
}
export interface ScriptExecutionFailureValidationFailure {
  code: 3012;
  message: string;
  data: {
    validationError: string;
    traces: string[];
  };
}
export interface ScriptExecutionFailureUnsuitableOutputReference {
  code: 3013;
  message: string;
  data: {
    unsuitableOutputReference: TransactionOutputReference;
  };
}
export interface EvaluateTransactionDeserialisationError {
  jsonrpc: "2.0";
  method: "evaluateTransaction";
  error: DeserialisationFailure;
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Acquire a point on chain from which to run ledger-state queries.
 */
export interface AcquireLedgerState {
  jsonrpc: "2.0";
  method: "acquireLedgerState";
  params: {
    point: PointOrOrigin;
  };
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Response to an 'acquireLedgerState' request.
 */
export interface AcquireLedgerStateSuccess {
  jsonrpc: "2.0";
  method: "acquireLedgerState";
  result: AcquireLedgerStateSuccess1;
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface AcquireLedgerStateSuccess1 {
  acquired: "ledgerState";
  point: PointOrOrigin;
}
/**
 * Unable to acquire the ledger state at the request point.
 */
export interface AcquireLedgerStateFailure {
  jsonrpc: "2.0";
  method: "acquireLedgerState";
  error: AcquireLedgerStateFailure1;
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface AcquireLedgerStateFailure1 {
  code: 2000;
  message: string;
  /**
   * A reason for the failure.
   */
  data: string;
}
/**
 * Release a previously acquired ledger state.
 */
export interface ReleaseLedgerState {
  jsonrpc: "2.0";
  method: "releaseLedgerState";
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Response to a 'releaseLedgerState' request.
 */
export interface ReleaseLedgerStateResponse {
  jsonrpc: "2.0";
  method: "releaseLedgerState";
  result: {
    released: "ledgerState";
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * An era mismatch between a client request and the era the ledger is in. This may occur when running queries on a syncing node and/or when the node is crossing an era.
 */
export interface QueryLedgerStateEraMismatch {
  jsonrpc: "2.0";
  method:
    | "queryLedgerState/epoch"
    | "queryLedgerState/eraStart"
    | "queryLedgerState/eraSummaries"
    | "queryLedgerState/liveStakeDistribution"
    | "queryLedgerState/projectedRewards"
    | "queryLedgerState/protocolParameters"
    | "queryLedgerState/proposedProtocolParameters"
    | "queryLedgerState/rewardAccountSummaries"
    | "queryLedgerState/rewardsProvenance"
    | "queryLedgerState/stakePoolParameters"
    | "queryLedgerState/stakePools"
    | "queryLedgerState/utxo"
    | "queryLedgerState/tip";
  error: {
    code: 2001;
    message: string;
    data: EraMismatch;
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Some query is not available for the requested ledger era.
 */
export interface QueryLedgerStateUnavailableInCurrentEra {
  jsonrpc: "2.0";
  method:
    | "queryLedgerState/epoch"
    | "queryLedgerState/eraStart"
    | "queryLedgerState/eraSummaries"
    | "queryLedgerState/liveStakeDistribution"
    | "queryLedgerState/projectedRewards"
    | "queryLedgerState/protocolParameters"
    | "queryLedgerState/proposedProtocolParameters"
    | "queryLedgerState/rewardAccountSummaries"
    | "queryLedgerState/rewardsProvenance"
    | "queryLedgerState/stakePoolParameters"
    | "queryLedgerState/stakePools"
    | "queryLedgerState/utxo"
    | "queryLedgerState/tip";
  error: {
    code: 2002;
    message: string;
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Previously acquired ledger state is no longer available.
 */
export interface QueryLedgerStateAcquiredExpired {
  jsonrpc: "2.0";
  method:
    | "queryLedgerState/epoch"
    | "queryLedgerState/eraStart"
    | "queryLedgerState/eraSummaries"
    | "queryLedgerState/liveStakeDistribution"
    | "queryLedgerState/projectedRewards"
    | "queryLedgerState/protocolParameters"
    | "queryLedgerState/proposedProtocolParameters"
    | "queryLedgerState/rewardAccountSummaries"
    | "queryLedgerState/rewardsProvenance"
    | "queryLedgerState/stakePoolParameters"
    | "queryLedgerState/stakePools"
    | "queryLedgerState/utxo"
    | "queryLedgerState/tip";
  error: {
    code: 2003;
    message: string;
    /**
     * A reason for the failure.
     */
    data: string;
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Query the current epoch number the ledger is at.
 */
export interface QueryLedgerStateEpoch {
  jsonrpc: "2.0";
  method: "queryLedgerState/epoch";
  params?: unknown;
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface QueryLedgerStateEpochResponse {
  jsonrpc: "2.0";
  method: "queryLedgerState/epoch";
  result: Epoch;
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Query the start of the current ledger era.
 */
export interface QueryLedgerStateEraStart {
  jsonrpc: "2.0";
  method: "queryLedgerState/eraStart";
  params?: unknown;
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface QueryLedgerStateEraStartResponse {
  jsonrpc: "2.0";
  method: "queryLedgerState/eraStart";
  result: Bound;
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * An era bound which captures the time, slot and epoch at which the era start. The time is relative to the start time of the network.
 */
export interface Bound {
  time: RelativeTime;
  slot: Slot;
  epoch: Epoch;
}
/**
 * Query a summary of the slotting parameters and boundaries for each known era. Useful for doing slot-arithmetic and time conversions.
 */
export interface QueryLedgerStateEraSummaries {
  jsonrpc: "2.0";
  method: "queryLedgerState/eraSummaries";
  params?: unknown;
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface QueryLedgerStateEraSummariesResponse {
  jsonrpc: "2.0";
  method: "queryLedgerState/eraSummaries";
  result: EraSummary[];
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Summary of the confirmed parts of the ledger.
 */
export interface EraSummary {
  start: Bound;
  end: Bound | null;
  parameters: EraParameters;
}
/**
 * Parameters that can vary across hard forks.
 */
export interface EraParameters {
  epochLength: Epoch;
  slotLength: SlotLength;
  safeZone: SafeZone | null;
}
/**
 * Query the current distribution of the stake across all known stake pools, relative to the TOTAL stake in the network.
 */
export interface QueryLedgerStateLiveStakeDistribution {
  jsonrpc: "2.0";
  method: "queryLedgerState/liveStakeDistribution";
  params?: unknown;
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface QueryLedgerStateLiveStakeDistributionResponse {
  jsonrpc: "2.0";
  method: "queryLedgerState/liveStakeDistribution";
  result: LiveStakeDistribution;
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Distribution of stake across registered stake pools. Each key in the map corresponds to a pool id.
 */
export interface LiveStakeDistribution {
  [k: string]: {
    stake: Ratio;
    vrf: DigestBlake2B256;
  };
}
/**
 * Query the projected rewards of an account in a context where the top stake pools are fully saturated. This projection gives, in principle, a ranking of stake pools that maximizes delegator rewards.
 */
export interface QueryLedgerStateProjectedRewards {
  jsonrpc: "2.0";
  method: "queryLedgerState/projectedRewards";
  params: {
    stake?: Lovelace[];
    scripts?: AnyStakeCredential[];
    keys?: AnyStakeCredential[];
  };
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface QueryLedgerStateProjectedRewardsResponse {
  jsonrpc: "2.0";
  method: "queryLedgerState/projectedRewards";
  result: ProjectedRewards;
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Rewards that can be expected assuming a pool is fully saturated. Such rewards are said non-myopic, in opposition to short-sighted rewards looking at immediate benefits. Keys of the map can be either Lovelace amounts or account credentials depending on the query.
 */
export interface ProjectedRewards {
  [k: string]: {
    [k: string]: Lovelace;
  };
}
/**
 * Query the last update proposal w.r.t. protocol parameters, if any.
 */
export interface QueryLedgerStateProposedProtocolParameters {
  jsonrpc: "2.0";
  method: "queryLedgerState/proposedProtocolParameters";
  params?: unknown;
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface QueryLedgerStateProposedProtocolParametersResponse {
  jsonrpc: "2.0";
  method: "queryLedgerState/proposedProtocolParameters";
  result: ProposedProtocolParametersShelley | ProposedProtocolParametersAlonzo | ProposedProtocolParametersBabbage;
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface ProposedProtocolParametersShelley {
  [k: string]: ProtocolParametersShelley;
}
export interface ProposedProtocolParametersAlonzo {
  [k: string]: ProtocolParametersAlonzo;
}
export interface ProposedProtocolParametersBabbage {
  [k: string]: ProtocolParametersBabbage;
}
/**
 * Query the current protocol parameters.
 */
export interface QueryLedgerStateProtocolParameters {
  jsonrpc: "2.0";
  method: "queryLedgerState/protocolParameters";
  params?: unknown;
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface QueryLedgerStateProtocolParametersResponse {
  jsonrpc: "2.0";
  method: "queryLedgerState/protocolParameters";
  result: ProtocolParametersShelley | ProtocolParametersAlonzo | ProtocolParametersBabbage;
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Query current delegation settings and rewards of some given reward accounts.
 */
export interface QueryLedgerStateRewardAccountSummaries {
  jsonrpc: "2.0";
  method: "queryLedgerState/rewardAccountSummaries";
  params: {
    scripts?: AnyStakeCredential[];
    keys?: AnyStakeCredential[];
  };
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface QueryLedgerStateRewardAccountSummariesResponse {
  jsonrpc: "2.0";
  method: "queryLedgerState/rewardAccountSummaries";
  result: RewardAccountSummaries;
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface RewardAccountSummaries {
  [k: string]: RewardAccountSummary;
}
export interface RewardAccountSummary {
  delegate?: StakePoolId;
  rewards?: Lovelace;
}
/**
 * Query details about rewards calculation for the ongoing epoch.
 */
export interface QueryLedgerStateRewardsProvenance {
  jsonrpc: "2.0";
  method: "queryLedgerState/rewardsProvenance";
  params?: unknown;
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface QueryLedgerStateRewardsProvenanceResponse {
  jsonrpc: "2.0";
  method: "queryLedgerState/rewardsProvenance";
  result: RewardsProvenance;
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Details about how rewards are calculated for the ongoing epoch.
 */
export interface RewardsProvenance {
  /**
   * Desired number of stake pools.
   */
  desiredNumberOfPools: number;
  /**
   * Influence of the pool owner's pledge on rewards, as a ratio of two integers.
   */
  poolInfluence: string;
  /**
   * Total rewards available for the given epoch.
   */
  totalRewards: {
    lovelace: bigint;
  };
  /**
   * The total amount of staked Lovelace during this epoch.
   */
  activeStake: {
    lovelace: bigint;
  };
  pools: {
    [k: string]: StakePoolSummary;
  };
}
export interface StakePoolSummary {
  stake: Lovelace;
  ownerStake: Lovelace;
  /**
   * Number of blocks produced divided by expected number of blocks (based on stake and epoch progress). Can be larger than 1.0 for pools that get lucky.
   */
  approximatePerformance: number;
  /**
   * Some of the pool parameters relevant for the reward calculation.
   */
  poolParameters: {
    cost: Lovelace;
    margin: Ratio;
    pledge: Lovelace;
  };
}
/**
 * Query the list of all stake pool identifiers currently registered and active.
 */
export interface QueryLedgerStateStakePools {
  jsonrpc: "2.0";
  method: "queryLedgerState/stakePools";
  params?: unknown;
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface QueryLedgerStateStakePoolsResponse {
  jsonrpc: "2.0";
  method: "queryLedgerState/stakePools";
  result: {
    id: StakePoolId;
  }[];
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Query registered parameters for given stake pools.
 */
export interface QueryLedgerStateStakePoolParameters {
  jsonrpc: "2.0";
  method: "queryLedgerState/stakePoolParameters";
  params: {
    stakePools: (StakePoolId | string)[];
  };
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface QueryLedgerStateStakePoolParametersResponse {
  jsonrpc: "2.0";
  method: "queryLedgerState/stakePoolParameters";
  result: {
    [k: string]: StakePoolParameters;
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Query the current tip the ledger is at. Said differently, the slot number and header hash of the last block that has been processed by the ledger.
 */
export interface QueryLedgerStateTip {
  jsonrpc: "2.0";
  method: "queryLedgerState/tip";
  params?: unknown;
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface QueryLedgerStateTipResponse {
  jsonrpc: "2.0";
  method: "queryLedgerState/tip";
  result: PointOrOrigin;
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Query the current Utxo set, restricted to some output references or addresses.
 */
export interface QueryLedgerStateUtxo {
  jsonrpc: "2.0";
  method: "queryLedgerState/utxo";
  params?: UtxoByOutputReferences | UtxoByAddresses | WholeUtxo;
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface UtxoByOutputReferences {
  outputReferences: TransactionOutputReference[];
}
export interface UtxoByAddresses {
  addresses: Address[];
}
export interface WholeUtxo {}
export interface QueryLedgerStateUtxoResponse {
  jsonrpc: "2.0";
  method: "queryLedgerState/utxo";
  result: Utxo;
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Query the networks highest block number.
 */
export interface QueryNetworkBlockHeight {
  jsonrpc: "2.0";
  method: "queryNetwork/blockHeight";
  params?: unknown;
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface QueryNetworkBlockHeightResponse {
  jsonrpc: "2.0";
  method: "queryNetwork/blockHeight";
  result: BlockHeight | Origin;
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Query the genesis configuration of a given era.
 */
export interface QueryNetworkGenesisConfiguration {
  jsonrpc: "2.0";
  method: "queryNetwork/genesisConfiguration";
  params: {
    era: EraWithGenesis;
  };
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface QueryNetworkGenesisConfigurationResponse {
  jsonrpc: "2.0";
  method: "queryNetwork/genesisConfiguration";
  result:
    | {
        byron: GenesisByron;
      }
    | {
        shelley: GenesisShelley;
      }
    | {
        alonzo: GenesisAlonzo;
      };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * A Byron genesis configuration, with information used to bootstrap the era. Some parameters are also updatable across the era.
 */
export interface GenesisByron {
  genesisKeyHashes: DigestBlake2B224[];
  genesisDelegations: {
    [k: string]: BootstrapOperationalCertificate;
  };
  systemStart: UtcTime;
  initialFunds: {
    [k: string]: Lovelace;
  };
  initialCoinOffering: {
    [k: string]: Lovelace;
  };
  securityParameter: UInt64;
  networkMagic: NetworkMagic;
  protocolParameters: ProtocolParametersByron;
}
/**
 * A Shelley genesis configuration, with information used to bootstrap the era. Some parameters are also updatable across the era.
 */
export interface GenesisShelley {
  systemStart: UtcTime;
  networkMagic: NetworkMagic;
  network: Network;
  activeSlotsCoefficient: Ratio;
  securityParameter: UInt64;
  epochLength: Epoch;
  slotsPerKesPeriod: UInt64;
  maxKesEvolutions: UInt64;
  slotLength: SlotLength;
  updateQuorum: UInt64;
  maxLovelaceSupply: UInt64;
  protocolParameters: ProtocolParametersShelley;
  initialDelegates: InitialDelegates;
  initialFunds: InitialFunds;
  initialPools: GenesisPools;
}
export interface InitialDelegates {
  [k: string]: GenesisDelegate;
}
/**
 * A Genesis delegate, in charge of Cardano's governance.
 */
export interface GenesisDelegate {
  delegate: DigestBlake2B224;
  vrf: DigestBlake2B256;
}
export interface InitialFunds {
  [k: string]: Lovelace;
}
/**
 * A Genesis stake pools configuration; primarily used for bootstrapping test networks.
 */
export interface GenesisPools {
  pools: {
    [k: string]: StakePoolParameters;
  };
  delegators: {
    [k: string]: StakePoolId;
  };
}
/**
 * An Alonzo genesis configuration, with information used to bootstrap the era. Some parameters are also updatable across the era.
 */
export interface GenesisAlonzo {
  coinsPerUtxoWord: UInt64;
  collateralPercentage: UInt64;
  costModels: CostModels;
  maxCollateralInputs: UInt64;
  maxExecutionUnitsPerBlock: ExecutionUnits;
  maxExecutionUnitsPerTransaction: ExecutionUnits;
  maxValueSize: UInt64;
  prices: Prices;
}
/**
 * Query the network start time.
 */
export interface QueryNetworkStartTime {
  jsonrpc: "2.0";
  method: "queryNetwork/startTime";
  params?: unknown;
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface QueryNetworkStartTimeResponse {
  jsonrpc: "2.0";
  method: "queryNetwork/startTime";
  result: UtcTime;
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Get the current network tip. Said differently, this is the most recent slot and block header hash that the node it aware of.
 */
export interface QueryNetworkTip {
  jsonrpc: "2.0";
  method: "queryNetwork/tip";
  params?: unknown;
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface QueryNetworkTipResponse {
  jsonrpc: "2.0";
  method: "queryNetwork/tip";
  result: PointOrOrigin;
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Acquire a mempool snapshot. This is blocking until a new (i.e different) snapshot is available.
 */
export interface AcquireMempool {
  jsonrpc: "2.0";
  method: "acquireMempool";
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Response to a 'acquireMempool' request.
 */
export interface AcquireMempoolResponse {
  jsonrpc: "2.0";
  method: "acquireMempool";
  result: {
    acquired: "mempool";
    slot: Slot;
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Request the next transaction from an acquired mempools napshot.
 */
export interface NextTransaction {
  jsonrpc: "2.0";
  method: "nextTransaction";
  params?: {
    fields?: "all";
  };
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Response to a 'nextTransaction' request.
 */
export interface NextTransactionResponse {
  jsonrpc: "2.0";
  method: "nextTransaction";
  /**
   * A transaction (or id) or an empty object if there's no more transactions.
   */
  result: {
    transaction:
      | {
          id: TransactionId;
        }
      | Transaction
      | null;
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Ask whether a given transaction is present in the acquired mempool snapshot.
 */
export interface HasTransaction {
  jsonrpc: "2.0";
  method: "hasTransaction";
  params: {
    id: TransactionId;
  };
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Response to a 'HasTransaction' request.
 */
export interface HasTransactionResponse {
  jsonrpc: "2.0";
  method: "hasTransaction";
  result: boolean;
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Get size and capacities of the mempool (acquired snapshot).
 */
export interface SizeOfMempool {
  jsonrpc: "2.0";
  method: "sizeOfMempool";
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Response to a 'sizeOfMempool' request.
 */
export interface SizeOfMempoolResponse {
  jsonrpc: "2.0";
  method: "sizeOfMempool";
  result: MempoolSizeAndCapacity;
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface MempoolSizeAndCapacity {
  maxCapacity: NumberOfBytes;
  currentSize: NumberOfBytes;
  transactions: {
    count: UInt321;
  };
}
/**
 * Release a previously acquired mempool snapshot.
 */
export interface ReleaseMempool {
  jsonrpc: "2.0";
  method: "releaseMempool";
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Response to a 'releaseMempool' request.
 */
export interface ReleaseMempoolResponse {
  jsonrpc: "2.0";
  method: "releaseMempool";
  result: {
    released: "mempool";
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * A generic error in the JSON-RPC protocol. This is returned by the server when a request from clients is deemed invalid or, when the server was unable to reply to a well-formed request.
 */
export interface RpcError {
  jsonrpc: "2.0";
  error: {
    /**
     * An error code telling about the nature of the error.
     */
    code: number;
    /**
     * A descriptive error message giving hints about the error.
     */
    message?: string;
    /**
     * Some optional data / context about the error. The exact type of this (optional) field depends on the error.
     */
    data?: {
      [k: string]: unknown;
    };
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
