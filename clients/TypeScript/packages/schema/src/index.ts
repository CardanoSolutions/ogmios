/* tslint:disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

/**
 * An absolute slot number.
 */
export type Slot = number;
/**
 * A Blake2b 32-byte hash digest, encoded in base16.
 */
export type DigestBlake2B256 = string;
/**
 * The origin of the blockchain. This point is special in the sense that it doesn't point to any existing slots, but is preceding any existing other point.
 */
export type Origin = "origin";
/**
 * A block number, the i-th block to be minted is number i.
 */
export type BlockHeight = number;
export type Block = BlockEBB | BlockBFT | BlockPraos;
/**
 * The size of the block in bytes.
 */
export type BlockSize = number;
/**
 * A Blake2b 32-byte hash digest of a transaction body
 */
export type TransactionId = string;
export type UInt32 = number;
/**
 * A number of lovelace, possibly large when summed up.
 */
export type Lovelace = bigint;
/**
 * A Cardano address (either legacy format or new format).
 */
export type Address = string;
/**
 * A number of asset, can be negative went burning assets.
 */
export type AssetQuantity = bigint;
export type Datum = string;
export type Script = Native | PlutusV1 | PlutusV2 | PlutusV3;
/**
 * A phase-1 monetary script. Timelocks constraints are only supported since Allegra.
 */
export type ScriptNative = DigestBlake2B224 | Any | All | NOf | ExpiresAt | StartsAt;
/**
 * A Blake2b 28-byte hash digest, encoded in base16.
 */
export type DigestBlake2B224 = string;
/**
 * A phase-2 Plutus script; or said differently, a serialized Plutus-core program.
 */
export type ScriptPlutus = string;
export type Certificate =
  | StakeDelegation
  | StakeKeyRegistration
  | StakeKeyDeregistration
  | PoolRegistration
  | PoolRetirement
  | GenesisDelegation
  | MoveInstantaneousRewards;
/**
 * A Blake2b 32-byte hash digest of a pool's verification key.
 */
export type StakePoolId = string;
/**
 * A ratio of two integers, to express exact fractions.
 */
export type Ratio = string;
/**
 * A hash digest from an unspecified algorithm and length.
 */
export type DigestAny = string;
export type Relay = ByAddress | ByName;
/**
 * A reward account, also known as 'stake address'.
 */
export type RewardAccount = string;
/**
 * An epoch number or length.
 */
export type Epoch = number;
/**
 * An amount, possibly negative, in Lovelace (1e6 Lovelace = 1 Ada).
 */
export type LovelaceDelta = number;
/**
 * Source of rewards as defined by the protocol parameters.
 */
export type RewardPot = "reserves" | "treasury";
/**
 * A network target, as defined since the Shelley era.
 */
export type Network = "mainnet" | "testnet";
export type UInt64 = number;
export type Nonce = Neutral | DigestBlake2B256;
export type Neutral = "neutral";
export type UInt321 = number;
export type Int64 = number;
export type CostModel = Int64[];
export type Metadatum = Int | String | Bytes | List | Map;
/**
 * Plutus data, CBOR-serialised.
 */
export type RedeemerData = string;
/**
 * An Ed25519 verification key.
 */
export type VerificationKey = string;
/**
 * An Ed25519-BIP32 Byron genesis delegate verification key with chain-code.
 */
export type ExtendedVerificationKey = string;
export type ProtocolMagicId = number;
export type GenesisHash = "genesis";
export type VrfProof = string;
export type VrfOutput = string;
export type KesVerificationKey = string;
export type Era = "byron" | "shelley" | "allegra" | "mary" | "alonzo" | "babbage";
export type UInt8 = number;
export type VotingPeriod = "voteForThisEpoch" | "voteForNextEpoch";
export type ScriptPurpose = Spend | Mint | Certificate1 | Withdrawal;
/**
 * A Blake2b 28-byte hash digest, encoded in base16.
 */
export type PolicyId = string;
export type Utxo = [TransactionOutputReference, TransactionOutput][];
export type Language = "plutus:v1" | "plutus:v2" | "plutus:v3";
export type ScriptExecutionFailureReason =
  | ExtraRedeemers
  | MissingRequiredDatums
  | MissingRequiredScripts
  | ValidatorFailed
  | UnknownInputReferencedByRedeemer
  | NonScriptInputReferencedByRedeemer
  | IllFormedExecutionBudget
  | NoCostModelForLanguage;
export type RedeemerPointer = string;
/**
 * A time in seconds relative to another one (typically, system start or era start).
 */
export type RelativeTime = number;
/**
 * A slot length, in seconds, possibly with decimals.
 */
export type SlotLength = number;
/**
 * Number of slots from the tip of the ledger in which it is guaranteed that no hard fork can take place. This should be (at least) the number of slots in which we are guaranteed to have k blocks.
 */
export type SafeZone = number;
export type StakeCredential = DigestBlake2B2241 | Bech32 | StakeAddress;
/**
 * A Blake2b 28-byte hash digest, encoded in base16.
 */
export type DigestBlake2B2241 = string;
/**
 * A Blake2b 28-byte hash digest of a verification key or script.
 */
export type Bech32 = string;
/**
 * A stake address (a.k.a reward account)
 */
export type StakeAddress = string;
/**
 * A number of lovelace, possibly large when summed up.
 */
export type Lovelace1 = bigint;
export type EraWithGenesis = "byron" | "shelley" | "alonzo";
export type UtcTime = string;
/**
 * A magic number for telling networks apart. (e.g. 764824073)
 */
export type NetworkMagic = number;

export interface Ogmios {
  FindIntersection: FindIntersection;
  FindIntersectionResponse: IntersectionFound | IntersectionNotFound;
  NextBlock: NextBlock;
  NextBlockResponse: NextBlockResponse;
  SubmitTransaction: SubmitTransaction;
  SubmitTransactionResponse: SubmitTransactionSuccess | SubmitTransactionFailure;
  EvaluateTransaction: EvaluateTransaction;
  EvaluateTransactionResponse: EvaluateTransactionSuccess | EvaluateTransactionFailure;
  AcquireLedgerState: AcquireLedgerState;
  AcquireLedgerStateResponse: AcquireLedgerStateSuccess | AcquireLedgerStateFailure;
  ReleaseLedgerState: ReleaseLedgerState;
  ReleaseLedgerStateResponse: ReleaseLedgerStateResponse;
  QueryLedgerStateEraMismatch?: QueryLedgerStateEraMismatch;
  QueryLedgerStateUnavailableInCurrentEra?: QueryLedgerStateUnavailableInCurrentEra;
  QueryLedgerStateAcquiredExpire?: QueryLedgerStateAcquiredExpired;
  QueryLedgerStateEpoch: QueryLedgerStateEpoch;
  QueryLedgerStateEpochResponse:
    | QueryLedgerStateEpochResponse
    | QueryLedgerStateEraMismatch
    | QueryLedgerStateUnavailableInCurrentEra
    | QueryLedgerStateAcquiredExpired;
  QueryLedgerStateEraStart: QueryLedgerStateEraStart;
  QueryLedgerStateEraStartResponse:
    | QueryLedgerStateEraStartResponse
    | QueryLedgerStateEraMismatch
    | QueryLedgerStateUnavailableInCurrentEra
    | QueryLedgerStateAcquiredExpired;
  QueryLedgerStateEraSummaries: QueryLedgerStateEraSummaries;
  QueryLedgerStateEraSummariesResponse:
    | QueryLedgerStateEraSummariesResponse
    | QueryLedgerStateEraMismatch
    | QueryLedgerStateUnavailableInCurrentEra
    | QueryLedgerStateAcquiredExpired;
  QueryLedgerStateLiveStakeDistribution: QueryLedgerStateLiveStakeDistribution;
  QueryLedgerStateLiveStakeDistributionResponse:
    | QueryLedgerStateLiveStakeDistributionResponse
    | QueryLedgerStateEraMismatch
    | QueryLedgerStateUnavailableInCurrentEra
    | QueryLedgerStateAcquiredExpired;
  QueryLedgerStateProjectedRewards: QueryLedgerStateProjectedRewards;
  QueryLedgerStateProjectedRewardsResponse:
    | QueryLedgerStateProjectedRewardsResponse
    | QueryLedgerStateEraMismatch
    | QueryLedgerStateUnavailableInCurrentEra
    | QueryLedgerStateAcquiredExpired;
  QueryLedgerStateProposedProtocolParameters: QueryLedgerStateProposedProtocolParameters;
  QueryLedgerStateProposedProtocolParametersResponse:
    | QueryLedgerStateProposedProtocolParametersResponse
    | QueryLedgerStateEraMismatch
    | QueryLedgerStateUnavailableInCurrentEra
    | QueryLedgerStateAcquiredExpired;
  QueryLedgerStateProtocolParameters: QueryLedgerStateProtocolParameters;
  QueryLedgerStateProtocolParametersResponse:
    | QueryLedgerStateProtocolParametersResponse
    | QueryLedgerStateEraMismatch
    | QueryLedgerStateUnavailableInCurrentEra
    | QueryLedgerStateAcquiredExpired;
  QueryLedgerStateRewardAccountSummaries: QueryLedgerStateRewardAccountSummaries;
  QueryLedgerStateRewardAccountSummariesResponse:
    | QueryLedgerStateRewardAccountSummariesResponse
    | QueryLedgerStateEraMismatch
    | QueryLedgerStateUnavailableInCurrentEra
    | QueryLedgerStateAcquiredExpired;
  QueryLedgerStateRewardsProvenance: QueryLedgerStateRewardsProvenance;
  QueryLedgerStateRewardsProvenanceResponse:
    | QueryLedgerStateRewardsProvenanceResponse
    | QueryLedgerStateEraMismatch
    | QueryLedgerStateUnavailableInCurrentEra
    | QueryLedgerStateAcquiredExpired;
  QueryLedgerStateStakePools: QueryLedgerStateStakePools;
  QueryLedgerStateStakePoolsResponse:
    | QueryLedgerStateStakePoolsResponse
    | QueryLedgerStateEraMismatch
    | QueryLedgerStateUnavailableInCurrentEra
    | QueryLedgerStateAcquiredExpired;
  QueryLedgerStateStakePoolParameters: QueryLedgerStateStakePoolParameters;
  QueryLedgerStateStakePoolParametersResponse:
    | QueryLedgerStateStakePoolParametersResponse
    | QueryLedgerStateEraMismatch
    | QueryLedgerStateUnavailableInCurrentEra
    | QueryLedgerStateAcquiredExpired;
  QueryLedgerStateTip: QueryLedgerStateTip;
  QueryLedgerStateTipResponse:
    | QueryLedgerStateTipResponse
    | QueryLedgerStateEraMismatch
    | QueryLedgerStateUnavailableInCurrentEra
    | QueryLedgerStateAcquiredExpired;
  QueryLedgerStateUtxo: QueryLedgerStateUtxo;
  QueryLedgerStateUtxoResponse:
    | QueryLedgerStateUtxoResponse
    | QueryLedgerStateEraMismatch
    | QueryLedgerStateUnavailableInCurrentEra
    | QueryLedgerStateAcquiredExpired;
  QueryNetworkBlockHeight: QueryNetworkBlockHeight;
  QueryNetworkBlockHeightResponse: QueryNetworkBlockHeightResponse;
  QueryNetworkGenesisConfiguration: QueryNetworkGenesisConfiguration;
  QueryNetworkGenesisConfigurationResponse: QueryNetworkGenesisConfigurationResponse;
  QueryNetworkStartTime: QueryNetworkStartTime;
  QueryNetworkStartTimeResponse: QueryNetworkStartTimeResponse;
  QueryNetworkTip: QueryNetworkTip;
  QueryNetworkTipResponse: QueryNetworkTipResponse;
  AcquireMempool: AcquireMempool;
  AcquireMempoolResponse: AcquireMempoolResponse;
  NextTransaction: NextTransaction;
  NextTransactionResponse: NextTransactionResponse;
  HasTransaction: HasTransaction;
  HasTransactionResponse: HasTransactionResponse;
  SizeOfMempool: SizeOfMempool;
  SizeOfMempoolResponse?: SizeOfMempoolResponse;
  ReleaseMempool: ReleaseMempool;
  ReleaseMempoolResponse: ReleaseMempoolResponse;
  RpcError: RpcError;
}
/**
 * Ask cardano-node to find an intersection between its local chain and the given points.
 */
export interface FindIntersection {
  jsonrpc: "2.0";
  method: "findIntersection";
  params: {
    points?: (Point | Origin)[];
  };
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * A point on the chain, identified by a slot and a block header hash.
 */
export interface Point {
  slot: Slot;
  hash: DigestBlake2B256;
}
export interface IntersectionFound {
  jsonrpc: "2.0";
  result: {
    intersection: Point | Origin;
    tip: Tip | Origin;
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface Tip {
  slot: Slot;
  hash: DigestBlake2B256;
  blockNo: BlockHeight;
}
export interface IntersectionNotFound {
  jsonrpc: "2.0";
  error: {
    code: 1000;
    message: string;
    data: {
      tip: Tip | Origin;
    };
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Request next block from the current cardano-node's cursor.
 */
export interface NextBlock {
  jsonrpc: "2.0";
  method: "nextBlock";
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Response to a 'nextBlock' request.
 */
export interface NextBlockResponse {
  jsonrpc: "2.0";
  result: RollForward | RollBackward;
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface RollForward {
  direction: "forward";
  tip: Tip;
  block: Block;
}
export interface BlockEBB {
  era: "byron";
  header: {
    hash: DigestBlake2B256;
  };
  ancestor: DigestBlake2B256;
  height: BlockHeight;
}
export interface BlockBFT {
  era: "byron";
  header: {
    hash: DigestBlake2B256;
  };
  ancestor: DigestBlake2B256;
  height: BlockHeight;
  slot: Slot;
  size: BlockSize;
  transactions?: Transaction[];
  operationalCertificates?: BootstrapOperationalCertificate[];
  governanceAction?: BootstrapGovernanceAction;
  protocol: {
    magic: ProtocolMagicId;
    version: ProtocolVersion;
    software: SoftwareVersion;
  };
  issuer: {
    verificationKey: ExtendedVerificationKey;
  };
  delegate: {
    verificationKey: ExtendedVerificationKey;
  };
}
export interface Transaction {
  id: DigestBlake2B256;
  inputSource: "inputs" | "collaterals";
  inputs: TransactionOutputReference[];
  references?: TransactionOutputReference[];
  collaterals?: TransactionOutputReference[];
  collateral?: Lovelace;
  collateralReturn?: TransactionOutput;
  outputs: TransactionOutput[];
  certificates?: Certificate[];
  withdrawals?: Withdrawals;
  fee?: Lovelace;
  validityInterval?: ValidityInterval;
  mint?: MintValue;
  network?: Network;
  scriptIntegrityHash?: DigestBlake2B256;
  requiredExtraSignatories?: DigestBlake2B224[];
  governanceActions?: UpdateProposalShelley[] | UpdateProposalAlonzo[] | UpdateProposalBabbage[];
  metadata?: Metadata;
  signatories: unknown[];
  scripts?: {
    [k: string]: Script;
  };
  datums?: {
    [k: string]: Datum;
  };
  redeemers?: {
    [k: string]: Redeemer;
  };
  /**
   * The raw serialized (CBOR) transaction, as found on-chain.
   */
  cbor: string;
}
export interface TransactionOutputReference {
  txId: TransactionId;
  index: UInt32;
}
/**
 * A transaction output. Since Mary, 'value' always return a multi-asset value. Since Alonzo, 'datumHash' is always present (albeit sometimes 'null'). Since Babbage, 'datum' & 'script' are always present (albeit sometimes 'null').
 */
export interface TransactionOutput {
  address: Address;
  value: Value;
  datumHash?: DigestBlake2B256;
  datum?: Datum;
  script?: Script;
}
export interface Value {
  coins: Lovelace;
  assets?: {
    [k: string]: AssetQuantity;
  };
}
export interface Native {
  native: ScriptNative;
}
export interface Any {
  any: ScriptNative[];
}
export interface All {
  all: ScriptNative[];
}
export interface NOf {
  [k: string]: ScriptNative[];
}
export interface ExpiresAt {
  expiresAt: Slot;
}
export interface StartsAt {
  startsAt: Slot;
}
export interface PlutusV1 {
  "plutus:v1": ScriptPlutus;
}
export interface PlutusV2 {
  "plutus:v2": ScriptPlutus;
}
export interface PlutusV3 {
  "plutus:v3": ScriptPlutus;
}
/**
 * A stake delegation certificate, from a delegator to a stake pool.
 */
export interface StakeDelegation {
  stakeDelegation: {
    delegator: DigestBlake2B224;
    delegatee: StakePoolId;
  };
}
/**
 * A stake key registration certificate.
 */
export interface StakeKeyRegistration {
  stakeKeyRegistration: DigestBlake2B224;
}
/**
 * A stake key de-registration certificate.
 */
export interface StakeKeyDeregistration {
  stakeKeyDeregistration: DigestBlake2B224;
}
/**
 * A pool registration certificate.
 */
export interface PoolRegistration {
  poolRegistration: StakePoolParameters;
}
export interface StakePoolParameters {
  id: StakePoolId;
  owners: DigestBlake2B224[];
  cost: Lovelace;
  margin: Ratio;
  pledge: Lovelace;
  vrf: DigestBlake2B256;
  metadata?: PoolMetadata;
  relays: Relay[];
  rewardAccount: RewardAccount;
}
export interface PoolMetadata {
  hash: DigestAny;
  url: string;
}
export interface ByAddress {
  ipv4?: string;
  ipv6?: string;
  port?: number;
}
export interface ByName {
  hostname: string;
  port?: number;
}
/**
 * A pool retirement certificate.
 */
export interface PoolRetirement {
  poolRetirement: {
    retirementEpoch: Epoch;
    poolId: StakePoolId;
  };
}
export interface GenesisDelegation {
  genesisDelegation: {
    delegateKeyHash: DigestBlake2B224;
    verificationKeyHash: DigestBlake2B224;
    vrfVerificationKeyHash: DigestBlake2B256;
  };
}
/**
 * Either `value` or `rewards` will be present, but never both.
 */
export interface MoveInstantaneousRewards {
  moveInstantaneousRewards: {
    rewards?: RewardTransfer;
    value?: Lovelace;
    pot: RewardPot;
  };
}
export interface RewardTransfer {
  [k: string]: LovelaceDelta;
}
export interface Withdrawals {
  [k: string]: Lovelace;
}
export interface ValidityInterval {
  invalidBefore?: Slot;
  invalidAfter?: Slot;
}
export interface MintValue {
  [k: string]: AssetQuantity;
}
export interface UpdateProposalShelley {
  epoch: Epoch;
  proposal: {
    [k: string]: ProtocolParametersShelley;
  };
}
export interface ProtocolParametersShelley {
  minFeeCoefficient?: UInt64;
  minFeeConstant?: UInt64;
  maxBlockBodySize?: UInt64;
  maxBlockHeaderSize?: UInt64;
  maxTxSize?: UInt64;
  stakeKeyDeposit?: UInt64;
  poolDeposit?: UInt64;
  poolRetirementEpochBound?: UInt64;
  desiredNumberOfPools?: UInt64;
  poolInfluence?: Ratio;
  monetaryExpansion?: Ratio;
  treasuryExpansion?: Ratio;
  decentralizationParameter?: Ratio;
  minUtxoValue?: UInt64;
  minPoolCost?: UInt64;
  extraEntropy?: Nonce;
  protocolVersion?: ProtocolVersion;
}
export interface ProtocolVersion {
  major: UInt321;
  minor: UInt321;
  patch?: UInt321;
}
export interface UpdateProposalAlonzo {
  epoch: Epoch;
  proposal: {
    [k: string]: ProtocolParametersAlonzo;
  };
}
export interface ProtocolParametersAlonzo {
  minFeeCoefficient?: UInt64;
  minFeeConstant?: UInt64;
  maxBlockBodySize?: UInt64;
  maxBlockHeaderSize?: UInt64;
  maxTxSize?: UInt64;
  stakeKeyDeposit?: UInt64;
  poolDeposit?: UInt64;
  poolRetirementEpochBound?: UInt64;
  desiredNumberOfPools?: UInt64;
  poolInfluence?: Ratio;
  monetaryExpansion?: Ratio;
  treasuryExpansion?: Ratio;
  decentralizationParameter?: Ratio;
  minPoolCost?: UInt64;
  coinsPerUtxoWord?: UInt64;
  maxValueSize?: UInt64;
  collateralPercentage?: UInt64;
  maxCollateralInputs?: UInt64;
  extraEntropy?: Nonce;
  protocolVersion?: ProtocolVersion;
  costModels?: CostModels;
  prices?: Prices;
  maxExecutionUnitsPerTransaction?: ExecutionUnits;
  maxExecutionUnitsPerBlock?: ExecutionUnits;
}
export interface CostModels {
  [k: string]: CostModel;
}
export interface Prices {
  memory: Ratio;
  steps: Ratio;
}
export interface ExecutionUnits {
  memory: UInt64;
  steps: UInt64;
}
export interface UpdateProposalBabbage {
  epoch: Epoch;
  proposal: {
    [k: string]: ProtocolParametersBabbage;
  };
}
export interface ProtocolParametersBabbage {
  minFeeCoefficient?: UInt64;
  minFeeConstant?: UInt64;
  maxBlockBodySize?: UInt64;
  maxBlockHeaderSize?: UInt64;
  maxTxSize?: UInt64;
  stakeKeyDeposit?: UInt64;
  poolDeposit?: UInt64;
  poolRetirementEpochBound?: UInt64;
  desiredNumberOfPools?: UInt64;
  poolInfluence?: Ratio;
  monetaryExpansion?: Ratio;
  treasuryExpansion?: Ratio;
  minPoolCost?: UInt64;
  coinsPerUtxoByte?: UInt64;
  maxValueSize?: UInt64;
  collateralPercentage?: UInt64;
  maxCollateralInputs?: UInt64;
  protocolVersion?: ProtocolVersion;
  costModels?: CostModels;
  prices?: Prices;
  maxExecutionUnitsPerTransaction?: ExecutionUnits;
  maxExecutionUnitsPerBlock?: ExecutionUnits;
}
export interface Metadata {
  hash: DigestBlake2B256;
  labels: MetadataLabels;
}
export interface MetadataLabels {
  [k: string]: Metadatum;
}
export interface Int {
  int: bigint;
}
export interface String {
  string: string;
}
export interface Bytes {
  bytes: string;
}
export interface List {
  list: Metadatum[];
}
export interface Map {
  map: MetadatumMap[];
}
export interface MetadatumMap {
  k: Metadatum;
  v: Metadatum;
}
export interface Redeemer {
  redeemer: RedeemerData;
  executionUnits: ExecutionUnits;
}
/**
 * A (Byron) delegation certificate.
 */
export interface BootstrapOperationalCertificate {
  issuer: {
    verificationKey: VerificationKey;
  };
  delegate: {
    verificationKey: VerificationKey;
  };
}
export interface BootstrapGovernanceAction {
  proposal?: {
    protocol: {
      version: ProtocolVersion;
      software: SoftwareVersion;
    };
    metadata: {
      [k: string]: string;
    };
    parameters: ProtocolParametersByron;
    issuer: {
      verificationKey: ExtendedVerificationKey;
    };
  };
  votes: BootstrapVote[];
}
export interface SoftwareVersion {
  appName: string;
  number: UInt321;
}
export interface ProtocolParametersByron {
  heavyDlgThreshold?: Ratio;
  maxBlockSize?: UInt64;
  maxHeaderSize?: UInt64;
  maxProposalSize?: UInt64;
  maxTxSize?: UInt64;
  mpcThreshold?: Ratio;
  scriptVersion?: UInt64;
  slotDuration?: UInt64;
  unlockStakeEpoch?: UInt64;
  updateProposalThreshold?: Ratio;
  updateProposalTimeToLive?: UInt64;
  updateVoteThreshold?: Ratio;
  txFeePolicy?: TxFeePolicy;
  softforkRule?: SoftForkRule;
}
export interface TxFeePolicy {
  coefficient: Ratio;
  constant: number;
}
export interface SoftForkRule {
  initThreshold: Ratio;
  minThreshold: Ratio;
  decrementThreshold: Ratio;
}
export interface BootstrapVote {
  voter: {
    verificationKey: VerificationKey;
  };
  proposal: {
    hash: DigestBlake2B256;
  };
}
export interface BlockPraos {
  era: "shelley" | "allegra" | "mary" | "alonzo" | "babbage";
  header: {
    hash: DigestBlake2B256;
  };
  ancestor: DigestBlake2B256 | GenesisHash;
  nonce?: CertifiedVrf;
  height: BlockHeight;
  size: BlockSize;
  slot: Slot;
  transactions?: Transaction[];
  protocol: {
    version: ProtocolVersion;
  };
  issuer: {
    verificationKey: VerificationKey;
    vrfVerificationKey: VerificationKey;
    operationalCertificate: OperationalCertificate;
    leaderValue: CertifiedVrf;
  };
}
export interface CertifiedVrf {
  proof?: VrfProof;
  output?: VrfOutput;
}
/**
 * Certificate identifying a stake pool operator.
 */
export interface OperationalCertificate {
  count: UInt64;
  kes: {
    period: UInt64;
    verificationKey: KesVerificationKey;
  };
}
export interface RollBackward {
  direction: "backward";
  tip: Tip | Origin;
  point: Point | Origin;
}
/**
 * Submit a signed and serialized transaction to the network.
 */
export interface SubmitTransaction {
  jsonrpc: "2.0";
  method: "submitTransaction";
  params: {
    /**
     * CBOR-serialized signed transaction (base16)
     */
    transaction: string;
  };
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface SubmitTransactionSuccess {
  jsonrpc: "2.0";
  result: {
    transaction: {
      id: TransactionId;
    };
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface SubmitTransactionFailure {
  jsonrpc: "2.0";
  error: {
    code: 3005;
    message: string;
    data: (
      | EraMismatch
      | InvalidWitnesses
      | MissingVkWitnesses
      | MissingScriptWitnesses
      | ScriptWitnessNotValidating
      | InsufficientGenesisSignatures
      | MissingTxMetadata
      | MissingTxMetadataHash
      | TxMetadataHashMismatch
      | BadInputs
      | ExpiredUtxo
      | OutsideOfValidityInterval
      | TxTooLarge
      | MissingAtLeastOneInputUtxo
      | InvalidMetadata
      | FeeTooSmall
      | ValueNotConserved
      | NetworkMismatch
      | OutputTooSmall
      | TooManyAssetsInOutput
      | AddressAttributesTooLarge
      | TriesToForgeAda
      | DelegateNotRegistered
      | UnknownOrIncompleteWithdrawals
      | StakePoolNotRegistered
      | WrongRetirementEpoch
      | WrongPoolCertificate
      | StakeKeyAlreadyRegistered
      | PoolCostTooSmall
      | PoolMetadataHashTooBig
      | StakeKeyNotRegistered
      | RewardAccountNotExisting
      | RewardAccountNotEmpty
      | WrongCertificateType
      | UnknownGenesisKey
      | AlreadyDelegating
      | InsufficientFundsForMir
      | TooLateForMir
      | MirTransferNotCurrentlyAllowed
      | MirNegativeTransferNotCurrentlyAllowed
      | MirProducesNegativeUpdate
      | DuplicateGenesisVrf
      | NonGenesisVoters
      | UpdateWrongEpoch
      | ProtocolVersionCannotFollow
      | MissingRequiredRedeemers
      | MissingRequiredDatums
      | UnspendableDatums
      | ExtraDataMismatch
      | MissingRequiredSignatures
      | UnspendableScriptInputs
      | ExtraRedeemers
      | MissingDatumHashesForInputs
      | MissingCollateralInputs
      | CollateralTooSmall
      | CollateralIsScript
      | CollateralHasNonAdaAssets
      | TooManyCollateralInputs
      | ExecutionUnitsTooLarge
      | OutsideForecast
      | ValidationTagMismatch
      | CollectErrors
      | ExtraScriptWitnesses
      | MirNegativeTransfer
      | TotalCollateralMismatch
      | MalformedReferenceScripts
      | MalformedScriptWitnesses
    )[];
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface EraMismatch {
  queryEra: Era;
  ledgerEra: Era;
}
export interface InvalidWitnesses {
  invalidWitnesses: VerificationKey[];
}
export interface MissingVkWitnesses {
  missingVkWitnesses: DigestBlake2B224[];
}
export interface MissingScriptWitnesses {
  missingScriptWitnesses: DigestBlake2B224[];
}
export interface ScriptWitnessNotValidating {
  scriptWitnessNotValidating: DigestBlake2B224[];
}
export interface InsufficientGenesisSignatures {
  insufficientGenesisSignatures: DigestBlake2B224[];
}
export interface MissingTxMetadata {
  missingTxMetadata: DigestBlake2B256;
}
export interface MissingTxMetadataHash {
  missingTxMetadataHash: DigestBlake2B256;
}
export interface TxMetadataHashMismatch {
  txMetadataHashMismatch: {
    includedHash: DigestBlake2B256;
    expectedHash: DigestBlake2B256;
  };
}
export interface BadInputs {
  badInputs: TransactionOutputReference[];
}
/**
 * Only in Shelley. Replaced with 'outsideOfValidityInterval' since Allegra.
 */
export interface ExpiredUtxo {
  expiredUtxo: {
    currentSlot: Slot;
    transactionTimeToLive: Slot;
  };
}
/**
 * Since Allegra. Replaces 'expiredUtxo'.
 */
export interface OutsideOfValidityInterval {
  outsideOfValidityInterval: {
    currentSlot: Slot;
    interval: ValidityInterval;
  };
}
export interface TxTooLarge {
  txTooLarge: {
    maximumSize: Int64;
    actualSize: Int64;
  };
}
export interface MissingAtLeastOneInputUtxo {
  missingAtLeastOneInputUtxo: null;
}
export interface InvalidMetadata {
  invalidMetadata: null;
}
export interface FeeTooSmall {
  feeTooSmall: {
    requiredFee: Lovelace;
    actualFee: Lovelace;
  };
}
/**
 * Returns 'Value' since Mary, and 'LovelaceDelta' before.
 */
export interface ValueNotConserved {
  valueNotConserved: {
    consumed: LovelaceDelta | Value;
    produced: LovelaceDelta | Value;
  };
}
export interface NetworkMismatch {
  networkMismatch: {
    expectedNetwork: Network;
    invalidEntities: (
      | {
          type: "address";
          entity: Address;
        }
      | {
          type: "poolRegistration";
          entity: StakePoolId;
        }
      | {
          type: "rewardAccount";
          entity: RewardAccount;
        }
    )[];
  };
}
export interface OutputTooSmall {
  outputTooSmall: (
    | TransactionOutput
    | {
        output: TransactionOutput;
        minimumRequiredValue: Lovelace;
      }
  )[];
}
/**
 * Only since Mary.
 */
export interface TooManyAssetsInOutput {
  tooManyAssetsInOutput: TransactionOutput[];
}
export interface AddressAttributesTooLarge {
  addressAttributesTooLarge: Address[];
}
/**
 * Only since Mary.
 */
export interface TriesToForgeAda {
  triesToForgeAda: null;
}
export interface DelegateNotRegistered {
  delegateNotRegistered: StakePoolId;
}
export interface UnknownOrIncompleteWithdrawals {
  unknownOrIncompleteWithdrawals: Withdrawals;
}
export interface StakePoolNotRegistered {
  stakePoolNotRegistered: StakePoolId;
}
export interface WrongRetirementEpoch {
  wrongRetirementEpoch: {
    currentEpoch: Epoch;
    requestedEpoch: Epoch;
    firstUnreachableEpoch: Epoch;
  };
}
export interface WrongPoolCertificate {
  wrongPoolCertificate: UInt8;
}
export interface StakeKeyAlreadyRegistered {
  stakeKeyAlreadyRegistered: DigestBlake2B224;
}
export interface PoolCostTooSmall {
  poolCostTooSmall: {
    minimumCost: Lovelace;
  };
}
export interface PoolMetadataHashTooBig {
  poolMetadataHashTooBig: {
    poolId: StakePoolId;
    measuredSize: Int64;
  };
}
export interface StakeKeyNotRegistered {
  stakeKeyNotRegistered: DigestBlake2B224;
}
export interface RewardAccountNotExisting {
  rewardAccountNotExisting: null;
}
export interface RewardAccountNotEmpty {
  rewardAccountNotEmpty: {
    balance: Lovelace;
  };
}
export interface WrongCertificateType {
  wrongCertificateType: null;
}
export interface UnknownGenesisKey {
  unknownGenesisKey: DigestBlake2B224;
}
export interface AlreadyDelegating {
  alreadyDelegating: DigestBlake2B224;
}
export interface InsufficientFundsForMir {
  insufficientFundsForMir: {
    rewardSource: RewardPot;
    sourceSize: Lovelace;
    requestedAmount: Lovelace;
  };
}
export interface TooLateForMir {
  tooLateForMir: {
    currentSlot: Slot;
    lastAllowedSlot: Slot;
  };
}
export interface MirTransferNotCurrentlyAllowed {
  mirTransferNotCurrentlyAllowed: null;
}
export interface MirNegativeTransferNotCurrentlyAllowed {
  mirNegativeTransferNotCurrentlyAllowed: null;
}
export interface MirProducesNegativeUpdate {
  mirProducesNegativeUpdate: null;
}
export interface DuplicateGenesisVrf {
  duplicateGenesisVrf: DigestBlake2B256;
}
export interface NonGenesisVoters {
  nonGenesisVoters: {
    currentlyVoting: DigestBlake2B224[];
    shouldBeVoting: DigestBlake2B224[];
  };
}
export interface UpdateWrongEpoch {
  updateWrongEpoch: {
    currentEpoch: Epoch;
    requestedEpoch: Epoch;
    votingPeriod: VotingPeriod;
  };
}
export interface ProtocolVersionCannotFollow {
  protocolVersionCannotFollow: ProtocolVersion;
}
export interface MissingRequiredRedeemers {
  missingRequiredRedeemers: {
    missing: {
      [k: string]: ScriptPurpose;
    }[];
  };
}
export interface Spend {
  spend: TransactionOutputReference;
}
export interface Mint {
  mint: PolicyId;
}
export interface Certificate1 {
  certificate: Certificate;
}
export interface Withdrawal {
  withdrawal: RewardAccount;
}
export interface MissingRequiredDatums {
  missingRequiredDatums: {
    provided?: DigestBlake2B256[];
    missing: DigestBlake2B256[];
  };
}
export interface UnspendableDatums {
  unspendableDatums: {
    nonSpendable: DigestBlake2B256[];
    acceptable: DigestBlake2B256[];
  };
}
export interface ExtraDataMismatch {
  extraDataMismatch: {
    provided?: DigestBlake2B256;
    inferredFromParameters?: DigestBlake2B256;
  };
}
export interface MissingRequiredSignatures {
  missingRequiredSignatures: DigestBlake2B224[];
}
export interface UnspendableScriptInputs {
  unspendableScriptInputs: TransactionOutputReference[];
}
export interface ExtraRedeemers {
  extraRedeemers: string[];
}
export interface MissingDatumHashesForInputs {
  missingDatumHashesForInputs: TransactionOutputReference[];
}
/**
 * Only since Alonzo.
 */
export interface MissingCollateralInputs {
  missingCollateralInputs: null;
}
export interface CollateralTooSmall {
  collateralTooSmall: {
    requiredCollateral: Lovelace;
    actualCollateral: Lovelace;
  };
}
export interface CollateralIsScript {
  collateralIsScript: Utxo;
}
export interface CollateralHasNonAdaAssets {
  collateralHasNonAdaAssets: Value;
}
export interface TooManyCollateralInputs {
  tooManyCollateralInputs: {
    maximumCollateralInputs: UInt64;
    actualCollateralInputs: UInt64;
  };
}
export interface ExecutionUnitsTooLarge {
  executionUnitsTooLarge: {
    maximumExecutionUnits: ExecutionUnits;
    actualExecutionUnits: ExecutionUnits;
  };
}
export interface OutsideForecast {
  outsideForecast: Slot;
}
/**
 * Only since Alonzo.
 */
export interface ValidationTagMismatch {
  validationTagMismatch: null;
}
export interface CollectErrors {
  collectErrors: (NoRedeemer | NoWitness | NoCostModel | BadTranslation)[];
}
export interface NoRedeemer {
  noRedeemer: ScriptPurpose;
}
export interface NoWitness {
  noWitness: DigestBlake2B224;
}
export interface NoCostModel {
  noCostModel: Language;
}
export interface BadTranslation {
  /**
   * An (hopefully) informative error about the transaction execution failure.
   */
  badTranslation: string;
}
export interface ExtraScriptWitnesses {
  extraScriptWitnesses: DigestBlake2B224[];
}
export interface MirNegativeTransfer {
  mirNegativeTransfer: {
    rewardSource: RewardPot;
    attemptedTransfer: Lovelace;
  };
}
export interface TotalCollateralMismatch {
  totalCollateralMismatch: {
    computedFromDelta: Lovelace;
    declaredInField: Lovelace;
  };
}
export interface MalformedReferenceScripts {
  malformedReferenceScripts: DigestBlake2B224[];
}
export interface MalformedScriptWitnesses {
  malformedScriptWitnesses: DigestBlake2B224[];
}
/**
 * Evaluate execution units for which redeemers's budget hasn't yet been set.
 */
export interface EvaluateTransaction {
  jsonrpc: "2.0";
  method: "evaluateTransaction";
  params: {
    /**
     * CBOR-serialized signed transaction (base16)
     */
    transaction: string;
    additionalUtxoSet?: Utxo;
  };
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface EvaluateTransactionSuccess {
  jsonrpc: "2.0";
  result: {
    budgets: {
      [k: string]: ExecutionUnits;
    };
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Happens when attempting to evaluate execution units on a node that isn't enough synchronized.
 */
export interface EvaluateTransactionFailure {
  jsonrpc: "2.0";
  error:
    | EvaluateTransactionFailureIncompatibleEra
    | EvaluateTransactionFailureUnsupportedEra
    | EvaluateTransactionFailureOverlappingAdditionalUtxo
    | EvaluateTransactionFailureNodeTipTooOld
    | EvaluateTransactionFailureCannotCreateEvaluationContext
    | EvaluateTransactionFailureScriptExecutionFailure;
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Returned when trying to evaluate execution units of a pre-Alonzo transaction. Note that this isn't possible with Ogmios because transactions are always de-serialized as Alonzo transactions.
 */
export interface EvaluateTransactionFailureIncompatibleEra {
  code: 3000;
  message: string;
  data: IncompatibleEra;
}
/**
 * The era in which the transaction has been identified.
 */
export interface IncompatibleEra {
  incompatibleEra: Era;
}
/**
 * Returned when trying to evaluate execution units of an era that is now considered too old and is no longer supported. This can solved by using a more recent transaction format.
 */
export interface EvaluateTransactionFailureUnsupportedEra {
  code: 3001;
  message: string;
  data: UnsupportedEra;
}
/**
 * The era in which the transaction has been identified.
 */
export interface UnsupportedEra {
  unsupportedEra: Era;
}
/**
 * Happens when providing an additional UTXO set which overlaps with the UTXO on-chain.
 */
export interface EvaluateTransactionFailureOverlappingAdditionalUtxo {
  code: 3002;
  message: string;
  data: OverlappingAdditionalUtxo;
}
export interface OverlappingAdditionalUtxo {
  overlappingOutputReferences: TransactionOutputReference[];
}
/**
 * Happens when attempting to evaluate execution units on a node that isn't enough synchronized.
 */
export interface EvaluateTransactionFailureNodeTipTooOld {
  code: 3003;
  message: string;
  data: NodeTipTooOld;
}
export interface NodeTipTooOld {
  minimumRequiredEra: Era;
  currentNodeEra: Era;
}
/**
 * The transaction is malformed or missing information; making evaluation impossible.
 */
export interface EvaluateTransactionFailureCannotCreateEvaluationContext {
  code: 3004;
  message: string;
  data: CannotCreateEvaluationContext;
}
export interface CannotCreateEvaluationContext {
  reason: string;
}
/**
 * One or more script execution terminated with an error.
 */
export interface EvaluateTransactionFailureScriptExecutionFailure {
  code: 3005;
  message: string;
  data: ScriptExecutionFailure;
}
/**
 * Some script in the transaction terminated with an error.
 */
export interface ScriptExecutionFailure {
  [k: string]: ScriptExecutionFailureReason[];
}
/**
 * Missing scripts required for validating script inputs.
 */
export interface MissingRequiredScripts {
  missingRequiredScripts: {
    missing: RedeemerPointer[];
    resolved: {
      [k: string]: DigestBlake2B224;
    };
  };
}
/**
 * Plutus interpreter error. Returns additional traces produced by the validator.
 */
export interface ValidatorFailed {
  validatorFailed: {
    error: string;
    traces: string[];
  };
}
/**
 * Non-existing input referenced by a redeemer pointer.
 */
export interface UnknownInputReferencedByRedeemer {
  unknownInputReferencedByRedeemer: TransactionOutputReference;
}
/**
 * Input not locked by a Plutus referenced by a redeemer pointer.
 */
export interface NonScriptInputReferencedByRedeemer {
  nonScriptInputReferencedByRedeemer: TransactionOutputReference;
}
/**
 * Invalid execution budget set for a redeemer. In principle, cannot happen in the context of Ogmios.
 */
export interface IllFormedExecutionBudget {
  illFormedExecutionBudget?: ExecutionUnits;
}
/**
 * Input locked by a script which language has no cost model in current protocol parameters. In principle, cannot happen in the context of Ogmios.
 */
export interface NoCostModelForLanguage {
  noCostModelForLanguage: Language;
}
/**
 * Acquire a point on chain from which to run ledger-state queries.
 */
export interface AcquireLedgerState {
  jsonrpc: "2.0";
  method: "acquireLedgerState";
  params: {
    point: Point | Origin;
  };
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Response to an 'acquireLedgerState' request.
 */
export interface AcquireLedgerStateSuccess {
  jsonrpc: "2.0";
  result: AcquireLedgerStateSuccess1;
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface AcquireLedgerStateSuccess1 {
  acquired: "ledgerState";
  point: Point | Origin;
}
/**
 * Unable to acquire the ledger state at the request point.
 */
export interface AcquireLedgerStateFailure {
  jsonrpc: "2.0";
  error: AcquireLedgerStateFailure1;
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface AcquireLedgerStateFailure1 {
  code: 2000;
  message: string;
  /**
   * A reason for the failure.
   */
  data: string;
}
/**
 * Release a previously acquired ledger state.
 */
export interface ReleaseLedgerState {
  jsonrpc: "2.0";
  method: "releaseLedgerState";
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Response to a 'releaseLedgerState' request.
 */
export interface ReleaseLedgerStateResponse {
  jsonrpc: "2.0";
  result: {
    released: "ledgerState";
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * An era mismatch between a client request and the era the ledger is in. This may occur when running queries on a syncing node and/or when the node is crossing an era.
 */
export interface QueryLedgerStateEraMismatch {
  jsonrpc: "2.0";
  error: {
    code: 2001;
    message: string;
    data: EraMismatch;
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Some query is not available for the requested ledger era.
 */
export interface QueryLedgerStateUnavailableInCurrentEra {
  jsonrpc: "2.0";
  error: {
    code: 2002;
    message: string;
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Previously acquired ledger state is no longer available.
 */
export interface QueryLedgerStateAcquiredExpired {
  jsonrpc: "2.0";
  error: {
    code: 2003;
    message: string;
    /**
     * A reason for the failure.
     */
    data: string;
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Query the current epoch number the ledger is at.
 */
export interface QueryLedgerStateEpoch {
  jsonrpc: "2.0";
  method: "queryLedgerState/epoch";
  params?: unknown;
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface QueryLedgerStateEpochResponse {
  jsonrpc: "2.0";
  result: {
    epoch: Epoch;
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Query the start of the current ledger era.
 */
export interface QueryLedgerStateEraStart {
  jsonrpc: "2.0";
  method: "queryLedgerState/eraStart";
  params?: unknown;
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface QueryLedgerStateEraStartResponse {
  jsonrpc: "2.0";
  result: {
    eraStart: Bound;
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * An era bound which captures the time, slot and epoch at which the era start. The time is relative to the start time of the network.
 */
export interface Bound {
  time: RelativeTime;
  slot: Slot;
  epoch: Epoch;
}
/**
 * Query a summary of the slotting parameters and boundaries for each known era. Useful for doing slot-arithmetic and time conversions.
 */
export interface QueryLedgerStateEraSummaries {
  jsonrpc: "2.0";
  method: "queryLedgerState/eraSummaries";
  params?: unknown;
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface QueryLedgerStateEraSummariesResponse {
  jsonrpc: "2.0";
  result: {
    eraSummaries: EraSummary[];
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Summary of the confirmed parts of the ledger.
 */
export interface EraSummary {
  start: Bound;
  end: Bound | null;
  parameters: EraParameters;
}
/**
 * Parameters that can vary across hard forks.
 */
export interface EraParameters {
  epochLength: Epoch;
  slotLength: SlotLength;
  safeZone: SafeZone | null;
}
/**
 * Query the current distribution of the stake across all known stake pools, relative to the TOTAL stake in the network.
 */
export interface QueryLedgerStateLiveStakeDistribution {
  jsonrpc: "2.0";
  method: "queryLedgerState/liveStakeDistribution";
  params?: unknown;
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface QueryLedgerStateLiveStakeDistributionResponse {
  jsonrpc: "2.0";
  result: {
    liveStakeDistribution: LiveStakeDistribution;
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Distribution of stake across registered stake pools. Each key in the map corresponds to a pool id.
 */
export interface LiveStakeDistribution {
  [k: string]: {
    stake: Ratio;
    vrf: DigestBlake2B256;
  };
}
/**
 * Query the projected rewards of an account in a context where the top stake pools are fully saturated. This projection gives, in principle, a ranking of stake pools that maximizes delegator rewards.
 */
export interface QueryLedgerStateProjectedRewards {
  jsonrpc: "2.0";
  method: "queryLedgerState/projectedRewards";
  params: {
    stake?: Lovelace[];
    scripts?: StakeCredential[];
    keys?: StakeCredential[];
  };
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface QueryLedgerStateProjectedRewardsResponse {
  jsonrpc: "2.0";
  result: {
    projectedRewards: ProjectedRewards;
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Rewards that can be expected assuming a pool is fully saturated. Such rewards are said non-myopic, in opposition to short-sighted rewards looking at immediate benefits. Keys of the map can be either Lovelace amounts or account credentials depending on the query.
 */
export interface ProjectedRewards {
  [k: string]: {
    [k: string]: number;
  };
}
/**
 * Query the last update proposal w.r.t. protocol parameters, if any.
 */
export interface QueryLedgerStateProposedProtocolParameters {
  jsonrpc: "2.0";
  method: "queryLedgerState/proposedProtocolParameters";
  params?: unknown;
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface QueryLedgerStateProposedProtocolParametersResponse {
  jsonrpc: "2.0";
  result: {
    proposedProtocolParameters:
      | ProposedProtocolParametersShelley
      | ProposedProtocolParametersAlonzo
      | ProposedProtocolParametersBabbage;
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface ProposedProtocolParametersShelley {
  [k: string]: ProtocolParametersShelley;
}
export interface ProposedProtocolParametersAlonzo {
  [k: string]: ProtocolParametersAlonzo;
}
export interface ProposedProtocolParametersBabbage {
  [k: string]: ProtocolParametersBabbage;
}
/**
 * Query the current protocol parameters.
 */
export interface QueryLedgerStateProtocolParameters {
  jsonrpc: "2.0";
  method: "queryLedgerState/protocolParameters";
  params?: unknown;
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface QueryLedgerStateProtocolParametersResponse {
  jsonrpc: "2.0";
  result: {
    protocolParameters: ProtocolParametersShelley | ProtocolParametersAlonzo | ProtocolParametersBabbage;
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Query current delegation settings and rewards of some given reward accounts.
 */
export interface QueryLedgerStateRewardAccountSummaries {
  jsonrpc: "2.0";
  method: "queryLedgerState/rewardAccountSummaries";
  params: {
    scripts?: StakeCredential[];
    keys?: StakeCredential[];
  };
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface QueryLedgerStateRewardAccountSummariesResponse {
  jsonrpc: "2.0";
  result: {
    rewardAccountSummaries: RewardAccountSummaries;
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface RewardAccountSummaries {
  [k: string]: RewardAccountSummary;
}
export interface RewardAccountSummary {
  delegate?: StakePoolId;
  rewards?: Lovelace;
}
/**
 * Query details about rewards calculation for the ongoing epoch.
 */
export interface QueryLedgerStateRewardsProvenance {
  jsonrpc: "2.0";
  method: "queryLedgerState/rewardsProvenance";
  params?: unknown;
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface QueryLedgerStateRewardsProvenanceResponse {
  jsonrpc: "2.0";
  result: {
    rewardsProvenance: RewardsProvenance;
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Details about how rewards are calculated for the ongoing epoch.
 */
export interface RewardsProvenance {
  /**
   * Desired number of stake pools.
   */
  desiredNumberOfPools: number;
  /**
   * Influence of the pool owner's pledge on rewards, as a ratio of two integers.
   */
  poolInfluence: string;
  /**
   * Total rewards available for the given epoch.
   */
  totalRewards: bigint;
  /**
   * The total amount of staked Lovelace during this epoch.
   */
  activeStake: bigint;
  pools: {
    [k: string]: StakePoolSummary;
  };
}
export interface StakePoolSummary {
  stake: Lovelace;
  ownerStake: Lovelace1;
  /**
   * Number of blocks produced divided by expected number of blocks (based on stake and epoch progress). Can be larger than 1.0 for pools that get lucky.
   */
  approximatePerformance: number;
  /**
   * Some of the pool parameters relevant for the reward calculation.
   */
  poolParameters: {
    cost: Lovelace;
    margin: Ratio;
    pledge: Lovelace;
  };
}
/**
 * Query the list of all stake pool identifiers currently registered and active.
 */
export interface QueryLedgerStateStakePools {
  jsonrpc: "2.0";
  method: "queryLedgerState/stakePools";
  params?: unknown;
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface QueryLedgerStateStakePoolsResponse {
  jsonrpc: "2.0";
  result: {
    stakePools: {
      id: StakePoolId;
    }[];
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Query registered parameters for given stake pools.
 */
export interface QueryLedgerStateStakePoolParameters {
  jsonrpc: "2.0";
  method: "queryLedgerState/stakePoolParameters";
  params: {
    stakePools: (StakePoolId | string)[];
  };
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface QueryLedgerStateStakePoolParametersResponse {
  jsonrpc: "2.0";
  result: {
    stakePoolParameters: {
      [k: string]: StakePoolParameters;
    };
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Query the current tip the ledger is at. Said differently, the slot number and header hash of the last block that has been processed by the ledger.
 */
export interface QueryLedgerStateTip {
  jsonrpc: "2.0";
  method: "queryLedgerState/tip";
  params?: unknown;
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface QueryLedgerStateTipResponse {
  jsonrpc: "2.0";
  result: {
    tip: Point | Origin;
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Query the current Utxo set, restricted to some output references or addresses.
 */
export interface QueryLedgerStateUtxo {
  jsonrpc: "2.0";
  method: "queryLedgerState/utxo";
  params?: UtxoByOutputReferences | UtxoByAddresses | WholeUtxo;
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface UtxoByOutputReferences {
  outputReferences: TransactionOutputReference[];
}
export interface UtxoByAddresses {
  addresses: Address[];
}
export interface WholeUtxo {}
export interface QueryLedgerStateUtxoResponse {
  jsonrpc: "2.0";
  result: {
    utxo: Utxo;
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Query the networks highest block number.
 */
export interface QueryNetworkBlockHeight {
  jsonrpc: "2.0";
  method: "queryNetwork/blockHeight";
  params?: unknown;
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface QueryNetworkBlockHeightResponse {
  jsonrpc: "2.0";
  result: {
    blockHeight: BlockHeight | Origin;
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Query the genesis configuration of a given era.
 */
export interface QueryNetworkGenesisConfiguration {
  jsonrpc: "2.0";
  method: "queryNetwork/genesisConfiguration";
  params: {
    era: EraWithGenesis;
  };
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface QueryNetworkGenesisConfigurationResponse {
  jsonrpc: "2.0";
  result: {
    genesisConfiguration:
      | {
          byron: GenesisByron;
        }
      | {
          shelley: GenesisShelley;
        }
      | {
          alonzo: GenesisAlonzo;
        };
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * A Byron genesis configuration, with information used to bootstrap the era. Some parameters are also updatable across the era.
 */
export interface GenesisByron {
  genesisKeyHashes: DigestBlake2B224[];
  genesisDelegations: {
    [k: string]: BootstrapOperationalCertificate;
  };
  systemStart: UtcTime;
  initialFunds: {
    [k: string]: Lovelace;
  };
  initialCoinOffering: {
    [k: string]: Lovelace;
  };
  securityParameter: UInt64;
  networkMagic: NetworkMagic;
  protocolParameters: ProtocolParametersByron;
}
/**
 * A Shelley genesis configuration, with information used to bootstrap the era. Some parameters are also updatable across the era.
 */
export interface GenesisShelley {
  systemStart: UtcTime;
  networkMagic: NetworkMagic;
  network: Network;
  activeSlotsCoefficient: Ratio;
  securityParameter: UInt64;
  epochLength: Epoch;
  slotsPerKesPeriod: UInt64;
  maxKesEvolutions: UInt64;
  slotLength: SlotLength;
  updateQuorum: UInt64;
  maxLovelaceSupply: UInt64;
  protocolParameters: ProtocolParametersShelley;
  initialDelegates: InitialDelegates;
  initialFunds: InitialFunds;
  initialPools: GenesisPools;
}
export interface InitialDelegates {
  [k: string]: GenesisDelegate;
}
/**
 * A Genesis delegate, in charge of Cardano's governance.
 */
export interface GenesisDelegate {
  delegate: DigestBlake2B224;
  vrf: DigestBlake2B256;
}
export interface InitialFunds {
  [k: string]: Lovelace;
}
/**
 * A Genesis stake pools configuration; primarily used for bootstrapping test networks.
 */
export interface GenesisPools {
  pools: {
    [k: string]: StakePoolParameters;
  };
  delegators: {
    [k: string]: StakePoolId;
  };
}
/**
 * An Alonzo genesis configuration, with information used to bootstrap the era. Some parameters are also updatable across the era.
 */
export interface GenesisAlonzo {
  coinsPerUtxoWord: UInt64;
  collateralPercentage: UInt64;
  costModels: CostModels;
  maxCollateralInputs: UInt64;
  maxExecutionUnitsPerBlock: ExecutionUnits;
  maxExecutionUnitsPerTransaction: ExecutionUnits;
  maxValueSize: UInt64;
  prices: Prices;
}
/**
 * Query the network start time.
 */
export interface QueryNetworkStartTime {
  jsonrpc: "2.0";
  method: "queryNetwork/startTime";
  params?: unknown;
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface QueryNetworkStartTimeResponse {
  jsonrpc: "2.0";
  result: {
    startTime: UtcTime;
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Get the current network tip. Said differently, this is the most recent slot and block header hash that the node it aware of.
 */
export interface QueryNetworkTip {
  jsonrpc: "2.0";
  method: "queryNetwork/tip";
  params?: unknown;
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface QueryNetworkTipResponse {
  jsonrpc: "2.0";
  result: {
    tip: Point | Origin;
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Acquire a mempool snapshot. This is blocking until a new (i.e different) snapshot is available.
 */
export interface AcquireMempool {
  jsonrpc: "2.0";
  method: "acquireMempool";
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Response to a 'acquireMempool' request.
 */
export interface AcquireMempoolResponse {
  jsonrpc: "2.0";
  result: {
    acquired: "mempool";
    slot: Slot;
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Request the next transaction from an acquired mempools napshot.
 */
export interface NextTransaction {
  jsonrpc: "2.0";
  method: "nextTransaction";
  params?: {
    fields?: "all";
  };
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Response to a 'nextTransaction' request.
 */
export interface NextTransactionResponse {
  jsonrpc: "2.0";
  /**
   * A transaction (or id) or an empty object if there's no more transactions.
   */
  result: {
    transaction:
      | {
          id: TransactionId;
        }
      | Transaction
      | null;
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Ask whether a given transaction is present in the acquired mempool snapshot.
 */
export interface HasTransaction {
  jsonrpc: "2.0";
  method: "hasTransaction";
  params: {
    id: TransactionId;
  };
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Response to a 'HasTransaction' request.
 */
export interface HasTransactionResponse {
  jsonrpc: "2.0";
  result: {
    hasTransaction: boolean;
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Get size and capacities of the mempool (acquired snapshot).
 */
export interface SizeOfMempool {
  jsonrpc: "2.0";
  method: "sizeOfMempool";
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Response to a 'sizeOfMempool' request.
 */
export interface SizeOfMempoolResponse {
  jsonrpc: "2.0";
  result: {
    mempool: MempoolSizeAndCapacity;
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
export interface MempoolSizeAndCapacity {
  maxCapacity: {
    bytes: UInt321;
  };
  currentSize: {
    bytes: UInt321;
  };
  transactions: {
    count: UInt321;
  };
}
/**
 * Release a previously acquired mempool snapshot.
 */
export interface ReleaseMempool {
  jsonrpc: "2.0";
  method: "releaseMempool";
  /**
   * An arbitrary JSON value that will be mirrored back in the response.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * Response to a 'releaseMempool' request.
 */
export interface ReleaseMempoolResponse {
  jsonrpc: "2.0";
  result: {
    released: "mempool";
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
/**
 * A generic error in the JSON-RPC protocol. This is returned by the server when a request from clients is deemed invalid or, when the server was unable to reply to a well-formed request.
 */
export interface RpcError {
  jsonrpc: "2.0";
  error: {
    /**
     * An error code telling about the nature of the error.
     */
    code: number;
    /**
     * A descriptive error message giving hints about the error.
     */
    message?: string;
    /**
     * Some optional data / context about the error. The exact type of this (optional) field depends on the error.
     */
    data?: {
      [k: string]: unknown;
    };
  };
  /**
   * Any value that was set by a client request in the 'id' field.
   */
  id?: {
    [k: string]: unknown;
  };
}
