/* tslint:disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

/**
 * A Cardano Block, which can take different forms depending on the era.
 */
export type Block = Babbage | Alonzo | Mary | Allegra | Shelley | Byron;
/**
 * A Blake2b 32-byte digest of an era-independent block body.
 */
export type DigestBlake2BBlockBody = string;
/**
 * A Blake2b 32-byte digest of a transaction body, CBOR-encoded.
 */
export type TxId = string;
/**
 * A Cardano address (either legacy format or new format).
 */
export type Address = string;
/**
 * A number of lovelace, possibly large when summed up.
 */
export type Lovelace = bigint;
/**
 * A number of asset, can be negative went burning assets.
 */
export type AssetQuantity = bigint;
/**
 * A Blake2b 32-byte digest of a serialized datum, CBOR-encoded.
 */
export type DigestBlake2BDatum = string;
export type Datum = string;
export type Script = Native | PlutusV1 | PlutusV2;
/**
 * A phase-1 monetary script. Timelocks constraints are only supported since Allegra.
 */
export type ScriptNative = DigestBlake2BVerificationKey | Any | All | NOf | ExpiresAt | StartsAt;
/**
 * A Blake2b 28-byte digest of an Ed25519 verification key.
 */
export type DigestBlake2BVerificationKey = string;
/**
 * An absolute slot number.
 */
export type Slot = number;
/**
 * A phase-2 Plutus script; or said differently, a serialized Plutus-core program.
 */
export type ScriptPlutus = string;
export type Certificate =
  | StakeDelegation
  | StakeKeyRegistration
  | StakeKeyDeregistration
  | PoolRegistration
  | PoolRetirement
  | GenesisDelegation
  | MoveInstantaneousRewards;
/**
 * A Blake2b 28-byte digest of a verification key or a script.
 */
export type DigestBlake2BCredential = string;
/**
 * A Blake2b 32-byte digest of a pool's verification key.
 */
export type PoolId = string;
/**
 * A ratio of two integers, to express exact fractions.
 */
export type Ratio = string;
/**
 * A Blake2b 32-byte digest of a VRF verification key.
 */
export type DigestBlake2BVrfVerificationKey = string;
/**
 * A Blake2b 32-byte digest of stake pool (canonical) JSON metadata.
 */
export type DigestBlake2BPoolMetadata = string;
export type Relay = ByAddress | ByName;
/**
 * A reward account, also known as 'stake address'.
 */
export type RewardAccount = string;
/**
 * An epoch number or length.
 */
export type Epoch = number;
/**
 * An amount, possibly negative, in Lovelace (1e6 Lovelace = 1 Ada).
 */
export type LovelaceDelta = number;
/**
 * Source of rewards as defined by the protocol parameters.
 */
export type RewardPot = "reserves" | "treasury";
export type UInt64 = number;
export type UInt32 = number;
export type Int64 = number;
/**
 * A network target, as defined since the Shelley era.
 */
export type Network = "mainnet" | "testnet";
/**
 * A Blake2b 32-byte digest of a script-integrity hash (i.e redeemers, datums and cost model, CBOR-encoded).
 */
export type DigestBlake2BScriptIntegrity = string;
/**
 * A signature coming from an Ed25519 or Ed25519-BIP32 signing key.
 */
export type Signature = string;
/**
 * An Ed25519 verification key.
 */
export type VerificationKey = string;
/**
 * An Ed25519-BIP32 chain-code for key deriviation.
 */
export type ChainCode = string;
/**
 * Extra attributes carried by Byron addresses (network magic and/or HD payload).
 */
export type AddressAttributes = string;
/**
 * Plutus data, CBOR-serialised.
 */
export type RedeemerData = string;
/**
 * A Blake2b 32-byte digest of an 'AuxiliaryDataBody', serialised as CBOR.
 */
export type DigestBlake2BAuxiliaryDataBody = string;
export type Metadatum = Int | String | Bytes | List | Map;
export type DigestBlake2BBlockHeader = string | "genesis";
/**
 * A block number, the i-th block to be minted is number i.
 */
export type BlockNo = number;
/**
 * A key identifying a block issuer.
 */
export type IssuerVrfVerificationKey = string;
/**
 * The size of the block in bytes.
 */
export type BlockSize = number;
export type KesVerificationKey = string;
/**
 * Signature proving a block was issued by a given issuer VRF key.
 */
export type IssuerSignature = string;
export type VrfProof = string;
export type VrfOutput = string;
export type Nonce = Neutral | DigestBlake2BNonce;
export type Neutral = "neutral";
/**
 * A Blake2b 32-byte digest of some arbitrary to make a nonce.
 */
export type DigestBlake2BNonce = string;
/**
 * A block in the Byron era. Most blocks are stanard blocks, but once at the beginning of each era is an additional epoch boundary block (a.k.a. EBB)
 */
export type BlockByron = StandardBlock | EpochBoundaryBlock;
/**
 * An Ed25519-BIP32 Byron genesis delegate verification key with chain-code.
 */
export type GenesisVerificationKey = string;
/**
 * A Blake2b 32-byte digest of a Merkle tree (or all block's transactions) root hash.
 */
export type DigestBlake2BMerkleRoot = string;
/**
 * A Blake2b 32-byte digest of a Byron transaction witness set, CBOR-encoded.
 */
export type DigestBlake2BBlockByronBodyTxPayloadWitness = string;
/**
 * A Blake2b 32-byte digest of a Byron delegation payload, CBOR-encoded.
 */
export type DigestBlake2BBlockByronBodyDlgPayload = string;
/**
 * A Blake2b 32-byte digest of a Byron update payload, CBOR-encoded.
 */
export type DigestBlake2BBlockByronBodyUpdatePayload = string;
export type ProtocolMagicId = number;
export type TxWitness = WitnessVk | RedeemWitness;
export type TipOrOrigin = Tip | Origin;
/**
 * The origin of the blockchain. This point is special in the sense that it doesn't point to any existing slots, but is preceding any existing other point.
 */
export type Origin = "origin";
export type PointOrOrigin = Point | Origin;
export type Era = "Byron" | "Shelley" | "Allegra" | "Mary" | "Alonzo" | "Babbage";
/**
 * A Blake2b 32-byte digest of a phase-1 or phase-2 script, CBOR-encoded.
 */
export type DigestBlake2BScript = string;
export type InvalidEntity =
  | {
      type: "address";
      entity: Address;
    }
  | {
      type: "poolRegistration";
      entity: PoolId;
    }
  | {
      type: "rewardAccount";
      entity: RewardAccount;
    };
export type UInt8 = number;
export type VotingPeriod = "voteForThisEpoch" | "voteForNextEpoch";
export type ScriptPurpose = Spend | Mint | Certificate1 | Withdrawal;
export type Utxo = [TxIn, TxOut][];
export type Language = "plutus:v1" | "plutus:v2";
export type SubmitTxError = (
  | EraMismatch
  | InvalidWitnesses
  | MissingVkWitnesses
  | MissingScriptWitnesses
  | ScriptWitnessNotValidating
  | InsufficientGenesisSignatures
  | MissingTxMetadata
  | MissingTxMetadataHash
  | TxMetadataHashMismatch
  | BadInputs
  | ExpiredUtxo
  | OutsideOfValidityInterval
  | TxTooLarge
  | MissingAtLeastOneInputUtxo
  | InvalidMetadata
  | FeeTooSmall
  | ValueNotConserved
  | NetworkMismatch
  | OutputTooSmall
  | TooManyAssetsInOutput
  | AddressAttributesTooLarge
  | TriesToForgeAda
  | DelegateNotRegistered
  | UnknownOrIncompleteWithdrawals
  | StakePoolNotRegistered
  | WrongRetirementEpoch
  | WrongPoolCertificate
  | StakeKeyAlreadyRegistered
  | PoolCostTooSmall
  | PoolMetadataHashTooBig
  | StakeKeyNotRegistered
  | RewardAccountNotExisting
  | RewardAccountNotEmpty
  | WrongCertificateType
  | UnknownGenesisKey
  | AlreadyDelegating
  | InsufficientFundsForMir
  | TooLateForMir
  | MirTransferNotCurrentlyAllowed
  | MirNegativeTransferNotCurrentlyAllowed
  | MirProducesNegativeUpdate
  | DuplicateGenesisVrf
  | NonGenesisVoters
  | UpdateWrongEpoch
  | ProtocolVersionCannotFollow
  | MissingRequiredRedeemers
  | MissingRequiredDatums
  | UnspendableDatums
  | ExtraDataMismatch
  | MissingRequiredSignatures
  | UnspendableScriptInputs
  | ExtraRedeemers
  | MissingDatumHashesForInputs
  | MissingCollateralInputs
  | CollateralTooSmall
  | CollateralIsScript
  | CollateralHasNonAdaAssets
  | TooManyCollateralInputs
  | ExecutionUnitsTooLarge
  | OutsideForecast
  | ValidationTagMismatch
  | CollectErrors
  | ExtraScriptWitnesses
  | MirNegativeTransfer
  | TotalCollateralMismatch
  | MalformedReferenceScripts
  | MalformedScriptWitnesses
)[];
export type RedeemerPointer = string;
/**
 * Errors which may occur when evaluating an on-chain script.
 */
export type ScriptFailure = (
  | ExtraRedeemers
  | MissingRequiredDatums
  | MissingRequiredScripts
  | ValidatorFailed
  | UnknownInputReferencedByRedeemer
  | NonScriptInputReferencedByRedeemer
  | IllFormedExecutionBudget
  | NoCostModelForLanguage
)[];
export type AcquireFailureDetails = "pointTooOld" | "pointNotOnChain";
export type Null = null;
export type GetEraStart = "eraStart";
export type GetEraSummaries = "eraSummaries";
export type GetLedgerTip = "ledgerTip";
export type GetCurrentEpoch = "currentEpoch";
export type StakeCredential = Base16 | Bech32 | StakeAddress;
/**
 * A Blake2b 28-byte digest of a verification key or a script.
 */
export type Base16 = string;
/**
 * A Blake2b 28-byte digest of a verification key or script.
 */
export type Bech32 = string;
/**
 * A stake address (a.k.a reward account)
 */
export type StakeAddress = string;
export type GetCurrentProtocolParameters = "currentProtocolParameters";
export type GetProposedProtocolParameters = "proposedProtocolParameters";
export type GetStakeDistribution = "stakeDistribution";
export type GetUtxo = "utxo";
export type GetRewardsProvenanceDeprecated = "rewardsProvenance";
export type GetRewardsProvenance = "rewardsProvenance'";
export type GetPoolsRanking = "poolsRanking";
export type GetPoolIds = "poolIds";
export type GetChainTip = "chainTip";
export type GetBlockHeight = "blockHeight";
export type GetSystemStart = "systemStart";
/**
 * A time in seconds relative to another one (typically, system start or era start). Starting from v5.5.4, this can be a floating number. Before v5.5.4, the floating value would be rounded to the nearest second.
 */
export type RelativeTime = number;
/**
 * The requested query is not available in the current node era. It could be that the node is not fully synced.
 */
export type QueryUnavailableInCurrentEra = "QueryUnavailableInCurrentEra";
/**
 * A slot length, in seconds. Starting from v5.5.4, this can be a floating number. Before v5.5.4, the floating value would be rounded to the nearest second.
 */
export type SlotLength = number;
/**
 * Number of slots from the tip of the ledger in which it is guaranteed that no hard fork can take place. This should be (at least) the number of slots in which we are guaranteed to have k blocks.
 */
export type SafeZone = number;
export type UtcTime = string;
/**
 * A magic number for telling networks apart. (e.g. 764824073)
 */
export type NetworkMagic = number;
export type BlockNoOrOrigin = BlockNo | Origin;

export interface Ogmios {
  /**
   * Request next block from the current cardano-node's cursor.
   */
  RequestNext: {
    jsonrpc: "2.0";
    method: "RequestNext";
    /**
     * An arbitrary JSON value that will be mirrored back in the response.
     */
    id?: {
      [k: string]: unknown;
    };
  };
  /**
   * Request next block from the current cardano-node's cursor.
   */
  RequestNextResponse: {
    jsonrpc: "2.0";
    result: RollForward | RollBackward;
    /**
     * Any value that was set by a client request in the 'id' field.
     */
    id?: {
      [k: string]: unknown;
    };
  };
  /**
   * Ask cardano-node to find an intersection between its local chain and the given points.
   */
  FindIntersect: {
    jsonrpc: "2.0";
    method: "FindIntersect";
    params: {
      points?: PointOrOrigin[];
    };
    /**
     * An arbitrary JSON value that will be mirrored back in the response.
     */
    id?: {
      [k: string]: unknown;
    };
  };
  FindIntersectResponse: {
    jsonrpc: "2.0";
    /**
     * Intersection found if any, alongside the cardano-node's current tip.
     */
    result: IntersectionFound | IntersectionNotFound;
    /**
     * Any value that was set by a client request in the 'id' field.
     */
    id?: {
      [k: string]: unknown;
    };
  };
  /**
   * Submit a signed and serialized transaction to the network.
   */
  SubmitTx: {
    jsonrpc: "2.0";
    method: "SubmitTx";
    params: {
      submit: string;
    };
    /**
     * An arbitrary JSON value that will be mirrored back in the response.
     */
    id?: {
      [k: string]: unknown;
    };
  };
  SubmitTxResponse: {
    jsonrpc: "2.0";
    result: SubmitSuccess | SubmitFail;
    /**
     * Any value that was set by a client request in the 'id' field.
     */
    id?: {
      [k: string]: unknown;
    };
  };
  /**
   * Evaluate execution units for which redeemers's budget hasn't yet been set.
   */
  EvaluateTx: {
    jsonrpc: "2.0";
    params: {
      evaluate: string;
      additionalUtxoSet?: Utxo;
    };
    /**
     * An arbitrary JSON value that will be mirrored back in the response.
     */
    id?: {
      [k: string]: unknown;
    };
  };
  EvaluateTxResponse: {
    jsonrpc: "2.0";
    result: EvaluationResult | EvaluationFailure;
    /**
     * Any value that was set by a client request in the 'id' field.
     */
    id?: {
      [k: string]: unknown;
    };
  };
  /**
   * Acquire a point on chain from which run queries.
   */
  Acquire: {
    jsonrpc: "2.0";
    method: "Acquire";
    params: {
      point: PointOrOrigin;
    };
    /**
     * An arbitrary JSON value that will be mirrored back in the response.
     */
    id?: {
      [k: string]: unknown;
    };
  };
  /**
   * Response to an 'Acquire' request.
   */
  AcquireResponse: {
    jsonrpc: "2.0";
    result: AcquireSuccess | AcquireFailure;
    /**
     * Any value that was set by a client request in the 'id' field.
     */
    id?: {
      [k: string]: unknown;
    };
  };
  /**
   * Release a point on chain previously acquired.
   */
  Release: {
    jsonrpc: "2.0";
    method: "Release";
    /**
     * An arbitrary JSON value that will be mirrored back in the response.
     */
    id?: {
      [k: string]: unknown;
    };
  };
  /**
   * Response to a 'Release' request.
   */
  ReleaseResponse: {
    jsonrpc: "2.0";
    result: "Released";
    /**
     * Any value that was set by a client request in the 'id' field.
     */
    id?: {
      [k: string]: unknown;
    };
  };
  /**
   * Acquire a mempool snapshot. This is blocking until a new (i.e different) snapshot is available.
   */
  AwaitAcquire: {
    jsonrpc: "2.0";
    method: "AwaitAcquire";
    /**
     * An arbitrary JSON value that will be mirrored back in the response.
     */
    id?: {
      [k: string]: unknown;
    };
  };
  /**
   * Response to a 'AwaitAcquire' request.
   */
  AwaitAcquireResponse: {
    jsonrpc: "2.0";
    result: AwaitAcquired;
    /**
     * Any value that was set by a client request in the 'id' field.
     */
    id?: {
      [k: string]: unknown;
    };
  };
  /**
   * Request the next transaction from an acquired snapshot.
   */
  NextTx: {
    jsonrpc: "2.0";
    method: "NextTx";
    params?: {
      fields?: "all";
    };
    /**
     * An arbitrary JSON value that will be mirrored back in the response.
     */
    id?: {
      [k: string]: unknown;
    };
  };
  /**
   * Response to a 'NextTx' request.
   */
  NextTxResponse: {
    jsonrpc: "2.0";
    result: TxId | TxAlonzo | TxBabbage | Null;
    /**
     * Any value that was set by a client request in the 'id' field.
     */
    id?: {
      [k: string]: unknown;
    };
  };
  /**
   * Ask whether a given transaction is present in the acquired mempool snapshot.
   */
  HasTx: {
    jsonrpc: "2.0";
    method: "HasTx";
    params: {
      id: TxId;
    };
    /**
     * An arbitrary JSON value that will be mirrored back in the response.
     */
    id?: {
      [k: string]: unknown;
    };
  };
  /**
   * Response to a 'HasTx' request.
   */
  HasTxResponse: {
    jsonrpc: "2.0";
    result: boolean;
    /**
     * Any value that was set by a client request in the 'id' field.
     */
    id?: {
      [k: string]: unknown;
    };
  };
  /**
   * Get size and capacities of the mempool (acquired snapshot).
   */
  SizeAndCapacity: {
    jsonrpc: "2.0";
    method: "SizeAndCapacity";
    /**
     * An arbitrary JSON value that will be mirrored back in the response.
     */
    id?: {
      [k: string]: unknown;
    };
  };
  /**
   * Response to a 'SizeAndCapacity' request.
   */
  SizeAndCapacityResponse: {
    jsonrpc: "2.0";
    result: MempoolSizeAndCapacity;
    /**
     * Any value that was set by a client request in the 'id' field.
     */
    id?: {
      [k: string]: unknown;
    };
  };
  /**
   * Release a previously acquired mempool snapshot.
   */
  ReleaseMempool?: {
    jsonrpc: "2.0";
    method: "ReleaseMempool";
    /**
     * An arbitrary JSON value that will be mirrored back in the response.
     */
    id?: {
      [k: string]: unknown;
    };
  };
  /**
   * Response to a 'ReleaseMempool' request.
   */
  ReleaseMempoolResponse?: {
    jsonrpc: "2.0";
    result: "Released";
    /**
     * Any value that was set by a client request in the 'id' field.
     */
    id?: {
      [k: string]: unknown;
    };
  };
  /**
   * Query the ledger / node.
   */
  Query: {
    jsonrpc: "2.0";
    method: "Query";
    params: {
      query:
        | GetEraStart
        | GetEraSummaries
        | GetLedgerTip
        | GetCurrentEpoch
        | GetNonMyopicMemberRewards
        | GetDelegationsAndRewards
        | GetCurrentProtocolParameters
        | GetProposedProtocolParameters
        | GetStakeDistribution
        | GetUtxo
        | GetUtxoByAddress
        | GetUtxoByTxIn
        | GetGenesisConfig
        | GetRewardsProvenanceDeprecated
        | GetRewardsProvenance
        | GetPoolsRanking
        | GetPoolIds
        | GetPoolParameters
        | GetChainTip
        | GetBlockHeight
        | GetSystemStart;
    };
    /**
     * An arbitrary JSON value that will be mirrored back in the response.
     */
    id?: {
      [k: string]: unknown;
    };
  };
  "QueryResponse[eraStart]": {
    jsonrpc: "2.0";
    result: Bound | QueryUnavailableInCurrentEra;
    /**
     * Any value that was set by a client request in the 'id' field.
     */
    id?: {
      [k: string]: unknown;
    };
  };
  "QueryResponse[eraSummaries]": {
    jsonrpc: "2.0";
    result: QueryUnavailableInCurrentEra | EraSummary[];
    /**
     * Any value that was set by a client request in the 'id' field.
     */
    id?: {
      [k: string]: unknown;
    };
  };
  "QueryResponse[ledgerTip]": {
    jsonrpc: "2.0";
    result: PointOrOrigin | EraMismatch | QueryUnavailableInCurrentEra;
    /**
     * Any value that was set by a client request in the 'id' field.
     */
    id?: {
      [k: string]: unknown;
    };
  };
  "QueryResponse[currentEpoch]": {
    jsonrpc: "2.0";
    result: Epoch | EraMismatch | QueryUnavailableInCurrentEra;
    /**
     * Any value that was set by a client request in the 'id' field.
     */
    id?: {
      [k: string]: unknown;
    };
  };
  "QueryResponse[nonMyopicMemberRewards]": {
    jsonrpc: "2.0";
    result: NonMyopicMemberRewards | EraMismatch | QueryUnavailableInCurrentEra;
    /**
     * Any value that was set by a client request in the 'id' field.
     */
    id?: {
      [k: string]: unknown;
    };
  };
  "QueryResponse[delegationsAndRewards]": {
    jsonrpc: "2.0";
    result: DelegationsAndRewardsByAccounts | EraMismatch | QueryUnavailableInCurrentEra;
    /**
     * Any value that was set by a client request in the 'id' field.
     */
    id?: {
      [k: string]: unknown;
    };
  };
  "QueryResponse[currentProtocolParameters]": {
    jsonrpc: "2.0";
    result:
      | ProtocolParametersShelley
      | ProtocolParametersAlonzo
      | ProtocolParametersBabbage
      | EraMismatch
      | QueryUnavailableInCurrentEra;
    /**
     * Any value that was set by a client request in the 'id' field.
     */
    id?: {
      [k: string]: unknown;
    };
  };
  "QueryResponse[proposedProtocolParameters]": {
    jsonrpc: "2.0";
    result:
      | ProposedProtocolParametersShelley
      | ProposedProtocolParametersAlonzo
      | ProposedProtocolParametersBabbage
      | EraMismatch
      | QueryUnavailableInCurrentEra;
    /**
     * Any value that was set by a client request in the 'id' field.
     */
    id?: {
      [k: string]: unknown;
    };
  };
  "QueryResponse[stakeDistribution]": {
    jsonrpc: "2.0";
    result: PoolDistribution | EraMismatch | QueryUnavailableInCurrentEra;
    /**
     * Any value that was set by a client request in the 'id' field.
     */
    id?: {
      [k: string]: unknown;
    };
  };
  "QueryResponse[utxo]": {
    jsonrpc: "2.0";
    result: Utxo | EraMismatch | QueryUnavailableInCurrentEra;
    /**
     * Any value that was set by a client request in the 'id' field.
     */
    id?: {
      [k: string]: unknown;
    };
  };
  "QueryResponse[genesisConfig]": {
    jsonrpc: "2.0";
    result: GenesisByron | GenesisShelley | GenesisAlonzo | EraMismatch | QueryUnavailableInCurrentEra;
    /**
     * Any value that was set by a client request in the 'id' field.
     */
    id?: {
      [k: string]: unknown;
    };
  };
  /**
   * This query is now deprecated. Use /rewardsProvenance'/ instead.
   */
  "QueryResponse[rewardsProvenance]": {
    jsonrpc: "2.0";
    result: RewardsProvenance | EraMismatch | QueryUnavailableInCurrentEra;
    /**
     * Any value that was set by a client request in the 'id' field.
     */
    id?: {
      [k: string]: unknown;
    };
  };
  "QueryResponse[rewardsProvenance']": {
    jsonrpc: "2.0";
    result: RewardsProvenance1 | EraMismatch | QueryUnavailableInCurrentEra;
    /**
     * Any value that was set by a client request in the 'id' field.
     */
    id?: {
      [k: string]: unknown;
    };
  };
  "QueryResponse[poolIds]": {
    jsonrpc: "2.0";
    result: PoolId[] | EraMismatch | QueryUnavailableInCurrentEra;
    /**
     * Any value that was set by a client request in the 'id' field.
     */
    id?: {
      [k: string]: unknown;
    };
  };
  "QueryResponse[poolParameters]": {
    jsonrpc: "2.0";
    result:
      | {
          [k: string]: PoolParameters;
        }
      | EraMismatch
      | QueryUnavailableInCurrentEra;
    /**
     * Any value that was set by a client request in the 'id' field.
     */
    id?: {
      [k: string]: unknown;
    };
  };
  "QueryResponse[poolsRanking]": {
    jsonrpc: "2.0";
    result: PoolsRanking | EraMismatch | QueryUnavailableInCurrentEra;
    /**
     * Any value that was set by a client request in the 'id' field.
     */
    id?: {
      [k: string]: unknown;
    };
  };
  "QueryResponse[blockHeight]": {
    jsonrpc: "2.0";
    result: BlockNoOrOrigin | QueryUnavailableInCurrentEra;
    /**
     * Any value that was set by a client request in the 'id' field.
     */
    id?: {
      [k: string]: unknown;
    };
  };
  "QueryResponse[chainTip]": {
    jsonrpc: "2.0";
    result: PointOrOrigin | QueryUnavailableInCurrentEra;
    /**
     * Any value that was set by a client request in the 'id' field.
     */
    id?: {
      [k: string]: unknown;
    };
  };
  "QueryResponse[systemStart]": {
    jsonrpc: "2.0";
    result: UtcTime | QueryUnavailableInCurrentEra;
    /**
     * Any value that was set by a client request in the 'id' field.
     */
    id?: {
      [k: string]: unknown;
    };
  };
  /**
   * A fault in the JSON-RPC protocol. This is returned by the server when a request from clients is deemed invalid or, when the server was unable to reply to a well-formed request.
   */
  Fault: {
    jsonrpc: "2.0";
    error: {
      /**
       * An error code telling about the nature of the error.
       */
      code: number;
      /**
       * A descriptive error message giving hints about the error.
       */
      message?: string;
    };
    /**
     * Any value that was set by a client request in the 'id' field.
     */
    id?: {
      [k: string]: unknown;
    };
  };
  [k: string]: unknown;
}
export interface RollForward {
  RollForward: {
    block: Block;
    tip: TipOrOrigin;
  };
}
export interface Babbage {
  babbage: BlockBabbage;
}
export interface BlockBabbage {
  body: TxBabbage[];
  headerHash: DigestBlake2BBlockHeader;
  header: {
    blockHeight: BlockNo;
    slot: Slot;
    prevHash: DigestBlake2BBlockHeader;
    issuerVk: VerificationKey;
    issuerVrf: IssuerVrfVerificationKey;
    blockSize: BlockSize;
    blockHash: DigestBlake2BBlockBody;
    opCert: OpCert;
    protocolVersion: ProtocolVersion;
    signature: IssuerSignature;
    vrfInput: CertifiedVrf;
  };
}
export interface TxBabbage {
  id: DigestBlake2BBlockBody;
  inputSource: "inputs" | "collaterals";
  body: {
    inputs: TxIn[];
    references?: TxIn[];
    collaterals?: TxIn[];
    collateralReturn?: TxOut;
    totalCollateral?: Lovelace;
    outputs: TxOut[];
    certificates?: Certificate[];
    withdrawals?: Withdrawals;
    fee: Lovelace;
    validityInterval: ValidityInterval;
    update?: UpdateProposalBabbage;
    mint?: Value;
    network?: Network;
    scriptIntegrityHash?: DigestBlake2BScriptIntegrity;
    requiredExtraSignatures?: DigestBlake2BVerificationKey[];
  };
  witness: {
    signatures: {
      [k: string]: Signature;
    };
    scripts: {
      [k: string]: Script;
    };
    bootstrap: BootstrapWitness[];
    datums: {
      [k: string]: Datum;
    };
    redeemers: {
      [k: string]: Redeemer;
    };
  };
  metadata?: AuxiliaryData;
  /**
   * The raw serialized transaction, as found on-chain.
   */
  raw: string;
}
export interface TxIn {
  txId: TxId;
  index: number;
}
/**
 * A transaction output. Since Mary, 'value' always return a multi-asset value. Since Alonzo, 'datumHash' is always present (albeit sometimes 'null'). Since Babbage, 'datum' & 'script' are always present (albeit sometimes 'null').
 */
export interface TxOut {
  address: Address;
  value: Value;
  datumHash?: DigestBlake2BDatum;
  datum?: Datum;
  script?: Script;
}
export interface Value {
  coins: Lovelace;
  assets?: {
    [k: string]: AssetQuantity;
  };
}
export interface Native {
  native: ScriptNative;
}
export interface Any {
  any: ScriptNative[];
}
export interface All {
  all: ScriptNative[];
}
export interface NOf {
  [k: string]: ScriptNative[];
}
export interface ExpiresAt {
  expiresAt: Slot;
}
export interface StartsAt {
  startsAt: Slot;
}
export interface PlutusV1 {
  "plutus:v1": ScriptPlutus;
}
export interface PlutusV2 {
  "plutus:v2": ScriptPlutus;
}
/**
 * A stake delegation certificate, from a delegator to a stake pool.
 */
export interface StakeDelegation {
  stakeDelegation: {
    delegator: DigestBlake2BCredential;
    delegatee: PoolId;
  };
}
/**
 * A stake key registration certificate.
 */
export interface StakeKeyRegistration {
  stakeKeyRegistration: DigestBlake2BCredential;
}
/**
 * A stake key de-registration certificate.
 */
export interface StakeKeyDeregistration {
  stakeKeyDeregistration: DigestBlake2BCredential;
}
/**
 * A pool registration certificate.
 */
export interface PoolRegistration {
  poolRegistration: PoolParameters;
}
export interface PoolParameters {
  id: PoolId;
  owners: DigestBlake2BVerificationKey[];
  cost: Lovelace;
  margin: Ratio;
  pledge: Lovelace;
  vrf: DigestBlake2BVrfVerificationKey;
  metadata?: PoolMetadata;
  relays: Relay[];
  rewardAccount: RewardAccount;
}
export interface PoolMetadata {
  hash: DigestBlake2BPoolMetadata;
  url: string;
}
export interface ByAddress {
  ipv4?: string;
  ipv6?: string;
  port?: number;
}
export interface ByName {
  hostname: string;
  port?: number;
}
/**
 * A pool retirement certificate.
 */
export interface PoolRetirement {
  poolRetirement: {
    retirementEpoch: Epoch;
    poolId: PoolId;
  };
}
export interface GenesisDelegation {
  genesisDelegation: {
    delegateKeyHash: DigestBlake2BVerificationKey;
    verificationKeyHash: DigestBlake2BVerificationKey;
    vrfVerificationKeyHash: DigestBlake2BVrfVerificationKey;
  };
}
/**
 * Either `value` or `rewards` will be present, but never both.
 */
export interface MoveInstantaneousRewards {
  moveInstantaneousRewards: {
    rewards?: Rewards;
    value?: Lovelace;
    pot: RewardPot;
  };
}
export interface Rewards {
  [k: string]: LovelaceDelta;
}
export interface Withdrawals {
  [k: string]: Lovelace;
}
export interface ValidityInterval {
  invalidBefore?: Slot;
  invalidHereafter?: Slot;
}
export interface UpdateProposalBabbage {
  epoch: Epoch;
  proposal: {
    [k: string]: ProtocolParametersBabbage;
  };
}
export interface ProtocolParametersBabbage {
  minFeeCoefficient?: UInt64;
  minFeeConstant?: UInt64;
  maxBlockBodySize?: UInt64;
  maxBlockHeaderSize?: UInt64;
  maxTxSize?: UInt64;
  stakeKeyDeposit?: UInt64;
  poolDeposit?: UInt64;
  poolRetirementEpochBound?: UInt64;
  desiredNumberOfPools?: UInt64;
  poolInfluence?: Ratio;
  monetaryExpansion?: Ratio;
  treasuryExpansion?: Ratio;
  minPoolCost?: UInt64;
  coinsPerUtxoByte?: UInt64;
  maxValueSize?: UInt64;
  collateralPercentage?: UInt64;
  maxCollateralInputs?: UInt64;
  protocolVersion?: ProtocolVersion;
  costModels?: CostModels;
  prices?: Prices;
  maxExecutionUnitsPerTransaction?: ExUnits;
  maxExecutionUnitsPerBlock?: ExUnits;
}
export interface ProtocolVersion {
  major: UInt32;
  minor: UInt32;
  patch?: UInt32;
}
export interface CostModels {
  [k: string]: CostModel;
}
export interface CostModel {
  [k: string]: Int64;
}
export interface Prices {
  memory: Ratio;
  steps: Ratio;
}
export interface ExUnits {
  memory: UInt64;
  steps: UInt64;
}
export interface BootstrapWitness {
  key: VerificationKey;
  signature: Signature;
  chainCode?: ChainCode;
  addressAttributes?: AddressAttributes;
}
export interface Redeemer {
  redeemer: RedeemerData;
  executionUnits: ExUnits;
}
export interface AuxiliaryData {
  hash: DigestBlake2BAuxiliaryDataBody;
  body: AuxiliaryDataBody;
}
export interface AuxiliaryDataBody {
  blob?: Metadata;
  scripts?: Script[];
}
export interface Metadata {
  [k: string]: Metadatum;
}
export interface Int {
  int: bigint;
}
export interface String {
  string: string;
}
export interface Bytes {
  bytes: string;
}
export interface List {
  list: Metadatum[];
}
export interface Map {
  map: MetadatumMap[];
}
export interface MetadatumMap {
  k: Metadatum;
  v: Metadatum;
}
/**
 * Certificate identifying a stake pool operator.
 */
export interface OpCert {
  count?: UInt64;
  sigma?: Signature;
  kesPeriod?: UInt64;
  hotVk?: KesVerificationKey;
}
export interface CertifiedVrf {
  proof?: VrfProof;
  output?: VrfOutput;
}
export interface Alonzo {
  alonzo: BlockAlonzo;
}
export interface BlockAlonzo {
  body: TxAlonzo[];
  headerHash: DigestBlake2BBlockHeader;
  header: {
    blockHeight: BlockNo;
    slot: Slot;
    prevHash: DigestBlake2BBlockHeader;
    issuerVk: VerificationKey;
    issuerVrf: IssuerVrfVerificationKey;
    nonce?: CertifiedVrf;
    leaderValue: CertifiedVrf;
    blockSize: BlockSize;
    blockHash: DigestBlake2BBlockBody;
    opCert: OpCert;
    protocolVersion: ProtocolVersion;
    signature: IssuerSignature;
  };
}
export interface TxAlonzo {
  id: DigestBlake2BBlockBody;
  inputSource: "inputs" | "collaterals";
  body: {
    inputs: TxIn[];
    collaterals?: TxIn[];
    outputs: TxOut[];
    certificates?: Certificate[];
    withdrawals?: Withdrawals;
    fee: Lovelace;
    validityInterval: ValidityInterval;
    update?: UpdateProposalAlonzo;
    mint?: Value;
    network?: Network;
    scriptIntegrityHash?: DigestBlake2BScriptIntegrity;
    requiredExtraSignatures?: DigestBlake2BVerificationKey[];
  };
  witness: {
    signatures: {
      [k: string]: Signature;
    };
    scripts: {
      [k: string]: Script;
    };
    bootstrap: BootstrapWitness[];
    datums: {
      [k: string]: Datum;
    };
    redeemers: {
      [k: string]: Redeemer;
    };
  };
  metadata?: AuxiliaryData;
  /**
   * The raw serialized transaction, as found on-chain.
   */
  raw: string;
}
export interface UpdateProposalAlonzo {
  epoch: Epoch;
  proposal: {
    [k: string]: ProtocolParametersAlonzo;
  };
}
export interface ProtocolParametersAlonzo {
  minFeeCoefficient?: UInt64;
  minFeeConstant?: UInt64;
  maxBlockBodySize?: UInt64;
  maxBlockHeaderSize?: UInt64;
  maxTxSize?: UInt64;
  stakeKeyDeposit?: UInt64;
  poolDeposit?: UInt64;
  poolRetirementEpochBound?: UInt64;
  desiredNumberOfPools?: UInt64;
  poolInfluence?: Ratio;
  monetaryExpansion?: Ratio;
  treasuryExpansion?: Ratio;
  decentralizationParameter?: Ratio;
  minPoolCost?: UInt64;
  coinsPerUtxoWord?: UInt64;
  maxValueSize?: UInt64;
  collateralPercentage?: UInt64;
  maxCollateralInputs?: UInt64;
  extraEntropy?: Nonce;
  protocolVersion?: ProtocolVersion;
  costModels?: CostModels;
  prices?: Prices;
  maxExecutionUnitsPerTransaction?: ExUnits;
  maxExecutionUnitsPerBlock?: ExUnits;
}
export interface Mary {
  mary: BlockMary;
}
export interface BlockMary {
  body: TxMary[];
  headerHash: DigestBlake2BBlockHeader;
  header: {
    blockHeight: BlockNo;
    slot: Slot;
    prevHash: DigestBlake2BBlockHeader;
    issuerVk: VerificationKey;
    issuerVrf: IssuerVrfVerificationKey;
    nonce?: CertifiedVrf;
    leaderValue: CertifiedVrf;
    blockSize: BlockSize;
    blockHash: DigestBlake2BBlockBody;
    opCert: OpCert;
    protocolVersion: ProtocolVersion;
    signature: IssuerSignature;
  };
}
export interface TxMary {
  id: DigestBlake2BBlockBody;
  body: {
    inputs: TxIn[];
    outputs: TxOut[];
    certificates?: Certificate[];
    withdrawals?: Withdrawals;
    fee: Lovelace;
    validityInterval: ValidityInterval;
    update?: UpdateProposalShelley;
    mint?: Value;
  };
  witness: {
    signatures: {
      [k: string]: Signature;
    };
    scripts: {
      [k: string]: Script;
    };
    bootstrap: BootstrapWitness[];
  };
  metadata?: AuxiliaryData;
  /**
   * The raw serialized transaction, as found on-chain.
   */
  raw: string;
}
export interface UpdateProposalShelley {
  epoch: Epoch;
  proposal: {
    [k: string]: ProtocolParametersShelley;
  };
}
export interface ProtocolParametersShelley {
  minFeeCoefficient?: UInt64;
  minFeeConstant?: UInt64;
  maxBlockBodySize?: UInt64;
  maxBlockHeaderSize?: UInt64;
  maxTxSize?: UInt64;
  stakeKeyDeposit?: UInt64;
  poolDeposit?: UInt64;
  poolRetirementEpochBound?: UInt64;
  desiredNumberOfPools?: UInt64;
  poolInfluence?: Ratio;
  monetaryExpansion?: Ratio;
  treasuryExpansion?: Ratio;
  decentralizationParameter?: Ratio;
  minUtxoValue?: UInt64;
  minPoolCost?: UInt64;
  extraEntropy?: Nonce;
  protocolVersion?: ProtocolVersion;
}
export interface Allegra {
  allegra: BlockAllegra;
}
export interface BlockAllegra {
  body: TxAllegra[];
  headerHash: DigestBlake2BBlockHeader;
  header: {
    blockHeight: BlockNo;
    slot: Slot;
    prevHash: DigestBlake2BBlockHeader;
    issuerVk: VerificationKey;
    issuerVrf: IssuerVrfVerificationKey;
    nonce?: CertifiedVrf;
    leaderValue: CertifiedVrf;
    blockSize: BlockSize;
    blockHash: DigestBlake2BBlockBody;
    opCert: OpCert;
    protocolVersion: ProtocolVersion;
    signature: IssuerSignature;
  };
}
export interface TxAllegra {
  id: DigestBlake2BBlockBody;
  body: {
    inputs: TxIn[];
    outputs: TxOut[];
    certificates?: Certificate[];
    withdrawals?: Withdrawals;
    fee: Lovelace;
    validityInterval: ValidityInterval;
    update?: UpdateProposalShelley;
  };
  witness: {
    signatures: {
      [k: string]: Signature;
    };
    scripts: {
      [k: string]: Script;
    };
    bootstrap: BootstrapWitness[];
  };
  metadata?: AuxiliaryData;
  /**
   * The raw serialized transaction, as found on-chain.
   */
  raw: string;
}
export interface Shelley {
  shelley: BlockShelley;
}
export interface BlockShelley {
  body: TxShelley[];
  headerHash: DigestBlake2BBlockHeader;
  header: {
    blockHeight: BlockNo;
    slot: Slot;
    prevHash: DigestBlake2BBlockHeader;
    issuerVk: VerificationKey;
    issuerVrf: IssuerVrfVerificationKey;
    nonce?: CertifiedVrf;
    leaderValue: CertifiedVrf;
    blockSize: BlockSize;
    blockHash: DigestBlake2BBlockBody;
    opCert: OpCert;
    protocolVersion: ProtocolVersion;
    signature: IssuerSignature;
  };
}
export interface TxShelley {
  id: DigestBlake2BBlockBody;
  body: {
    inputs: TxIn[];
    outputs: TxOut[];
    certificates?: Certificate[];
    withdrawals?: Withdrawals;
    fee: Lovelace;
    timeToLive: Slot;
    update?: UpdateProposalShelley;
  };
  witness: {
    signatures?: {
      [k: string]: Signature;
    };
    scripts?: {
      [k: string]: Script;
    };
    bootstrap?: BootstrapWitness[];
  };
  metadata?: AuxiliaryData;
  /**
   * The raw serialized transaction, as found on-chain.
   */
  raw: string;
}
export interface Byron {
  byron: BlockByron;
}
export interface StandardBlock {
  hash: DigestBlake2BBlockHeader;
  header: {
    blockHeight: BlockNo;
    genesisKey: GenesisVerificationKey;
    prevHash: DigestBlake2BBlockHeader;
    proof: BlockProof;
    protocolMagicId: ProtocolMagicId;
    protocolVersion: ProtocolVersion;
    signature: BlockSignature;
    slot: Slot;
    softwareVersion: SoftwareVersion;
  };
  body: {
    txPayload: TxByron[];
    dlgPayload: DlgCertificate[];
    updatePayload: {
      proposal?: UpdateProposalByron;
      votes: Vote[];
    };
  };
}
export interface BlockProof {
  utxo: {
    number: UInt32;
    root: DigestBlake2BMerkleRoot;
    witnessesHash: DigestBlake2BBlockByronBodyTxPayloadWitness;
  };
  delegation: DigestBlake2BBlockByronBodyDlgPayload;
  update: DigestBlake2BBlockByronBodyUpdatePayload;
}
export interface BlockSignature {
  dlgCertificate: DlgCertificate;
  signature: IssuerSignature;
}
/**
 * A (Byron) delegation certificate.
 */
export interface DlgCertificate {
  epoch: Epoch;
  issuerVk: GenesisVerificationKey;
  delegateVk: GenesisVerificationKey;
  signature: IssuerSignature;
}
export interface SoftwareVersion {
  appName: string;
  number: UInt32;
}
export interface TxByron {
  id: TxId;
  body: {
    inputs: TxIn[];
    outputs: TxOut[];
  };
  witness: TxWitness[];
  /**
   * The raw serialized transaction, as found on-chain.
   */
  raw: string;
}
export interface WitnessVk {
  witnessVk: {
    key: DigestBlake2BVerificationKey;
    signature: Signature;
  };
}
export interface RedeemWitness {
  redeemWitness: {
    key: VerificationKey;
    signature: Signature;
  };
}
export interface UpdateProposalByron {
  body: {
    protocolVersion: ProtocolVersion;
    softwareVersion: SoftwareVersion;
    metadata: {
      [k: string]: string;
    };
    parametersUpdate: ProtocolParametersByron;
  };
  issuer: IssuerVrfVerificationKey;
  signature: IssuerSignature;
}
export interface ProtocolParametersByron {
  heavyDlgThreshold?: Ratio;
  maxBlockSize?: UInt64;
  maxHeaderSize?: UInt64;
  maxProposalSize?: UInt64;
  maxTxSize?: UInt64;
  mpcThreshold?: Ratio;
  scriptVersion?: UInt64;
  slotDuration?: UInt64;
  unlockStakeEpoch?: UInt64;
  updateProposalThreshold?: Ratio;
  updateProposalTimeToLive?: UInt64;
  updateVoteThreshold?: Ratio;
  txFeePolicy?: TxFeePolicy;
  softforkRule?: SoftForkRule;
}
export interface TxFeePolicy {
  coefficient: Ratio;
  constant: number;
}
export interface SoftForkRule {
  initThreshold: Ratio;
  minThreshold: Ratio;
  decrementThreshold: Ratio;
}
export interface Vote {
  voterVk: VerificationKey;
  proposalId: DigestBlake2BVerificationKey;
  signature: Signature;
}
export interface EpochBoundaryBlock {
  hash: DigestBlake2BBlockHeader;
  header: {
    blockHeight: BlockNo;
    epoch: Epoch;
    prevHash: DigestBlake2BBlockHeader;
  };
}
export interface Tip {
  slot: Slot;
  hash: DigestBlake2BBlockHeader;
  blockNo: BlockNo;
}
export interface RollBackward {
  RollBackward: {
    point: PointOrOrigin;
    tip: TipOrOrigin;
  };
}
/**
 * A point on the chain, identified by a slot and a block header hash.
 */
export interface Point {
  slot: Slot;
  hash: DigestBlake2BBlockHeader;
}
export interface IntersectionFound {
  IntersectionFound: {
    point: PointOrOrigin;
    tip: TipOrOrigin;
  };
}
export interface IntersectionNotFound {
  IntersectionNotFound: {
    tip: TipOrOrigin;
  };
}
export interface SubmitSuccess {
  SubmitSuccess: {
    txId: TxId;
  };
}
export interface SubmitFail {
  SubmitFail: SubmitTxError;
}
/**
 * An era mismatch between a client request and the era the ledger is in. This may occur when running queries on a syncing node and/or when the node is crossing an era.
 */
export interface EraMismatch {
  eraMismatch: {
    queryEra: Era;
    ledgerEra: Era;
  };
}
export interface InvalidWitnesses {
  invalidWitnesses: VerificationKey[];
}
export interface MissingVkWitnesses {
  missingVkWitnesses: DigestBlake2BVerificationKey[];
}
export interface MissingScriptWitnesses {
  missingScriptWitnesses: DigestBlake2BScript[];
}
export interface ScriptWitnessNotValidating {
  scriptWitnessNotValidating: DigestBlake2BScript[];
}
export interface InsufficientGenesisSignatures {
  insufficientGenesisSignatures: DigestBlake2BVerificationKey[];
}
export interface MissingTxMetadata {
  missingTxMetadata: DigestBlake2BAuxiliaryDataBody;
}
export interface MissingTxMetadataHash {
  missingTxMetadataHash: DigestBlake2BAuxiliaryDataBody;
}
export interface TxMetadataHashMismatch {
  txMetadataHashMismatch: {
    includedHash: DigestBlake2BAuxiliaryDataBody;
    expectedHash: DigestBlake2BAuxiliaryDataBody;
  };
}
export interface BadInputs {
  badInputs: TxIn[];
}
/**
 * Only in Shelley. Replaced with 'outsideOfValidityInterval' since Allegra.
 */
export interface ExpiredUtxo {
  expiredUtxo: {
    currentSlot: Slot;
    transactionTimeToLive: Slot;
  };
}
/**
 * Since Allegra. Replaces 'expiredUtxo'.
 */
export interface OutsideOfValidityInterval {
  outsideOfValidityInterval: {
    currentSlot: Slot;
    interval: ValidityInterval;
  };
}
export interface TxTooLarge {
  txTooLarge: {
    maximumSize: Int64;
    actualSize: Int64;
  };
}
export interface MissingAtLeastOneInputUtxo {
  missingAtLeastOneInputUtxo: null;
}
export interface InvalidMetadata {
  invalidMetadata: null;
}
export interface FeeTooSmall {
  feeTooSmall: {
    requiredFee: Lovelace;
    actualFee: Lovelace;
  };
}
/**
 * Returns 'Value' since Mary, and 'LovelaceDelta' before.
 */
export interface ValueNotConserved {
  valueNotConserved: {
    consumed: LovelaceDelta | Value;
    produced: LovelaceDelta | Value;
  };
}
export interface NetworkMismatch {
  networkMismatch: {
    expectedNetwork: Network;
    invalidEntities: InvalidEntity[];
  };
}
export interface OutputTooSmall {
  outputTooSmall: (
    | TxOut
    | {
        output: TxOut;
        minimumRequiredValue: Lovelace;
      }
  )[];
}
/**
 * Only since Mary.
 */
export interface TooManyAssetsInOutput {
  tooManyAssetsInOutput: TxOut[];
}
export interface AddressAttributesTooLarge {
  addressAttributesTooLarge: Address[];
}
/**
 * Only since Mary.
 */
export interface TriesToForgeAda {
  triesToForgeAda: null;
}
export interface DelegateNotRegistered {
  delegateNotRegistered: PoolId;
}
export interface UnknownOrIncompleteWithdrawals {
  unknownOrIncompleteWithdrawals: Withdrawals;
}
export interface StakePoolNotRegistered {
  stakePoolNotRegistered: PoolId;
}
export interface WrongRetirementEpoch {
  wrongRetirementEpoch: {
    currentEpoch: Epoch;
    requestedEpoch: Epoch;
    firstUnreachableEpoch: Epoch;
  };
}
export interface WrongPoolCertificate {
  wrongPoolCertificate: UInt8;
}
export interface StakeKeyAlreadyRegistered {
  stakeKeyAlreadyRegistered: DigestBlake2BVerificationKey;
}
export interface PoolCostTooSmall {
  poolCostTooSmall: {
    minimumCost: Lovelace;
  };
}
export interface PoolMetadataHashTooBig {
  poolMetadataHashTooBig: {
    poolId: PoolId;
    measuredSize: Int64;
  };
}
export interface StakeKeyNotRegistered {
  stakeKeyNotRegistered: DigestBlake2BVerificationKey;
}
export interface RewardAccountNotExisting {
  rewardAccountNotExisting: null;
}
export interface RewardAccountNotEmpty {
  rewardAccountNotEmpty: {
    balance: Lovelace;
  };
}
export interface WrongCertificateType {
  wrongCertificateType: null;
}
export interface UnknownGenesisKey {
  unknownGenesisKey: DigestBlake2BVerificationKey;
}
export interface AlreadyDelegating {
  alreadyDelegating: DigestBlake2BVerificationKey;
}
export interface InsufficientFundsForMir {
  insufficientFundsForMir: {
    rewardSource: RewardPot;
    sourceSize: Lovelace;
    requestedAmount: Lovelace;
  };
}
export interface TooLateForMir {
  tooLateForMir: {
    currentSlot: Slot;
    lastAllowedSlot: Slot;
  };
}
export interface MirTransferNotCurrentlyAllowed {
  mirTransferNotCurrentlyAllowed: null;
}
export interface MirNegativeTransferNotCurrentlyAllowed {
  mirNegativeTransferNotCurrentlyAllowed: null;
}
export interface MirProducesNegativeUpdate {
  mirProducesNegativeUpdate: null;
}
export interface DuplicateGenesisVrf {
  duplicateGenesisVrf: DigestBlake2BVrfVerificationKey;
}
export interface NonGenesisVoters {
  nonGenesisVoters: {
    currentlyVoting: DigestBlake2BVerificationKey[];
    shouldBeVoting: DigestBlake2BVerificationKey[];
  };
}
export interface UpdateWrongEpoch {
  updateWrongEpoch: {
    currentEpoch: Epoch;
    requestedEpoch: Epoch;
    votingPeriod: VotingPeriod;
  };
}
export interface ProtocolVersionCannotFollow {
  protocolVersionCannotFollow: ProtocolVersion;
}
export interface MissingRequiredRedeemers {
  missingRequiredRedeemers: {
    missing: {
      [k: string]: ScriptPurpose;
    }[];
  };
}
export interface Spend {
  spend: TxIn;
}
export interface Mint {
  mint: DigestBlake2BScript;
}
export interface Certificate1 {
  certificate: Certificate;
}
export interface Withdrawal {
  withdrawal: RewardAccount;
}
export interface MissingRequiredDatums {
  missingRequiredDatums: {
    provided?: DigestBlake2BDatum[];
    missing: DigestBlake2BDatum[];
  };
}
export interface UnspendableDatums {
  unspendableDatums: {
    nonSpendable: DigestBlake2BDatum[];
    acceptable: DigestBlake2BDatum[];
  };
}
export interface ExtraDataMismatch {
  extraDataMismatch: {
    provided?: DigestBlake2BScriptIntegrity;
    inferredFromParameters?: DigestBlake2BScriptIntegrity;
  };
}
export interface MissingRequiredSignatures {
  missingRequiredSignatures: DigestBlake2BVerificationKey[];
}
export interface UnspendableScriptInputs {
  unspendableScriptInputs: TxIn[];
}
export interface ExtraRedeemers {
  extraRedeemers: string[];
}
export interface MissingDatumHashesForInputs {
  missingDatumHashesForInputs: TxIn[];
}
/**
 * Only since Alonzo.
 */
export interface MissingCollateralInputs {
  missingCollateralInputs: null;
}
export interface CollateralTooSmall {
  collateralTooSmall: {
    requiredCollateral: Lovelace;
    actualCollateral: Lovelace;
  };
}
export interface CollateralIsScript {
  collateralIsScript: Utxo;
}
export interface CollateralHasNonAdaAssets {
  collateralHasNonAdaAssets: Value;
}
export interface TooManyCollateralInputs {
  tooManyCollateralInputs: {
    maximumCollateralInputs: UInt64;
    actualCollateralInputs: UInt64;
  };
}
export interface ExecutionUnitsTooLarge {
  executionUnitsTooLarge: {
    maximumExecutionUnits: ExUnits;
    actualExecutionUnits: ExUnits;
  };
}
export interface OutsideForecast {
  outsideForecast: Slot;
}
/**
 * Only since Alonzo.
 */
export interface ValidationTagMismatch {
  validationTagMismatch: null;
}
export interface CollectErrors {
  collectErrors: (NoRedeemer | NoWitness | NoCostModel | BadTranslation)[];
}
export interface NoRedeemer {
  noRedeemer: ScriptPurpose;
}
export interface NoWitness {
  noWitness: DigestBlake2BScript;
}
export interface NoCostModel {
  noCostModel: Language;
}
export interface BadTranslation {
  /**
   * An (hopefully) informative error about the transaction execution failure.
   */
  badTranslation: string;
}
export interface ExtraScriptWitnesses {
  extraScriptWitnesses: DigestBlake2BScript[];
}
export interface MirNegativeTransfer {
  mirNegativeTransfer: {
    rewardSource: RewardPot;
    attemptedTransfer: Lovelace;
  };
}
export interface TotalCollateralMismatch {
  totalCollateralMismatch: {
    computedFromDelta: Lovelace;
    declaredInField: Lovelace;
  };
}
export interface MalformedReferenceScripts {
  malformedReferenceScripts: DigestBlake2BScript[];
}
export interface MalformedScriptWitnesses {
  malformedScriptWitnesses: DigestBlake2BScript[];
}
export interface EvaluationResult {
  EvaluationResult: {
    [k: string]: ExUnits;
  };
}
export interface EvaluationFailure {
  EvaluationFailure:
    | EvaluationFailureScriptFailures
    | EvaluationFailureIncompatibleEra
    | EvaluationFailureAdditionalUtxoOverlap
    | EvaluationFailureNotEnoughSynced
    | EvaluationFailureCannotCreateEvaluationContext;
}
export interface EvaluationFailureScriptFailures {
  ScriptFailures: {
    [k: string]: ScriptFailure;
  };
}
/**
 * Missing scripts required for validating script inputs.
 */
export interface MissingRequiredScripts {
  missingRequiredScripts: {
    missing: RedeemerPointer[];
    resolved: {
      [k: string]: DigestBlake2BScript;
    };
  };
}
/**
 * Plutus interpreter error. Returns additional traces produced by the validator.
 */
export interface ValidatorFailed {
  validatorFailed: {
    error: string;
    traces: string[];
  };
}
/**
 * Non-existing input referenced by a redeemer pointer.
 */
export interface UnknownInputReferencedByRedeemer {
  unknownInputReferencedByRedeemer: TxIn;
}
/**
 * Input not locked by a Plutus referenced by a redeemer pointer.
 */
export interface NonScriptInputReferencedByRedeemer {
  nonScriptInputReferencedByRedeemer: TxIn;
}
/**
 * Invalid execution budget set for a redeemer. In principle, cannot happen in the context of Ogmios.
 */
export interface IllFormedExecutionBudget {
  illFormedExecutionBudget?: ExUnits;
}
/**
 * Input locked by a script which language has no cost model in current protocol parameters. In principle, cannot happen in the context of Ogmios.
 */
export interface NoCostModelForLanguage {
  noCostModelForLanguage: Language;
}
/**
 * Returned when trying to evaluate execution units of a pre-Alonzo transaction. Note that this isn't possible with Ogmios because transactions are always de-serialized as Alonzo transactions.
 */
export interface EvaluationFailureIncompatibleEra {
  /**
   * The era in which the transaction has been identified.
   */
  IncompatibleEra: "Byron" | "Shelley" | "Allegra" | "Mary";
}
/**
 * Happens when providing an additional UTXO set which overlaps with the UTXO on-chain.
 */
export interface EvaluationFailureAdditionalUtxoOverlap {
  AdditionalUtxoOverlap: TxIn[];
}
/**
 * Happens when attempting to evaluate execution units on a node that isn't enough synchronized.
 */
export interface EvaluationFailureNotEnoughSynced {
  NotEnoughSynced: {
    minimumRequiredEra: Era;
    currentNodeEra: Era;
  };
}
/**
 * Happens when the ledger fails to create an evaluation context from a given transaction. This is mostly due to the transaction being malformed (e.g. wrong redeemer pointer, missing UTxO).
 */
export interface EvaluationFailureCannotCreateEvaluationContext {
  CannotCreateEvaluationContext: {
    reason: string;
  };
}
export interface AcquireSuccess {
  AcquireSuccess: {
    point: PointOrOrigin;
  };
}
export interface AcquireFailure {
  AcquireFailure: {
    failure: AcquireFailureDetails;
  };
}
export interface AwaitAcquired {
  AwaitAcquired: {
    slot: Slot;
  };
}
export interface MempoolSizeAndCapacity {
  capacity: UInt32;
  currentSize: UInt32;
  numberOfTxs: UInt32;
}
export interface GetNonMyopicMemberRewards {
  nonMyopicMemberRewards: Lovelace[] | StakeCredential[];
}
export interface GetDelegationsAndRewards {
  delegationsAndRewards: StakeCredential[];
}
export interface GetUtxoByAddress {
  utxo: Address[];
}
export interface GetUtxoByTxIn {
  utxo: TxIn[];
}
export interface GetGenesisConfig {
  genesisConfig: "byron" | "shelley" | "alonzo";
}
export interface GetPoolParameters {
  poolParameters: (PoolId | string)[];
}
/**
 * An era bound which captures the time, slot and epoch at which the era start. The time is relative to the start time of the network.
 */
export interface Bound {
  time: RelativeTime;
  slot: Slot;
  epoch: Epoch;
}
/**
 * Summary of the confirmed parts of the ledger.
 */
export interface EraSummary {
  start: Bound;
  end: Bound | null;
  parameters: EraParameters;
}
/**
 * Parameters that can vary across hard forks.
 */
export interface EraParameters {
  epochLength: Epoch;
  slotLength: SlotLength;
  safeZone: SafeZone | null;
}
/**
 * Rewards that can be expected assuming a pool is fully saturated. Such rewards are said non-myopic, in opposition to short-sighted rewards looking at immediate benefits. Keys of the map can be either Lovelace amounts or account credentials depending on the query.
 */
export interface NonMyopicMemberRewards {
  [k: string]: {
    [k: string]: number;
  };
}
export interface DelegationsAndRewardsByAccounts {
  [k: string]: DelegationsAndRewards;
}
export interface DelegationsAndRewards {
  delegate?: PoolId;
  rewards?: Lovelace;
}
export interface ProposedProtocolParametersShelley {
  [k: string]: ProtocolParametersShelley;
}
export interface ProposedProtocolParametersAlonzo {
  [k: string]: ProtocolParametersAlonzo;
}
export interface ProposedProtocolParametersBabbage {
  [k: string]: ProtocolParametersBabbage;
}
/**
 * Distribution of stake across registered stake pools. Each key in the map corresponds to a pool id.
 */
export interface PoolDistribution {
  [k: string]: {
    stake: Ratio;
    vrf: DigestBlake2BVrfVerificationKey;
  };
}
/**
 * A Byron genesis configuration, with information used to bootstrap the era. Some parameters are also updatable across the era.
 */
export interface GenesisByron {
  genesisKeyHashes: DigestBlake2BVerificationKey[];
  genesisDelegations: {
    [k: string]: DlgCertificate;
  };
  systemStart: UtcTime;
  initialFunds: {
    [k: string]: Lovelace;
  };
  initialCoinOffering: {
    [k: string]: Lovelace;
  };
  securityParameter: UInt64;
  networkMagic: NetworkMagic;
  protocolParameters: ProtocolParametersByron;
}
/**
 * A Shelley genesis configuration, with information used to bootstrap the era. Some parameters are also updatable across the era.
 */
export interface GenesisShelley {
  systemStart: UtcTime;
  networkMagic: NetworkMagic;
  network: Network;
  activeSlotsCoefficient: Ratio;
  securityParameter: UInt64;
  epochLength: Epoch;
  slotsPerKesPeriod: UInt64;
  maxKesEvolutions: UInt64;
  slotLength: SlotLength;
  updateQuorum: UInt64;
  maxLovelaceSupply: UInt64;
  protocolParameters: ProtocolParametersShelley;
  initialDelegates: InitialDelegates;
  initialFunds: InitialFunds;
  initialPools: GenesisPools;
}
export interface InitialDelegates {
  [k: string]: GenesisDelegate;
}
/**
 * A Genesis delegate, in charge of Cardano's governance.
 */
export interface GenesisDelegate {
  delegate: DigestBlake2BVerificationKey;
  vrf: DigestBlake2BVrfVerificationKey;
}
export interface InitialFunds {
  [k: string]: Lovelace;
}
/**
 * A Genesis stake pools configuration; primarily used for bootstrapping test networks.
 */
export interface GenesisPools {
  pools: {
    [k: string]: PoolParameters;
  };
  delegators: {
    [k: string]: PoolId;
  };
}
/**
 * An Alonzo genesis configuration, with information used to bootstrap the era. Some parameters are also updatable across the era.
 */
export interface GenesisAlonzo {
  coinsPerUtxoWord: UInt64;
  collateralPercentage: UInt64;
  costModels: CostModels;
  maxCollateralInputs: UInt64;
  maxExecutionUnitsPerBlock: ExUnits;
  maxExecutionUnitsPerTransaction: ExUnits;
  maxValueSize: UInt64;
  prices: Prices;
}
/**
 * Details about how rewards are calculated for the ongoing epoch.
 */
export interface RewardsProvenance {
  epochLength: Epoch;
  decentralizationParameter: Ratio;
  maxLovelaceSupply: Lovelace;
  /**
   * Number of blocks minted by each pool.
   */
  mintedBlocks: {
    [k: string]: UInt64;
  };
  /**
   * The total number of blocks minted during the given epoch.
   */
  totalMintedBlocks: number;
  /**
   * The number of blocks expected to be produced during the given epoch.
   */
  totalExpectedBlocks: number;
  /**
   * A number of lovelace, possibly large when summed up.
   */
  incentive: bigint;
  /**
   * A number of lovelace, possibly large when summed up.
   */
  rewardsGap: bigint;
  /**
   * A number of lovelace, possibly large when summed up.
   */
  availableRewards: bigint;
  /**
   * A number of lovelace, possibly large when summed up.
   */
  totalRewards: bigint;
  /**
   * A number of lovelace, possibly large when summed up.
   */
  treasuryTax: bigint;
  /**
   * A number of lovelace, possibly large when summed up.
   */
  activeStake: bigint;
  pools: {
    [k: string]: IndividualPoolRewardsProvenance;
  };
}
export interface IndividualPoolRewardsProvenance {
  /**
   * The number of blocks the pool produced.
   */
  totalMintedBlocks: number;
  /**
   * A ratio of two integers, to express exact fractions.
   */
  totalStakeShare: string;
  /**
   * A ratio of two integers, to express exact fractions.
   */
  activeStakeShare: string;
  /**
   * A number of lovelace, possibly large when summed up.
   */
  ownerStake: bigint;
  parameters: PoolParameters;
  /**
   * A ratio of two integers, to express exact fractions.
   */
  pledgeRatio: string;
  /**
   * A number of lovelace, possibly large when summed up.
   */
  maxRewards: bigint;
  /**
   * A ratio of two integers, to express exact fractions.
   */
  apparentPerformance: string;
  /**
   * A number of lovelace, possibly large when summed up.
   */
  totalRewards: bigint;
  /**
   * A number of lovelace, possibly large when summed up.
   */
  leaderRewards: bigint;
}
/**
 * Details about how rewards are calculated for the ongoing epoch.
 */
export interface RewardsProvenance1 {
  /**
   * Desired number of stake pools.
   */
  desiredNumberOfPools: number;
  /**
   * Influence of the pool owner's pledge on rewards, as a ratio of two integers.
   */
  poolInfluence: string;
  /**
   * Total rewards available for the given epoch.
   */
  totalRewards: bigint;
  /**
   * The total amount of staked Lovelace during this epoch.
   */
  activeStake: bigint;
  pools: {
    [k: string]: RewardInfoPool;
  };
}
export interface RewardInfoPool {
  stake: Lovelace;
  /**
   * A number of lovelace, possibly large when summed up.
   */
  ownerStake: bigint;
  /**
   * Number of blocks produced divided by expected number of blocks (based on stake and epoch progress). Can be larger than 1.0 for pools that get lucky.
   */
  approximatePerformance: number;
  /**
   * Some of the pool parameters relevant for the reward calculation.
   */
  poolParameters: {
    cost: Lovelace;
    margin: Ratio;
    pledge: Lovelace;
  };
}
export interface PoolsRanking {
  [k: string]: {
    score: number;
    estimatedHitRate: number;
  };
}
