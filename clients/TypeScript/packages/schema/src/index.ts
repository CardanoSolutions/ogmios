/* tslint:disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

/**
 * A Cardano Block, which can take different forms depending on the era.
 */
export type Block = Byron | Shelley | Allegra | Mary | Alonzo;
/**
 * A block in the Byron era. Most blocks are stanard blocks, but once at the beginning of each era is an additional epoch boundary block (a.k.a. EBB)
 */
export type BlockByron = StandardBlock | EpochBoundaryBlock;
/**
 * A base16-encoded digest.
 */
export type Hash16 = string;
/**
 * A block number, the i-th block to be minted is number i.
 */
export type BlockNo = number;
export type UInt32 = number;
export type ProtocolMagicId = number;
/**
 * An epoch number.
 */
export type Epoch = number;
/**
 * A base64-encoded digest.
 */
export type Hash64 = string;
/**
 * An absolute slot number.
 */
export type Slot = number;
/**
 * A Cardano address (either legacy format or new format).
 */
export type Address = string;
export type Lovelace = number;
/**
 * A number of asset, can be negative went burning assets.
 */
export type AssetQuantity = bigint;
export type Null = null;
export type TxWitness = WitnessVk | RedeemWitness;
export type NullableRatio = Ratio | Null;
/**
 * A ratio of two integers, to express exact fractions.
 */
export type Ratio = string;
export type NullableUInt64 = UInt64 | Null;
export type UInt64 = number;
export type Certificate =
  | StakeDelegation
  | StakeKeyRegistration
  | StakeKeyDeregistration
  | PoolRegistration
  | PoolRetirement
  | GenesisDelegation
  | MoveInstantaneousRewards;
export type PoolId = string;
export type Relay = ByAddress | ByName;
/**
 * A reward account, also known as 'stake address'.
 */
export type RewardAccount = string;
/**
 * An amount, possibly negative, in Lovelace (1e6 Lovelace = 1 Ada).
 */
export type LovelaceDelta = number;
/**
 * Source of rewards as defined by the protocol parameters.
 */
export type RewardPot = "reserves" | "treasury";
export type UpdateShelley = Null | UpdateProposalShelley;
export type Nonce = Neutral | Hash16;
export type Neutral = "neutral";
export type Signature = string;
export type Script = Native | Plutus;
/**
 * A phase-1 monetary script. Timelocks constraints are only supported since Allegra.
 */
export type ScriptNative = Hash16 | Any | All | NOf | ExpiresAt | StartsAt;
/**
 * A phase-2 Plutus script; or said differently, a serialized Plutus-core program.
 */
export type ScriptPlutus = string;
export type Metadatum = Int | String | Bytes | List | Map;
/**
 * The size of the block in bytes.
 */
export type BlockSize = number;
export type UpdateAlonzo = Null | UpdateProposalAlonzo;
export type Int64 = number;
/**
 * A network target, as defined since the Shelley era.
 */
export type Network = "mainnet" | "testnet";
export type TipOrOrigin = Tip | Origin;
/**
 * The origin of the blockchain. This point is special in the sense that it doesn't point to any existing slots, but is preceding any existing other point.
 */
export type Origin = "origin";
export type PointOrOrigin = Point | Origin;
export type SubmitSuccess = "SubmitSuccess";
export type Era = "Byron" | "Shelley" | "Allegra" | "Mary" | "Alonzo";
export type MissingAtLeastOneInputUtxo = "missingAtLeastOneInputUtxo";
export type InvalidMetadata = "invalidMetadata";
export type InvalidEntity =
  | {
      type: "address";
      entity: Address;
    }
  | {
      type: "poolRegistration";
      entity: PoolId;
    }
  | {
      type: "rewardAccount";
      entity: RewardAccount;
    };
/**
 * Only since Mary.
 */
export type TriesToForgeAda = "triesToForgeAda";
export type UInt8 = number;
export type RewardAccountNotExisting = "rewardAccountNotExisting";
export type WrongCertificateType = "wrongCertificateType";
export type MirTransferNotCurrentlyAllowed = "mirTransferNotCurrentlyAllowed";
export type MirNegativeTransferNotCurrentlyAllowed = "mirNegativeTransferNotCurrentlyAllowed";
export type MirProducesNegativeUpdate = "mirProducesNegativeUpdate";
export type VotingPeriod = "voteForThisEpoch" | "voteForNextEpoch";
export type ScriptPurpose = Spend | Mint | Certificate1 | Withdrawal;
export type MissingCollateralInputs = "missingCollateralInputs";
export type Utxo = [TxIn, TxOut][];
export type ValidationTagMismatch = "validationTagMismatch";
export type SubmitTxError = (
  | InvalidWitnesses
  | MissingVkWitnesses
  | MissingScriptWitnesses
  | ScriptWitnessNotValidating
  | InsufficientGenesisSignatures
  | MissingTxMetadata
  | MissingTxMetadataHash
  | TxMetadataHashMismatch
  | BadInputs
  | ExpiredUtxo
  | OutsideOfValidityInterval
  | TxTooLarge
  | MissingAtLeastOneInputUtxo
  | InvalidMetadata
  | FeeTooSmall
  | ValueNotConserved
  | NetworkMismatch
  | OutputTooSmall
  | TooManyAssetsInOutput
  | AddressAttributesTooLarge
  | TriesToForgeAda
  | DelegateNotRegistered
  | UnknownOrIncompleteWithdrawals
  | StakePoolNotRegistered
  | WrongRetirementEpoch
  | WrongPoolCertificate
  | StakeKeyAlreadyRegistered
  | PoolCostTooSmall
  | PoolMetadataHashTooBig
  | StakeKeyNotRegistered
  | RewardAccountNotExisting
  | RewardAccountNotEmpty
  | WrongCertificateType
  | UnknownGenesisKey
  | AlreadyDelegating
  | InsufficientFundsForMir
  | TooLateForMir
  | MirTransferNotCurrentlyAllowed
  | MirNegativeTransferNotCurrentlyAllowed
  | MirProducesNegativeUpdate
  | DuplicateGenesisVrf
  | NonGenesisVoters
  | UpdateWrongEpoch
  | ProtocolVersionCannotFollow
  | MissingRequiredRedeemers
  | MissingRequiredDatums
  | UnspendableDatums
  | ExtraDataMismatch
  | MissingRequiredSignatures
  | UnspendableScriptInputs
  | ExtraRedeemers
  | MissingDatumHashesForInputs
  | MissingCollateralInputs
  | CollateralTooSmall
  | CollateralIsScript
  | CollateralHasNonAdaAssets
  | TooManyCollateralInputs
  | ExecutionUnitsTooLarge
  | OutsideForecast
  | ValidationTagMismatch
  | CollectErrors
)[];
export type AcquireFailureDetails = "pointTooOld" | "pointNotOnChain";
export type GetEraStart = "eraStart";
export type GetLedgerTip = "ledgerTip";
export type GetCurrentEpoch = "currentEpoch";
export type Lovelaces = Lovelace[];
export type Credentials = Hash16[];
export type GetCurrentProtocolParameters = "currentProtocolParameters";
export type GetProposedProtocolParameters = "proposedProtocolParameters";
export type GetStakeDistribution = "stakeDistribution";
export type GetUtxo = "utxo";
export type GetGenesisConfig = "genesisConfig";
export type GetRewardsProvenance = "rewardsProvenance";
export type GetPoolsRanking = "poolsRanking";
export type GetPoolIds = "poolIds";
/**
 * A time in seconds relative to the system start.
 */
export type RelativeTime = string;
/**
 * The requested query is not available in the current node era. It could be that the node is not fully synced.
 */
export type QueryUnavailableInCurrentEra = "QueryUnavailableInCurrentEra";
export type UtcTime = string;
/**
 * A magic number for telling networks apart. (e.g. 764824073)
 */
export type NetworkMagic = number;

export interface Ogmios {
  /**
   * Request next block from the current cardano-node's cursor.
   */
  RequestNext: {
    type: "jsonwsp/request";
    version: "1.0";
    servicename: "ogmios";
    methodname: "RequestNext";
    args?: {};
    /**
     * An arbitrary JSON value that will be mirrored back in the response.
     */
    mirror?: {
      [k: string]: unknown;
    };
  };
  /**
   * Request next block from the current cardano-node's cursor.
   */
  RequestNextResponse: {
    type: "jsonwsp/response";
    version: "1.0";
    servicename: "ogmios";
    methodname: "RequestNext";
    result: RollForward | RollBackward;
    /**
     * Any value that was set by a client request in the 'mirror' field.
     */
    reflection?: {
      [k: string]: unknown;
    };
  };
  /**
   * Ask cardano-node to find an intersection between its local chain and the given points.
   */
  FindIntersect: {
    type: "jsonwsp/request";
    version: "1.0";
    servicename: "ogmios";
    methodname: "FindIntersect";
    args?: {
      points?: PointOrOrigin[];
    };
    /**
     * An arbitrary JSON value that will be mirrored back in the response.
     */
    mirror?: {
      [k: string]: unknown;
    };
  };
  FindIntersectResponse: {
    type: "jsonwsp/response";
    version: "1.0";
    servicename: "ogmios";
    methodname: "FindIntersect";
    /**
     * Intersection found if any, alongside the cardano-node's current tip.
     */
    result: IntersectionFound | IntersectionNotFound;
    /**
     * Any value that was set by a client request in the 'mirror' field.
     */
    reflection?: {
      [k: string]: unknown;
    };
  };
  /**
   * Submit a signed and serialized Utxo transaction to the network.
   */
  SubmitTx: {
    type: "jsonwsp/request";
    version: "1.0";
    servicename: "ogmios";
    methodname: "SubmitTx";
    args?: {
      /**
       * CBOR-serialized signed transaction, in base64
       */
      bytes: string;
    };
    /**
     * An arbitrary JSON value that will be mirrored back in the response.
     */
    mirror?: {
      [k: string]: unknown;
    };
  };
  SubmitTxResponse: {
    type: "jsonwsp/response";
    version: "1.0";
    servicename: "ogmios";
    methodname: "SubmitTx";
    result: SubmitSuccess | SubmitFail;
    /**
     * Any value that was set by a client request in the 'mirror' field.
     */
    reflection?: {
      [k: string]: unknown;
    };
  };
  /**
   * Acquire a point on chain from which run queries.
   */
  Acquire: {
    type: "jsonwsp/request";
    version: "1.0";
    servicename: "ogmios";
    methodname: "Acquire";
    args?: {
      point: PointOrOrigin;
    };
    /**
     * An arbitrary JSON value that will be mirrored back in the response.
     */
    mirror?: {
      [k: string]: unknown;
    };
  };
  /**
   * Response to an 'Acquire' request.
   */
  AcquireResponse: {
    type: "jsonwsp/response";
    version: "1.0";
    servicename: "ogmios";
    methodname: "Acquire";
    result: AcquireSuccess | AcquireFailure;
    /**
     * Any value that was set by a client request in the 'mirror' field.
     */
    reflection?: {
      [k: string]: unknown;
    };
  };
  /**
   * Release a point on chain previously acquired.
   */
  Release: {
    type: "jsonwsp/request";
    version: "1.0";
    servicename: "ogmios";
    methodname: "Release";
    args?: {};
    /**
     * An arbitrary JSON value that will be mirrored back in the response.
     */
    mirror?: {
      [k: string]: unknown;
    };
  };
  /**
   * Response to a 'Release' request.
   */
  ReleaseResponse: {
    type: "jsonwsp/response";
    version: "1.0";
    servicename: "ogmios";
    methodname: "Release";
    result: "Released";
    /**
     * Any value that was set by a client request in the 'mirror' field.
     */
    reflection?: {
      [k: string]: unknown;
    };
  };
  /**
   * Query the current ledger tip.
   */
  Query: {
    type: "jsonwsp/request";
    version: "1.0";
    servicename: "ogmios";
    methodname: "Query";
    args?: {
      query:
        | GetEraStart
        | GetLedgerTip
        | GetCurrentEpoch
        | GetNonMyopicMemberRewards
        | GetDelegationsAndRewards
        | GetCurrentProtocolParameters
        | GetProposedProtocolParameters
        | GetStakeDistribution
        | GetUtxo
        | GetUtxoByAddress
        | GetUtxoByTxIn
        | GetGenesisConfig
        | GetRewardsProvenance
        | GetPoolsRanking
        | GetPoolIds
        | GetPoolParameters;
    };
    /**
     * An arbitrary JSON value that will be mirrored back in the response.
     */
    mirror?: {
      [k: string]: unknown;
    };
  };
  "QueryResponse[eraStart]": {
    type: "jsonwsp/response";
    version: "1.0";
    servicename: "ogmios";
    methodname: "Query";
    result: Bound | QueryUnavailableInCurrentEra;
    /**
     * Any value that was set by a client request in the 'mirror' field.
     */
    reflection?: {
      [k: string]: unknown;
    };
  };
  "QueryResponse[ledgerTip]": {
    type: "jsonwsp/response";
    version: "1.0";
    servicename: "ogmios";
    methodname: "Query";
    result: PointOrOrigin | EraMismatch | QueryUnavailableInCurrentEra;
    /**
     * Any value that was set by a client request in the 'mirror' field.
     */
    reflection?: {
      [k: string]: unknown;
    };
  };
  "QueryResponse[currentEpoch]": {
    type: "jsonwsp/response";
    version: "1.0";
    servicename: "ogmios";
    methodname: "Query";
    result: Epoch | EraMismatch | QueryUnavailableInCurrentEra;
    /**
     * Any value that was set by a client request in the 'mirror' field.
     */
    reflection?: {
      [k: string]: unknown;
    };
  };
  "QueryResponse[nonMyopicMemberRewards]": {
    type: "jsonwsp/response";
    version: "1.0";
    servicename: "ogmios";
    methodname: "Query";
    result: NonMyopicMemberRewards | EraMismatch | QueryUnavailableInCurrentEra;
    /**
     * Any value that was set by a client request in the 'mirror' field.
     */
    reflection?: {
      [k: string]: unknown;
    };
  };
  "QueryResponse[delegationsAndRewards]": {
    type: "jsonwsp/response";
    version: "1.0";
    servicename: "ogmios";
    methodname: "Query";
    result: DelegationsAndRewardsByAccounts | EraMismatch | QueryUnavailableInCurrentEra;
    /**
     * Any value that was set by a client request in the 'mirror' field.
     */
    reflection?: {
      [k: string]: unknown;
    };
  };
  "QueryResponse[currentProtocolParameters]": {
    type: "jsonwsp/response";
    version: "1.0";
    servicename: "ogmios";
    methodname: "Query";
    result: ProtocolParametersShelley | ProtocolParametersAlonzo | EraMismatch | QueryUnavailableInCurrentEra;
    /**
     * Any value that was set by a client request in the 'mirror' field.
     */
    reflection?: {
      [k: string]: unknown;
    };
  };
  "QueryResponse[proposedProtocolParameters]": {
    type: "jsonwsp/response";
    version: "1.0";
    servicename: "ogmios";
    methodname: "Query";
    result:
      | ProposedProtocolParametersShelley
      | ProposedProtocolParametersAlonzo
      | EraMismatch
      | QueryUnavailableInCurrentEra;
    /**
     * Any value that was set by a client request in the 'mirror' field.
     */
    reflection?: {
      [k: string]: unknown;
    };
  };
  "QueryResponse[stakeDistribution]": {
    type: "jsonwsp/response";
    version: "1.0";
    servicename: "ogmios";
    methodname: "Query";
    result: PoolDistribution | EraMismatch | QueryUnavailableInCurrentEra;
    /**
     * Any value that was set by a client request in the 'mirror' field.
     */
    reflection?: {
      [k: string]: unknown;
    };
  };
  "QueryResponse[utxo]": {
    type: "jsonwsp/response";
    version: "1.0";
    servicename: "ogmios";
    methodname: "Query";
    result: Utxo | EraMismatch | QueryUnavailableInCurrentEra;
    /**
     * Any value that was set by a client request in the 'mirror' field.
     */
    reflection?: {
      [k: string]: unknown;
    };
  };
  "QueryResponse[genesisConfig]": {
    type: "jsonwsp/response";
    version: "1.0";
    servicename: "ogmios";
    methodname: "Query";
    result: CompactGenesis | EraMismatch | QueryUnavailableInCurrentEra;
    /**
     * Any value that was set by a client request in the 'mirror' field.
     */
    reflection?: {
      [k: string]: unknown;
    };
  };
  "QueryResponse[rewardsProvenance]": {
    type: "jsonwsp/response";
    version: "1.0";
    servicename: "ogmios";
    methodname: "Query";
    result: RewardsProvenance | EraMismatch | QueryUnavailableInCurrentEra;
    /**
     * Any value that was set by a client request in the 'mirror' field.
     */
    reflection?: {
      [k: string]: unknown;
    };
  };
  "QueryResponse[poolIds]": {
    type: "jsonwsp/response";
    version: "1.0";
    servicename: "ogmios";
    methodname: "Query";
    result: PoolId[] | EraMismatch | QueryUnavailableInCurrentEra;
    /**
     * Any value that was set by a client request in the 'mirror' field.
     */
    reflection?: {
      [k: string]: unknown;
    };
  };
  "QueryResponse[poolParameters]": {
    type: "jsonwsp/response";
    version: "1.0";
    servicename: "ogmios";
    methodname: "Query";
    result:
      | {
          [k: string]: PoolParameters;
        }
      | EraMismatch
      | QueryUnavailableInCurrentEra;
    /**
     * Any value that was set by a client request in the 'mirror' field.
     */
    reflection?: {
      [k: string]: unknown;
    };
  };
  "QueryResponse[poolsRanking]": {
    type: "jsonwsp/response";
    version: "1.0";
    servicename: "ogmios";
    methodname: "Query";
    result: PoolsRanking | EraMismatch | QueryUnavailableInCurrentEra;
    /**
     * Any value that was set by a client request in the 'mirror' field.
     */
    reflection?: {
      [k: string]: unknown;
    };
  };
  /**
   * A fault in the JSON-WSP protocol. This is returned by the server when a request from clients is deemed invalid or, when the server was unable to reply to a well-formed request.
   */
  Fault: {
    type: "jsonwsp/fault";
    version: "1.0";
    servicename: "ogmios";
    fault: {
      /**
       * An error code telling about the nature of the fault.
       */
      code: "incompatible" | "server" | "client";
      /**
       * A descriptive error message giving hints about the fault.
       */
      string: string;
    };
  };
  [k: string]: unknown;
}
export interface RollForward {
  RollForward: {
    block: Block;
    tip: TipOrOrigin;
  };
}
export interface Byron {
  byron: BlockByron;
}
export interface StandardBlock {
  hash: Hash16;
  header: {
    blockHeight: BlockNo;
    genesisKey: Hash16;
    prevHash: Hash16;
    proof: BlockProof;
    protocolMagicId: ProtocolMagicId;
    protocolVersion: ProtocolVersion;
    signature: BlockSignature;
    slot: Slot;
    softwareVersion: SoftwareVersion;
  };
  body: {
    txPayload: {
      id: Hash16;
      body: Tx;
      witness: TxWitness[];
    }[];
    dlgPayload: DlgCertificate[];
    updatePayload: {
      proposal: Null | UpdateProposalByron;
      votes: Vote[];
    };
  };
}
export interface BlockProof {
  utxo: {
    number: UInt32;
    root: Hash16;
    witnessesHash: Hash16;
  };
  delegation: Hash16;
  update: Hash16;
}
export interface ProtocolVersion {
  major: UInt32;
  minor: UInt32;
  patch?: UInt32;
}
export interface BlockSignature {
  dlgCertificate: DlgCertificate;
  signature: Hash64;
}
/**
 * A (Byron) delegation certificate.
 */
export interface DlgCertificate {
  epoch: Epoch;
  issuerVk: Hash16;
  delegateVk: Hash16;
  signature: Hash64;
}
export interface SoftwareVersion {
  appName: string;
  number: UInt32;
}
export interface Tx {
  inputs: TxIn[];
  outputs: TxOut[];
}
export interface TxIn {
  txId: Hash16;
  index: number;
}
/**
 * A transaction output. Since Mary, 'value' always return a multi-asset value. Since Alonzo, 'datum' is always present (albeit sometimes 'null')
 */
export interface TxOut {
  address: Address;
  value: Value;
  datum?: Hash16 | Null;
}
export interface Value {
  coins: Lovelace;
  assets?: {
    [k: string]: AssetQuantity;
  };
}
export interface WitnessVk {
  witnessVk: {
    key: Hash16;
    signature: Hash64;
  };
}
export interface RedeemWitness {
  redeemWitness: {
    key: Hash64;
    signature: Hash64;
  };
}
export interface UpdateProposalByron {
  body: {
    protocolVersion: ProtocolVersion;
    softwareVersion: SoftwareVersion;
    metadata: {
      [k: string]: string;
    };
    parametersUpdate: ProtocolParametersByron;
  };
  issuer: Hash64;
  signature: Hash64;
}
export interface ProtocolParametersByron {
  heavyDlgThreshold: NullableRatio;
  maxBlockSize: NullableUInt64;
  maxHeaderSize: NullableUInt64;
  maxProposalSize: NullableUInt64;
  maxTxSize: NullableUInt64;
  mpcThreshold: NullableRatio;
  scriptVersion: NullableUInt64;
  slotDuration: NullableUInt64;
  unlockStakeEpoch: NullableUInt64;
  updateProposalThreshold: NullableRatio;
  updateProposalTimeToLive: NullableUInt64;
  updateVoteThreshold: NullableRatio;
  txFeePolicy: TxFeePolicy | Null;
  softforkRule: SoftForkRule | Null;
}
export interface TxFeePolicy {
  coefficient: Ratio;
  constant: number;
}
export interface SoftForkRule {
  initThreshold: NullableRatio;
  minThreshold: NullableRatio;
  decrementThreshold: NullableRatio;
}
export interface Vote {
  voterVk: Hash64;
  proposalId: Hash16;
  signature: Hash64;
}
export interface EpochBoundaryBlock {
  hash: Hash16;
  header: {
    blockHeight: BlockNo;
    epoch: Epoch;
    prevHash: Hash16;
  };
}
export interface Shelley {
  shelley: BlockShelley;
}
export interface BlockShelley {
  body?: BlockBodyShelley[];
  headerHash?: Hash16;
  header?: {
    blockHeight: BlockNo;
    slot: Slot;
    prevHash: Hash16;
    issuerVk: Hash16;
    issuerVrf: Hash64;
    nonce?: NonceProof;
    leaderValue: LeaderValue;
    blockSize: BlockSize;
    blockHash: Hash16;
    opCert: OpCert;
    protocolVersion: ProtocolVersion;
    signature: Hash64;
  };
}
export interface BlockBodyShelley {
  id: Hash16;
  body: {
    inputs: TxIn[];
    outputs: TxOut[];
    certificates: Certificate[];
    withdrawals: Withdrawals;
    fee: Lovelace;
    timeToLive: Slot;
    update: UpdateShelley;
  };
  witness: {
    signatures: {
      [k: string]: Signature;
    };
    scripts: {
      [k: string]: Script;
    };
    bootstrap: BootstrapWitness[];
  };
  metadata: AuxiliaryData | Null;
}
/**
 * A stake delegation certificate, from a delegator to a stake pool.
 */
export interface StakeDelegation {
  stakeDelegation: {
    delegator: Hash16;
    delegatee: PoolId;
  };
}
/**
 * A stake key registration certificate.
 */
export interface StakeKeyRegistration {
  stakeKeyRegistration: Hash16;
}
/**
 * A stake key de-registration certificate.
 */
export interface StakeKeyDeregistration {
  stakeKeyDeregistration: Hash16;
}
/**
 * A pool registration certificate.
 */
export interface PoolRegistration {
  poolRegistration: PoolParameters;
}
export interface PoolParameters {
  owners: Hash16[];
  cost: Lovelace;
  margin: Ratio;
  pledge: Lovelace;
  vrf: Hash16;
  metadata: Null | PoolMetadata;
  id: PoolId;
  relays: Relay[];
  rewardAccount: RewardAccount;
}
export interface PoolMetadata {
  hash: Hash16;
  url: string;
}
export interface ByAddress {
  ipv4: string | Null;
  ipv6: string | Null;
  port: number | Null;
}
export interface ByName {
  hostname: string;
  port: number | Null;
}
/**
 * A pool retirement certificate.
 */
export interface PoolRetirement {
  poolRetirement: {
    retirementEpoch: Epoch;
    poolId: PoolId;
  };
}
export interface GenesisDelegation {
  genesisDelegation: {
    delegateKeyHash: Hash16;
    verificationKeyHash: Hash16;
    vrfVerificationKeyHash: Hash16;
  };
}
/**
 * Either `value` or `rewards` will be present, but never both.
 */
export interface MoveInstantaneousRewards {
  moveInstantaneousRewards: {
    rewards?: Rewards;
    value?: Lovelace;
    pot: RewardPot;
  };
}
export interface Rewards {
  [k: string]: LovelaceDelta;
}
export interface Withdrawals {
  [k: string]: Lovelace;
}
export interface UpdateProposalShelley {
  epoch: Epoch;
  proposal: {
    [k: string]: ProtocolParametersShelley;
  };
}
export interface ProtocolParametersShelley {
  minFeeCoefficient: NullableUInt64;
  minFeeConstant: NullableUInt64;
  maxBlockBodySize: NullableUInt64;
  maxBlockHeaderSize: NullableUInt64;
  maxTxSize: NullableUInt64;
  stakeKeyDeposit: NullableUInt64;
  poolDeposit: NullableUInt64;
  poolRetirementEpochBound: NullableUInt64;
  desiredNumberOfPools: NullableUInt64;
  poolInfluence: NullableRatio;
  monetaryExpansion: NullableRatio;
  treasuryExpansion: NullableRatio;
  decentralizationParameter: NullableRatio;
  minUtxoValue: NullableUInt64;
  minPoolCost: NullableUInt64;
  extraEntropy: Nonce | Null;
  protocolVersion: ProtocolVersion | Null;
}
export interface Native {
  native: ScriptNative;
}
export interface Any {
  any: ScriptNative[];
}
export interface All {
  all: ScriptNative[];
}
export interface NOf {
  [k: string]: ScriptNative[];
}
export interface ExpiresAt {
  expiresAt: Slot;
}
export interface StartsAt {
  startsAt: Slot;
}
export interface Plutus {
  plutus: ScriptPlutus;
}
export interface BootstrapWitness {
  signature?: Hash64;
  chainCode?: Hash16 | Null;
  addressAttributes?: Hash64 | Null;
  key?: Hash16;
}
export interface AuxiliaryData {
  hash: Hash16;
  body: AuxiliaryDataBody;
}
export interface AuxiliaryDataBody {
  blob?: Metadata;
  scripts?: Script[];
}
export interface Metadata {
  [k: string]: Metadatum;
}
export interface Int {
  int: bigint;
}
export interface String {
  string: string;
}
export interface Bytes {
  bytes: string;
}
export interface List {
  list: Metadatum[];
}
export interface Map {
  map: MetadatumMap[];
}
export interface MetadatumMap {
  k: Metadatum;
  v: Metadatum;
}
export interface NonceProof {
  proof?: Hash64;
  output?: Hash64;
}
/**
 * In Ouroboros Praos, designate the leader's contribution to the Multi-Party computation used for calculating the leader schedule.
 */
export interface LeaderValue {
  proof?: Hash64;
  output?: Hash64;
}
/**
 * Certificate identifying a stake pool operator.
 */
export interface OpCert {
  count?: UInt64;
  sigma?: Hash64;
  kesPeriod?: UInt64;
  hotVk?: Hash64;
}
export interface Allegra {
  allegra: BlockAllegra;
}
export interface BlockAllegra {
  body?: BlockBodyAllegra[];
  headerHash?: Hash16;
  header?: {
    blockHeight: BlockNo;
    slot: Slot;
    prevHash: Hash16;
    issuerVk: Hash16;
    issuerVrf: Hash64;
    nonce?: NonceProof;
    leaderValue: LeaderValue;
    blockSize: BlockSize;
    blockHash: Hash16;
    opCert: OpCert;
    protocolVersion: ProtocolVersion;
    signature: Hash64;
  };
}
export interface BlockBodyAllegra {
  id: Hash16;
  body: {
    inputs: TxIn[];
    outputs: TxOut[];
    certificates: Certificate[];
    withdrawals: Withdrawals;
    fee: Lovelace;
    validityInterval: ValidityInterval;
    update: UpdateShelley;
  };
  witness: {
    signatures: {
      [k: string]: Signature;
    };
    scripts: {
      [k: string]: Script;
    };
    bootstrap: BootstrapWitness[];
  };
  metadata: AuxiliaryData | Null;
}
export interface ValidityInterval {
  invalidBefore: Slot | Null;
  invalidHereafter: Slot | Null;
}
export interface Mary {
  mary: BlockMary;
}
export interface BlockMary {
  body?: BlockBodyMary[];
  headerHash?: Hash16;
  header?: {
    blockHeight: BlockNo;
    slot: Slot;
    prevHash: Hash16;
    issuerVk: Hash16;
    issuerVrf: Hash64;
    nonce?: NonceProof;
    leaderValue: LeaderValue;
    blockSize: BlockSize;
    blockHash: Hash16;
    opCert: OpCert;
    protocolVersion: ProtocolVersion;
    signature: Hash64;
  };
}
export interface BlockBodyMary {
  id: Hash16;
  body: {
    inputs: TxIn[];
    outputs: TxOut[];
    certificates: Certificate[];
    withdrawals: Withdrawals;
    fee: Lovelace;
    validityInterval: ValidityInterval;
    update: UpdateShelley;
    mint: Value;
  };
  witness: {
    signatures: {
      [k: string]: Signature;
    };
    scripts: {
      [k: string]: Script;
    };
    bootstrap: BootstrapWitness[];
  };
  metadata: AuxiliaryData | Null;
}
export interface Alonzo {
  alonzo: BlockAlonzo;
}
export interface BlockAlonzo {
  body?: BlockBodyAlonzo[];
  headerHash?: Hash16;
  header?: {
    blockHeight: BlockNo;
    slot: Slot;
    prevHash: Hash16;
    issuerVk: Hash16;
    issuerVrf: Hash64;
    nonce?: NonceProof;
    leaderValue: LeaderValue;
    blockSize: BlockSize;
    blockHash: Hash16;
    opCert: OpCert;
    protocolVersion: ProtocolVersion;
    signature: Hash64;
  };
}
export interface BlockBodyAlonzo {
  id: Hash16;
  body: {
    inputs: TxIn[];
    collaterals: TxIn[];
    outputs: TxOut[];
    certificates: Certificate[];
    withdrawals: Withdrawals;
    fee: Lovelace;
    validityInterval: ValidityInterval;
    update: UpdateAlonzo;
    mint: Value;
    network: Network | Null;
    scriptIntegrityHash: Hash16 | Null;
    requiredExtraSignatures: Hash16[];
  };
  witness: {
    signatures: {
      [k: string]: Signature;
    };
    scripts: {
      [k: string]: Script;
    };
    bootstrap: BootstrapWitness[];
    datums: {
      [k: string]: Hash64;
    };
    redeemers: {
      [k: string]: Redeemer;
    };
  };
  metadata: AuxiliaryData | Null;
}
export interface UpdateProposalAlonzo {
  epoch: Epoch;
  proposal: {
    [k: string]: ProtocolParametersAlonzo;
  };
}
export interface ProtocolParametersAlonzo {
  minFeeCoefficient: NullableUInt64;
  minFeeConstant: NullableUInt64;
  maxBlockBodySize: NullableUInt64;
  maxBlockHeaderSize: NullableUInt64;
  maxTxSize: NullableUInt64;
  stakeKeyDeposit: NullableUInt64;
  poolDeposit: NullableUInt64;
  poolRetirementEpochBound: NullableUInt64;
  desiredNumberOfPools: NullableUInt64;
  poolInfluence: NullableRatio;
  monetaryExpansion: NullableRatio;
  treasuryExpansion: NullableRatio;
  decentralizationParameter: NullableRatio;
  minPoolCost: NullableUInt64;
  coinsPerUtxoWord: NullableUInt64;
  maxValueSize: NullableUInt64;
  collateralPercentage: NullableUInt64;
  maxCollateralInputs: NullableUInt64;
  extraEntropy: Nonce | Null;
  protocolVersion: ProtocolVersion | Null;
  costModels: CostModels | Null;
  prices: Prices | Null;
  maxExecutionUnitsPerTransaction: ExUnits | Null;
  maxExecutionUnitsPerBlock: ExUnits | Null;
}
export interface CostModels {
  [k: string]: CostModel;
}
export interface CostModel {
  [k: string]: Int64;
}
export interface Prices {
  memory: Ratio;
  steps: Ratio;
}
export interface ExUnits {
  memory: UInt64;
  steps: UInt64;
}
export interface Redeemer {
  redeemer: Hash64;
  executionUnits: ExUnits;
}
export interface Tip {
  slot: Slot;
  hash: Hash16;
  blockNo: BlockNo;
}
export interface RollBackward {
  RollBackward: {
    point: PointOrOrigin;
    tip: TipOrOrigin;
  };
}
/**
 * A point on the chain, identified by a slot and a block header hash.
 */
export interface Point {
  slot: Slot;
  hash: Hash16;
}
export interface IntersectionFound {
  IntersectionFound: {
    point: PointOrOrigin;
    tip: TipOrOrigin;
  };
}
export interface IntersectionNotFound {
  IntersectionNotFound: {
    tip: TipOrOrigin;
  };
}
export interface SubmitFail {
  SubmitFail: EraMismatch | SubmitTxError;
}
/**
 * An era mismatch between a client request and the era the ledger is in. This may occur when running queries on a syncing node and/or when the node is crossing an era.
 */
export interface EraMismatch {
  eraMismatch: {
    queryEra: Era;
    ledgerEra: Era;
  };
}
export interface InvalidWitnesses {
  invalidWitnesses: Hash16[];
}
export interface MissingVkWitnesses {
  missingVkWitnesses: Hash16[];
}
export interface MissingScriptWitnesses {
  missingScriptWitnesses: Hash16[];
}
export interface ScriptWitnessNotValidating {
  scriptWitnessNotValidating: Hash16[];
}
export interface InsufficientGenesisSignatures {
  insufficientGenesisSignatures: Hash16[];
}
export interface MissingTxMetadata {
  missingTxMetadata: Hash16;
}
export interface MissingTxMetadataHash {
  missingTxMetadataHash: Hash16;
}
export interface TxMetadataHashMismatch {
  txMetadataHashMismatch: {
    includedHash: Hash16;
    expectedHash: Hash16;
  };
}
export interface BadInputs {
  badInputs: TxIn[];
}
/**
 * Only in Shelley. Replaced with 'outsideOfValidityInterval' since Allegra.
 */
export interface ExpiredUtxo {
  expiredUtxo: {
    currentSlot: Slot;
    transactionTimeToLive: Slot;
  };
}
/**
 * Since Allegra. Replaces 'expiredUtxo'.
 */
export interface OutsideOfValidityInterval {
  outsideOfValidityInterval: {
    currentSlot: Slot;
    interval: ValidityInterval;
  };
}
export interface TxTooLarge {
  txTooLarge: {
    maximumSize: Int64;
    actualSize: Int64;
  };
}
export interface FeeTooSmall {
  feeTooSmall: {
    requiredFee: Lovelace;
    actualFee: Lovelace;
  };
}
/**
 * Returns 'Value' since Mary, and 'LovelaceDelta' before.
 */
export interface ValueNotConserved {
  valueNotConserved: {
    consumed: LovelaceDelta | Value;
    produced: LovelaceDelta | Value;
  };
}
export interface NetworkMismatch {
  networkMismatch: {
    expectedNetwork: Network;
    invalidEntities: InvalidEntity[];
  };
}
export interface OutputTooSmall {
  outputTooSmall: TxOut[];
}
/**
 * Only since Mary.
 */
export interface TooManyAssetsInOutput {
  tooManyAssetsInOutput: TxOut[];
}
export interface AddressAttributesTooLarge {
  addressAttributesTooLarge: Address[];
}
export interface DelegateNotRegistered {
  delegateNotRegistered: PoolId;
}
export interface UnknownOrIncompleteWithdrawals {
  unknownOrIncompleteWithdrawals: Withdrawals;
}
export interface StakePoolNotRegistered {
  stakePoolNotRegistered: PoolId;
}
export interface WrongRetirementEpoch {
  wrongRetirementEpoch: {
    currentEpoch: Epoch;
    requestedEpoch: Epoch;
    firstUnreachableEpoch: Epoch;
  };
}
export interface WrongPoolCertificate {
  wrongPoolCertificate: UInt8;
}
export interface StakeKeyAlreadyRegistered {
  stakeKeyAlreadyRegistered: Hash16;
}
export interface PoolCostTooSmall {
  poolCostTooSmall: {
    minimumCost: Lovelace;
  };
}
export interface PoolMetadataHashTooBig {
  poolMetadataHashTooBig: {
    poolId: PoolId;
    measuredSize: Int64;
  };
}
export interface StakeKeyNotRegistered {
  stakeKeyNotRegistered: Hash16;
}
export interface RewardAccountNotEmpty {
  rewardAccountNotEmpty: {
    balance: Lovelace;
  };
}
export interface UnknownGenesisKey {
  unknownGenesisKey: Hash16;
}
export interface AlreadyDelegating {
  alreadyDelegating: Hash16;
}
export interface InsufficientFundsForMir {
  insufficientFundsForMir: {
    rewardSource: RewardPot;
    sourceSize: Lovelace;
    requestedAmount: Lovelace;
  };
}
export interface TooLateForMir {
  tooLateForMir: {
    currentSlot: Slot;
    lastAllowedSlot: Slot;
  };
}
export interface DuplicateGenesisVrf {
  duplicateGenesisVrf: Hash16;
}
export interface NonGenesisVoters {
  nonGenesisVoters: {
    currentlyVoting: Hash16[];
    shouldBeVoting: Hash16[];
  };
}
export interface UpdateWrongEpoch {
  updateWrongEpoch: {
    currentEpoch: Epoch;
    requestedEpoch: Epoch;
    votingPeriod: VotingPeriod;
  };
}
export interface ProtocolVersionCannotFollow {
  protocolVersionCannotFollow: ProtocolVersion;
}
export interface MissingRequiredRedeemers {
  missingRequiredRedeemers: {
    missing: {
      [k: string]: ScriptPurpose;
    }[];
  };
}
export interface Spend {
  spend: TxIn;
}
export interface Mint {
  mint: Hash16;
}
export interface Certificate1 {
  certificate: Certificate;
}
export interface Withdrawal {
  withdrawal: RewardAccount;
}
export interface MissingRequiredDatums {
  missingRequiredDatums: {
    provided: Hash16[];
    missing: Hash16[];
  };
}
export interface UnspendableDatums {
  unspendableDatums: {
    nonSpendable: Hash16[];
    acceptable: Hash16[];
  };
}
export interface ExtraDataMismatch {
  extraDataMismatch: {
    provided: Hash16 | Null;
    inferredFromParameters: Hash16 | Null;
  };
}
export interface MissingRequiredSignatures {
  missingRequiredSignatures: Hash16[];
}
export interface UnspendableScriptInputs {
  unspendableScriptInputs: TxIn[];
}
export interface ExtraRedeemers {
  extraRedeemers: string[];
}
export interface MissingDatumHashesForInputs {
  missingDatumHashesForInputs: TxIn[];
}
export interface CollateralTooSmall {
  collateralTooSmall: {
    requiredCollateral: Lovelace;
    actualCollateral: Lovelace;
  };
}
export interface CollateralIsScript {
  collateralIsScript: Utxo;
}
export interface CollateralHasNonAdaAssets {
  collateralHasNonAdaAssets: Value;
}
export interface TooManyCollateralInputs {
  tooManyCollateralInputs: {
    maximumCollateralInputs: UInt64;
    actualCollateralInputs: UInt64;
  };
}
export interface ExecutionUnitsTooLarge {
  executionUnitsTooLarge: {
    maximumExecutionUnits: ExUnits;
    actualExecutionUnits: ExUnits;
  };
}
export interface OutsideForecast {
  outsideForecast: Slot;
}
export interface CollectErrors {
  collectErrors: unknown[];
}
export interface AcquireSuccess {
  AcquireSuccess: {
    point: PointOrOrigin;
  };
}
export interface AcquireFailure {
  AcquireFailure: {
    failure: AcquireFailureDetails;
  };
}
export interface GetNonMyopicMemberRewards {
  nonMyopicMemberRewards: Lovelaces | Credentials;
}
export interface GetDelegationsAndRewards {
  delegationsAndRewards: Hash16[];
}
export interface GetUtxoByAddress {
  utxo: Address[];
}
export interface GetUtxoByTxIn {
  utxo: TxIn[];
}
export interface GetPoolParameters {
  poolParameters: (PoolId | string)[];
}
/**
 * An era bound which captures the time, slot and epoch at which the era start. The time is relative to the start time of the network.
 */
export interface Bound {
  time: RelativeTime;
  slot: Slot;
  epoch: Epoch;
}
/**
 * Rewards that can be expected assuming a pool is fully saturated. Such rewards are said non-myopic, in opposition to short-sighted rewards looking at immediate benefits. Keys of the map can be either Lovelace amounts or account credentials depending on the query.
 */
export interface NonMyopicMemberRewards {
  [k: string]: {
    [k: string]: number;
  };
}
export interface DelegationsAndRewardsByAccounts {
  [k: string]: DelegationsAndRewards;
}
export interface DelegationsAndRewards {
  delegate?: PoolId;
  rewards?: Lovelace;
}
export interface ProposedProtocolParametersShelley {
  [k: string]: ProtocolParametersShelley;
}
export interface ProposedProtocolParametersAlonzo {
  [k: string]: ProtocolParametersAlonzo;
}
/**
 * Distribution of stake across registered stake pools. Each key in the map corresponds to a pool id.
 */
export interface PoolDistribution {
  [k: string]: {
    stake: Ratio;
    vrf: Hash16;
  };
}
/**
 * A compact (without genesis UTxO) representation of the genesis configuration.
 */
export interface CompactGenesis {
  systemStart: UtcTime;
  networkMagic: NetworkMagic;
  network: Network;
  activeSlotsCoefficient: Ratio;
  securityParameter: UInt64;
  epochLength: Epoch;
  slotsPerKesPeriod: UInt64;
  maxKesEvolutions: UInt64;
  slotLength: Int64;
  updateQuorum: UInt64;
  maxLovelaceSupply: UInt64;
  protocolParameters: ProtocolParametersShelley;
}
/**
 * Details about how rewards are calculated for the ongoing epoch.
 */
export interface RewardsProvenance {
  epochLength: Epoch;
  decentralizationParameter: Ratio;
  maxLovelaceSupply: Lovelace;
  /**
   * Number of blocks minted by each pool.
   */
  mintedBlocks: {
    [k: string]: UInt64;
  };
  /**
   * The total number of blocks minted during the given epoch.
   */
  totalMintedBlocks: number;
  /**
   * The number of blocks expected to be produced during the given epoch.
   */
  totalExpectedBlocks: number;
  /**
   * The maximum amount of Lovelace which can be removed from the reserves to be given out as rewards for the given epoch.
   */
  incentive: number;
  /**
   * The difference between the 'availableRewards' and what was actually distributed.
   */
  rewardsGap: number;
  /**
   * The total Lovelace available for rewards for the given epoch, equal to 'totalRewards' less 'treasuryTax'.
   */
  availableRewards: number;
  /**
   * The reward pot for the given epoch, equal to the 'incentive' plus the fee pot.
   */
  totalRewards: number;
  /**
   * The amount of Lovelace taken for the treasury for the given epoch.
   */
  treasuryTax: number;
  /**
   * The amount of Lovelace that is delegated during the given epoch.
   */
  activeStake: number;
  pools: {
    [k: string]: IndividualPoolRewardsProvenance;
  };
}
export interface IndividualPoolRewardsProvenance {
  /**
   * The number of blocks the pool produced.
   */
  totalMintedBlocks: number;
  /**
   * A ratio of two integers, to express exact fractions.
   */
  totalStakeShare: string;
  /**
   * A ratio of two integers, to express exact fractions.
   */
  activeStakeShare: string;
  /**
   * The number of Lovelace owned by the stake pool owners. If this value is not at least as large as the 'pledgeRatio', the stake pool will not earn any rewards for the given epoch.
   */
  ownerStake: number;
  parameters: PoolParameters;
  /**
   * A ratio of two integers, to express exact fractions.
   */
  pledgeRatio: string;
  /**
   * The maximum number of Lovelace this stake pool can earn.
   */
  maxRewards: number;
  /**
   * A ratio of two integers, to express exact fractions.
   */
  apparentPerformance: string;
  /**
   * The total Lovelace earned by the stake pool.
   */
  totalRewards: number;
  /**
   * The total Lovelace earned by the stake pool leader.
   */
  leaderRewards: number;
}
export interface PoolsRanking {
  [k: string]: {
    score: number;
    estimatedHitRate: number;
  };
}
