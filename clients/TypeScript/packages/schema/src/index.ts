/* tslint:disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type PointOrOrigin = Point | Origin;
/**
 * An absolute slot number.
 */
export type Slot = number;
/**
 * A Blake2b 32-byte hash digest, encoded in base16.
 */
export type DigestBlake2B256 = string;
/**
 * The origin of the blockchain. This point is special in the sense that it doesn't point to any existing slots, but is preceding any existing other point.
 */
export type Origin = "origin";
export type TipOrOrigin = Tip | Origin;
/**
 * A block number, the i-th block to be minted is number i.
 */
export type BlockHeight = number;
export type Block = BlockEBB | BlockBFT | BlockPraos;
export type UInt64 = number;
/**
 * A Blake2b 32-byte hash digest of a transaction body
 */
export type TransactionId = string;
/**
 * A Cardano address (either legacy format or new format).
 */
export type Address = string;
/**
 * A number of asset, can be negative went burning assets.
 */
export type AssetQuantity = bigint;
export type Datum = string;
export type Script = Native | Plutus;
/**
 * A phase-1 monetary script. Timelocks constraints are only supported since Allegra.
 */
export type ScriptNative = ClauseSignature | ClauseAny | ClauseAll | ClauseSome | ClauseBefore | ClauseAfter;
/**
 * A Blake2b 28-byte hash digest, encoded in base16.
 */
export type DigestBlake2B224 = string;
export type Certificate =
  | StakeDelegation
  | StakeCredentialRegistration
  | StakeCredentialDeregistration
  | StakePoolRegistration
  | StakePoolRetirement
  | GenesisDelegation
  | ConstitutionalCommitteeDelegation
  | ConstitutionalCommitteeRetirement
  | DelegateRepresentativeRegistration
  | DelegateRepresentativeUpdate
  | DelegateRepresentativeRetirement;
export type CredentialOrigin = "verificationKey" | "script";
/**
 * A Blake2b 32-byte hash digest of a pool's verification key.
 */
export type StakePoolId = string;
export type DelegateRepresentative =
  | DelegateRepresentativeRegistered
  | DelegateRepresentativeNoConfidence
  | DelegateRepresentativeAbstain;
/**
 * A ratio of two integers, to express exact fractions.
 */
export type Ratio = string;
/**
 * A reward account, also known as 'stake address'.
 */
export type RewardAccount = string;
/**
 * A hash digest from an unspecified algorithm and length.
 */
export type DigestAny = string;
export type Relay = RelayByAddress | RelayByName;
/**
 * An epoch number or length.
 */
export type Epoch = number;
export type ConstitutionalCommitteeDelegate =
  | {
      status: "authorized";
      id: DigestBlake2B224;
      from: CredentialOrigin;
    }
  | {
      status: "resigned";
      metadata?: Anchor;
    }
  | {
      status: "none";
    };
export type None = null;
/**
 * A network target, as defined since the Shelley era.
 */
export type Network = "mainnet" | "testnet";
export type UInt32 = number;
export type Nonce = Neutral | DigestBlake2B256;
export type Neutral = "neutral";
export type Int64 = number;
export type CostModel = Int64[];
export type UInt16 = number;
export type Metadatum = MetadatumNoSchema | MetadatumDetailedSchema;
export type MetadatumNoSchema = IntegerNoSchema | StringNoSchema | ArrayNoSchema | ObjectNoSchema;
export type IntegerNoSchema = bigint;
export type StringNoSchema = string;
export type ArrayNoSchema = MetadatumNoSchema[];
export type MetadatumDetailedSchema =
  | IntegerDetailedSchema
  | StringDetailedSchema
  | BytesDetailedSchema
  | ArrayDetailedSchema
  | ObjectDetailedSchema;
/**
 * An Ed25519 verification key.
 */
export type VerificationKey = string;
/**
 * An EdDSA signature.
 */
export type Signature = string;
/**
 * An Ed25519-BIP32 chain-code for key deriviation.
 */
export type ChainCode = string;
/**
 * Extra attributes carried by Byron addresses (network magic and/or HD payload).
 */
export type AddressAttributes = string;
/**
 * Plutus data, CBOR-serialised.
 */
export type RedeemerData = string;
export type BootstrapProtocolId = number;
/**
 * An Ed25519-BIP32 Byron genesis delegate verification key with chain-code.
 */
export type ExtendedVerificationKey = string;
export type GenesisHash = "genesis";
export type VrfProof = string;
export type VrfOutput = string;
export type KesVerificationKey = string;
export type SubmitTransactionFailure =
  | SubmitTransactionFailureEraMismatch
  | SubmitTransactionFailureInvalidSignatories
  | SubmitTransactionFailureMissingSignatories
  | SubmitTransactionFailureMissingScripts
  | SubmitTransactionFailureFailingNativeScript
  | SubmitTransactionFailureExtraneousScripts
  | SubmitTransactionFailureMissingMetadataHash
  | SubmitTransactionFailureMissingMetadata
  | SubmitTransactionFailureMetadataHashMismatch
  | SubmitTransactionFailureInvalidMetadata
  | SubmitTransactionFailureMissingRedeemers
  | SubmitTransactionFailureExtraneousRedeemers
  | SubmitTransactionFailureMissingDatums
  | SubmitTransactionFailureExtraneousDatums
  | SubmitTransactionFailureScriptIntegrityHashMismatch
  | SubmitTransactionFailureOrphanScriptInputs
  | SubmitTransactionFailureMissingCostModels
  | SubmitTransactionFailureMalformedScripts
  | SubmitTransactionFailureUnknownOutputReferences
  | SubmitTransactionFailureOutsideOfValidityInterval
  | SubmitTransactionFailureTransactionTooLarge
  | SubmitTransactionFailureValueTooLarge
  | SubmitTransactionFailureEmptyInputSet
  | SubmitTransactionFailureTransactionFeeTooSmall
  | SubmitTransactionFailureValueNotConserved
  | SubmitTransactionFailureNetworkMismatch
  | SubmitTransactionFailureInsufficientlyFundedOutputs
  | SubmitTransactionFailureBootstrapAttributesTooLarge
  | SubmitTransactionFailureMintingOrBurningAda
  | SubmitTransactionFailureInsufficientCollateral
  | SubmitTransactionFailureCollateralLockedByScript
  | SubmitTransactionFailureUnforeseeableSlot
  | SubmitTransactionFailureTooManyCollateralInputs
  | SubmitTransactionFailureMissingCollateralInputs
  | SubmitTransactionFailureNonAdaCollateral
  | SubmitTransactionFailureExecutionUnitsTooLarge
  | SubmitTransactionFailureTotalCollateralMismatch
  | SubmitTransactionFailureSpendsMismatch
  | SubmitTransactionFailureUnauthorizedVotes
  | SubmitTransactionFailureUnknownGovernanceProposals
  | SubmitTransactionFailureInvalidProtocolParametersUpdate
  | SubmitTransactionFailureUnknownStakePool
  | SubmitTransactionFailureIncompleteWithdrawals
  | SubmitTransactionFailureRetirementTooLate
  | SubmitTransactionFailureStakePoolCostTooLow
  | SubmitTransactionFailureMetadataHashTooLarge
  | SubmitTransactionFailureCredentialAlreadyRegistered
  | SubmitTransactionFailureUnknownCredential
  | SubmitTransactionFailureNonEmptyRewardAccount
  | SubmitTransactionFailureInvalidGenesisDelegation
  | SubmitTransactionFailureInvalidMIRTransfer
  | SubmitTransactionFailureForbiddenWithdrawal
  | SubmitTransactionFailureCredentialDepositMismatch
  | SubmitTransactionFailureDRepAlreadyRegistered
  | SubmitTransactionFailureDRepNotRegistered
  | SubmitTransactionFailureUnknownConstitutionalCommitteeMember
  | SubmitTransactionFailureGovernanceProposalDepositMismatch
  | SubmitTransactionFailureConflictingCommitteeUpdate
  | SubmitTransactionFailureInvalidCommitteeUpdate
  | SubmitTransactionFailureTreasuryWithdrawalMismatch
  | SubmitTransactionFailureInvalidOrMissingPreviousProposals
  | SubmitTransactionFailureVotingOnExpiredActions
  | SubmitTransactionFailureExecutionBudgetOutOfBounds
  | SubmitTransactionFailureInvalidHardForkVersionBump
  | SubmitTransactionFailureConstitutionGuardrailsHashMismatch
  | SubmitTransactionFailureConflictingInputsAndReferences
  | SubmitTransactionFailureUnauthorizedGovernanceAction
  | SubmitTransactionFailureReferenceScriptsTooLarge
  | SubmitTransactionFailureUnknownVoters
  | SubmitTransactionFailureEmptyTreasuryWithdrawal
  | SubmitTransactionFailureUnexpectedMempoolError
  | SubmitTransactionFailureUnrecognizedCertificateType;
export type Era = "byron" | "shelley" | "allegra" | "mary" | "alonzo" | "babbage" | "conway";
export type ScriptPurpose =
  | ScriptPurposeSpend
  | ScriptPurposeMint
  | ScriptPurposePublish
  | ScriptPurposeWithdraw
  | ScriptPurposePropose
  | ScriptPurposeVote;
/**
 * A Blake2b 28-byte hash digest, encoded in base16.
 */
export type PolicyId = string;
export type Language = "plutus:v1" | "plutus:v2" | "plutus:v3";
export type Utxo = {
  transaction: {
    id: TransactionId;
  };
  index: UInt32;
  address: Address;
  value: Value;
  datumHash?: DigestBlake2B256;
  datum?: Datum;
  script?: Script;
}[];
export type EvaluateTransactionFailure =
  | EvaluateTransactionFailureIncompatibleEra
  | EvaluateTransactionFailureUnsupportedEra
  | EvaluateTransactionFailureOverlappingAdditionalUtxo
  | EvaluateTransactionFailureNodeTipTooOld
  | EvaluateTransactionFailureCannotCreateEvaluationContext
  | EvaluateTransactionFailureScriptExecutionFailure;
export type ScriptExecutionFailure =
  | ScriptExecutionFailureInvalidRedeemerPointers
  | ScriptExecutionFailureValidationFailure
  | ScriptExecutionFailureUnsuitableOutputReference
  | SubmitTransactionFailureExtraneousRedeemers
  | SubmitTransactionFailureMissingDatums
  | SubmitTransactionFailureUnknownOutputReferences
  | SubmitTransactionFailureMissingCostModels
  | SubmitTransactionFailureExecutionBudgetOutOfBounds;
export type AnyDelegateRepresentativeCredential = Base16 | Bech32DrepVkhDrepScript;
/**
 * A key or script hash in base16.
 */
export type Base16 = string;
/**
 * A Blake2b 28-byte hash digest of a drep verification key or script.
 */
export type Bech32DrepVkhDrepScript = string;
export type DelegateRepresentativeSummary =
  | DelegateRepresentativeSummaryRegistered
  | DelegateRepresentativeSummaryNoConfidence
  | DelegateRepresentativeAbstain1;
/**
 * Number of slots from the tip of the ledger in which it is guaranteed that no hard fork can take place. This should be (at least) the number of slots in which we are guaranteed to have k blocks.
 */
export type SafeZone = number;
export type AnyStakeCredential = Base16 | Bech32StakeVkhScript | StakeAddress;
/**
 * A Blake2b 28-byte hash digest of a verification key or script.
 */
export type Bech32StakeVkhScript = string;
/**
 * A stake address (a.k.a reward account)
 */
export type StakeAddress = string;
export type EraWithGenesis = "byron" | "shelley" | "alonzo" | "conway";
export type UtcTime = string;
/**
 * A magic number for telling networks apart. (e.g. 764824073)
 */
export type NetworkMagic = number;
export type InitialDelegates = {
  issuer: {
    id: DigestBlake2B224;
  };
  delegate: GenesisDelegate;
}[];

export interface Ogmios {
  FindIntersection: FindIntersection;
  FindIntersectionResponse: IntersectionFound | IntersectionNotFound | IntersectionInterleaved;
  NextBlock: NextBlock;
  NextBlockResponse: NextBlockResponse;
  SubmitTransaction: SubmitTransaction;
  SubmitTransactionResponse: SubmitTransactionSuccess | SubmitTransactionError | SubmitTransactionDeserialisationError;
  EvaluateTransaction: EvaluateTransaction;
  EvaluateTransactionResponse:
    | EvaluateTransactionSuccess
    | EvaluateTransactionError
    | EvaluateTransactionDeserialisationError;
  AcquireLedgerState: AcquireLedgerState;
  AcquireLedgerStateFailure?: AcquireLedgerStateFailure;
  AcquireLedgerStateResponse: AcquireLedgerStateSuccess | AcquireLedgerStateFailure;
  ReleaseLedgerState: ReleaseLedgerState;
  ReleaseLedgerStateResponse: ReleaseLedgerStateResponse;
  QueryLedgerStateEraMismatch?: QueryLedgerStateEraMismatch;
  QueryLedgerStateUnavailableInCurrentEra?: QueryLedgerStateUnavailableInCurrentEra;
  QueryLedgerStateAcquiredExpired?: QueryLedgerStateAcquiredExpired;
  QueryLedgerStateConstitution: QueryLedgerStateConstitution;
  QueryLedgerStateConstitutionResponse:
    | QueryLedgerStateConstitutionResponse
    | QueryLedgerStateEraMismatch
    | QueryLedgerStateUnavailableInCurrentEra
    | QueryLedgerStateAcquiredExpired;
  QueryLedgerStateConstitutionalCommittee: QueryLedgerStateConstitutionalCommittee;
  QueryLedgerStateConstitutionalCommitteeResponse:
    | QueryLedgerStateConstitutionalCommitteeResponse
    | QueryLedgerStateEraMismatch
    | QueryLedgerStateUnavailableInCurrentEra
    | QueryLedgerStateAcquiredExpired;
  QueryLedgerStateDelegateRepresentatives: QueryLedgerStateDelegateRepresentatives;
  QueryLedgerStateDelegateRepresentativesResponse:
    | QueryLedgerStateDelegateRepresentativesResponse
    | QueryLedgerStateEraMismatch
    | QueryLedgerStateUnavailableInCurrentEra
    | QueryLedgerStateAcquiredExpired;
  QueryLedgerStateDump: QueryLedgerStateDump;
  QueryLedgerStateDumpResponse:
    | QueryLedgerStateDumpResponse
    | QueryLedgerStateEraMismatch
    | QueryLedgerStateUnavailableInCurrentEra
    | QueryLedgerStateAcquiredExpired;
  QueryLedgerStateEpoch: QueryLedgerStateEpoch;
  QueryLedgerStateEpochResponse:
    | QueryLedgerStateEpochResponse
    | QueryLedgerStateEraMismatch
    | QueryLedgerStateUnavailableInCurrentEra
    | QueryLedgerStateAcquiredExpired;
  QueryLedgerStateEraStart: QueryLedgerStateEraStart;
  QueryLedgerStateEraStartResponse:
    | QueryLedgerStateEraStartResponse
    | QueryLedgerStateEraMismatch
    | QueryLedgerStateUnavailableInCurrentEra
    | QueryLedgerStateAcquiredExpired;
  QueryLedgerStateEraSummaries: QueryLedgerStateEraSummaries;
  QueryLedgerStateEraSummariesResponse:
    | QueryLedgerStateEraSummariesResponse
    | QueryLedgerStateEraMismatch
    | QueryLedgerStateUnavailableInCurrentEra
    | QueryLedgerStateAcquiredExpired;
  QueryLedgerStateGovernanceProposals: QueryLedgerStateGovernanceProposals;
  QueryLedgerStateGovernanceProposalsResponse:
    | QueryLedgerStateGovernanceProposalsResponse
    | QueryLedgerStateEraMismatch
    | QueryLedgerStateUnavailableInCurrentEra
    | QueryLedgerStateAcquiredExpired;
  QueryLedgerStateLiveStakeDistribution: QueryLedgerStateLiveStakeDistribution;
  QueryLedgerStateLiveStakeDistributionResponse:
    | QueryLedgerStateLiveStakeDistributionResponse
    | QueryLedgerStateEraMismatch
    | QueryLedgerStateUnavailableInCurrentEra
    | QueryLedgerStateAcquiredExpired;
  QueryLedgerStateProjectedRewards: QueryLedgerStateProjectedRewards;
  QueryLedgerStateProjectedRewardsResponse:
    | QueryLedgerStateProjectedRewardsResponse
    | QueryLedgerStateEraMismatch
    | QueryLedgerStateUnavailableInCurrentEra
    | QueryLedgerStateAcquiredExpired;
  QueryLedgerStateProposedProtocolParameters: QueryLedgerStateProposedProtocolParameters;
  QueryLedgerStateProposedProtocolParametersResponse:
    | QueryLedgerStateProposedProtocolParametersResponse
    | QueryLedgerStateEraMismatch
    | QueryLedgerStateUnavailableInCurrentEra
    | QueryLedgerStateAcquiredExpired;
  QueryLedgerStateProtocolParameters: QueryLedgerStateProtocolParameters;
  QueryLedgerStateProtocolParametersResponse:
    | QueryLedgerStateProtocolParametersResponse
    | QueryLedgerStateEraMismatch
    | QueryLedgerStateUnavailableInCurrentEra
    | QueryLedgerStateAcquiredExpired;
  QueryLedgerStateRewardAccountSummaries: QueryLedgerStateRewardAccountSummaries;
  QueryLedgerStateRewardAccountSummariesResponse:
    | QueryLedgerStateRewardAccountSummariesResponse
    | QueryLedgerStateEraMismatch
    | QueryLedgerStateUnavailableInCurrentEra
    | QueryLedgerStateAcquiredExpired;
  QueryLedgerStateRewardsProvenance: QueryLedgerStateRewardsProvenance;
  QueryLedgerStateRewardsProvenanceResponse:
    | QueryLedgerStateRewardsProvenanceResponse
    | QueryLedgerStateEraMismatch
    | QueryLedgerStateUnavailableInCurrentEra
    | QueryLedgerStateAcquiredExpired;
  QueryLedgerStateStakePools: QueryLedgerStateStakePools;
  QueryLedgerStateStakePoolsResponse:
    | QueryLedgerStateStakePoolsResponse
    | QueryLedgerStateEraMismatch
    | QueryLedgerStateUnavailableInCurrentEra
    | QueryLedgerStateAcquiredExpired;
  QueryLedgerStateTip: QueryLedgerStateTip;
  QueryLedgerStateTipResponse:
    | QueryLedgerStateTipResponse
    | QueryLedgerStateEraMismatch
    | QueryLedgerStateUnavailableInCurrentEra
    | QueryLedgerStateAcquiredExpired;
  QueryLedgerStateTreasuryAndReserves: QueryLedgerStateTreasuryAndReserves;
  QueryLedgerStateTreasuryAndReservesResponse:
    | QueryLedgerStateTreasuryAndReservesResponse
    | QueryLedgerStateEraMismatch
    | QueryLedgerStateUnavailableInCurrentEra
    | QueryLedgerStateAcquiredExpired;
  QueryLedgerStateUtxo: QueryLedgerStateUtxo;
  QueryLedgerStateUtxoResponse:
    | QueryLedgerStateUtxoResponse
    | QueryLedgerStateEraMismatch
    | QueryLedgerStateUnavailableInCurrentEra
    | QueryLedgerStateAcquiredExpired;
  QueryNetworkBlockHeight: QueryNetworkBlockHeight;
  QueryNetworkBlockHeightResponse: QueryNetworkBlockHeightResponse;
  QueryNetworkGenesisConfiguration: QueryNetworkGenesisConfiguration;
  QueryNetworkGenesisConfigurationResponse: QueryNetworkGenesisConfigurationResponse;
  QueryNetworkInvalidGenesis?: QueryNetworkInvalidGenesis;
  QueryNetworkStartTime: QueryNetworkStartTime;
  QueryNetworkStartTimeResponse: QueryNetworkStartTimeResponse;
  QueryNetworkTip: QueryNetworkTip;
  QueryNetworkTipResponse: QueryNetworkTipResponse;
  AcquireMempool: AcquireMempool;
  AcquireMempoolResponse: AcquireMempoolResponse;
  NextTransaction: NextTransaction;
  MustAcquireMempoolFirst?: MustAcquireMempoolFirst;
  NextTransactionResponse: NextTransactionResponse | MustAcquireMempoolFirst;
  HasTransaction: HasTransaction;
  HasTransactionResponse: HasTransactionResponse | MustAcquireMempoolFirst;
  SizeOfMempool: SizeOfMempool;
  SizeOfMempoolResponse?: SizeOfMempoolResponse | MustAcquireMempoolFirst;
  ReleaseMempool: ReleaseMempool;
  ReleaseMempoolResponse: ReleaseMempoolResponse | MustAcquireMempoolFirst;
  RpcError: RpcError;
}
/**
 * Ask cardano-node to find an intersection between its local chain and the given points.
 */
export interface FindIntersection {
  jsonrpc: "2.0";
  method: "findIntersection";
  params: {
    points?: PointOrOrigin[];
  };
  id?: unknown;
}
/**
 * A point on the chain, identified by a slot and a block header hash.
 */
export interface Point {
  slot: Slot;
  id: DigestBlake2B256;
}
export interface IntersectionFound {
  jsonrpc: "2.0";
  method: "findIntersection";
  result: {
    intersection: PointOrOrigin;
    tip: TipOrOrigin;
  };
  id?: unknown;
}
export interface Tip {
  slot: Slot;
  id: DigestBlake2B256;
  height: BlockHeight;
}
export interface IntersectionNotFound {
  jsonrpc: "2.0";
  method: "findIntersection";
  /**
   * No intersection found with the requested points.
   */
  error: {
    code: 1000;
    message: string;
    data: {
      tip: TipOrOrigin;
    };
  };
  id?: unknown;
}
export interface IntersectionInterleaved {
  jsonrpc: "2.0";
  method: "findIntersection";
  /**
   * An internal error indicating that requests were interleaved in an unexpected way. Shouldn't ever happen.
   */
  error: {
    code: 1001;
    message: string;
  };
  id?: unknown;
}
/**
 * Request next block from the current cardano-node's cursor.
 */
export interface NextBlock {
  jsonrpc: "2.0";
  method: "nextBlock";
  id?: unknown;
}
/**
 * Response to a 'nextBlock' request.
 */
export interface NextBlockResponse {
  jsonrpc: "2.0";
  method: "nextBlock";
  result: RollForward | RollBackward;
  id?: unknown;
}
export interface RollForward {
  direction: "forward";
  tip: Tip;
  block: Block;
}
export interface BlockEBB {
  type: "ebb";
  era: "byron";
  id: DigestBlake2B256;
  ancestor: DigestBlake2B256;
  height: BlockHeight;
}
export interface BlockBFT {
  type: "bft";
  era: "byron";
  id: DigestBlake2B256;
  ancestor: DigestBlake2B256;
  height: BlockHeight;
  slot: Slot;
  size: {
    bytes: UInt64;
  };
  transactions?: Transaction[];
  operationalCertificates?: BootstrapOperationalCertificate[];
  protocol: {
    id: BootstrapProtocolId;
    version: ProtocolVersion;
    software: SoftwareVersion;
    update?: BootstrapProtocolUpdate;
  };
  issuer: {
    verificationKey: ExtendedVerificationKey;
  };
  delegate: {
    verificationKey: ExtendedVerificationKey;
  };
}
export interface Transaction {
  id: DigestBlake2B256;
  spends: "inputs" | "collaterals";
  inputs: TransactionOutputReference[];
  references?: TransactionOutputReference[];
  collaterals?: TransactionOutputReference[];
  totalCollateral?: ValueAdaOnly;
  collateralReturn?: TransactionOutput;
  outputs: TransactionOutput[];
  certificates?: Certificate[];
  withdrawals?: Withdrawals;
  fee?: ValueAdaOnly;
  validityInterval?: ValidityInterval;
  mint?: Assets;
  network?: Network;
  scriptIntegrityHash?: DigestBlake2B256;
  requiredExtraSignatories?: DigestBlake2B224[];
  requiredExtraScripts?: DigestBlake2B224[];
  proposals?: GovernanceProposal[];
  votes?: GovernanceVote[];
  metadata?: Metadata;
  signatories: Signatory[];
  scripts?: {
    [k: string]: Script;
  };
  datums?: {
    [k: string]: Datum;
  };
  redeemers?: Redeemer[];
  treasury?: {
    value?: ValueAdaOnly;
    donation?: ValueAdaOnly;
  };
  /**
   * The raw serialized (CBOR) transaction, as found on-chain. Use --include-transaction-cbor to ALWAYS include the 'cbor' field. Omitted otherwise.
   */
  cbor?: string;
}
export interface TransactionOutputReference {
  transaction: {
    id: TransactionId;
  };
  index: UInt64;
}
export interface ValueAdaOnly {
  ada: {
    lovelace: bigint;
  };
}
/**
 * A transaction output. 'datum' and 'datumHash' are never present together.
 */
export interface TransactionOutput {
  address: Address;
  value: Value;
  datumHash?: DigestBlake2B256;
  datum?: Datum;
  script?: Script;
}
export interface Value {
  ada: {
    lovelace: bigint;
  };
  [k: string]: {
    [k: string]: AssetQuantity;
  };
}
/**
 * A Cardano native script. Use --include-script-cbor to ALWAYS include the 'cbor' field. Omitted otherwise.
 */
export interface Native {
  language: "native";
  json: ScriptNative;
  cbor?: string;
}
export interface ClauseSignature {
  clause: "signature";
  from: DigestBlake2B224;
}
export interface ClauseAny {
  clause: "any";
  from: ScriptNative[];
}
export interface ClauseAll {
  clause: "all";
  from: ScriptNative[];
}
export interface ClauseSome {
  clause: "some";
  atLeast: bigint;
  from: ScriptNative[];
}
export interface ClauseBefore {
  clause: "before";
  slot: Slot;
}
export interface ClauseAfter {
  clause: "after";
  slot: Slot;
}
export interface Plutus {
  language: "plutus:v1" | "plutus:v2" | "plutus:v3";
  cbor: string;
}
/**
 * A stake delegation certificate, from a delegator to a stake pool and/or a delegate representative.
 */
export interface StakeDelegation {
  type: "stakeDelegation";
  from: CredentialOrigin;
  credential: DigestBlake2B224;
  stakePool?: {
    id: StakePoolId;
  };
  delegateRepresentative?: DelegateRepresentative;
}
export interface DelegateRepresentativeRegistered {
  id: DigestBlake2B224;
  from: CredentialOrigin;
  type: "registered";
}
export interface DelegateRepresentativeNoConfidence {
  /**
   * A special delegate representative which always vote no, except on votes of no-confidence.
   */
  type: "noConfidence";
}
export interface DelegateRepresentativeAbstain {
  /**
   * A special delegate representative which always abstain.
   */
  type: "abstain";
}
/**
 * A stake credential (key or script) registration certificate. The field 'deposit' is only *optionally* present in Conway onwards.
 */
export interface StakeCredentialRegistration {
  type: "stakeCredentialRegistration";
  from: CredentialOrigin;
  credential: DigestBlake2B224;
  deposit?: ValueAdaOnly;
}
/**
 * A stake key de-registration certificate. The field 'deposit' is only *optionally* present in Conway onwards.
 */
export interface StakeCredentialDeregistration {
  type: "stakeCredentialDeregistration";
  from: CredentialOrigin;
  credential: DigestBlake2B224;
  deposit?: ValueAdaOnly;
}
/**
 * A stake pool registration certificate.
 */
export interface StakePoolRegistration {
  type: "stakePoolRegistration";
  stakePool: StakePool;
}
export interface StakePool {
  id: StakePoolId;
  vrfVerificationKeyHash: DigestBlake2B256;
  owners: DigestBlake2B224[];
  cost: ValueAdaOnly;
  margin: Ratio;
  pledge: ValueAdaOnly;
  rewardAccount: RewardAccount;
  metadata?: Anchor;
  relays: Relay[];
}
export interface Anchor {
  hash: DigestAny;
  url: string;
}
export interface RelayByAddress {
  type: "ipAddress";
  ipv4?: string;
  ipv6?: string;
  port?: number;
}
export interface RelayByName {
  type: "hostname";
  hostname: string;
  port?: number;
}
/**
 * A stake pool retirement certificate.
 */
export interface StakePoolRetirement {
  type: "stakePoolRetirement";
  stakePool: {
    retirementEpoch: Epoch;
    id: StakePoolId;
  };
}
export interface GenesisDelegation {
  type: "genesisDelegation";
  delegate: GenesisDelegate;
  issuer: {
    id: DigestBlake2B224;
  };
}
/**
 * A Genesis delegate, in charge of Cardano's governance.
 */
export interface GenesisDelegate {
  id: DigestBlake2B224;
  vrfVerificationKeyHash: DigestBlake2B256;
}
/**
 * A constitutional committee member delegates a hot credential for voting on-chain. Constitutional committee members do not vote with their cold key directly. New registrations supersedes any preceding ones.
 */
export interface ConstitutionalCommitteeDelegation {
  type: "constitutionalCommitteeDelegation";
  member: {
    id: DigestBlake2B224;
    from: CredentialOrigin;
  };
  delegate: ConstitutionalCommitteeDelegate;
}
/**
 * A constitutional committee member resigns from the committee.
 */
export interface ConstitutionalCommitteeRetirement {
  type: "constitutionalCommitteeRetirement";
  member: {
    id: DigestBlake2B224;
    from: CredentialOrigin;
  };
  metadata?: Anchor;
}
/**
 * A delegate representative registration. Note that this is only possible for 'registered' representatives and not for well-known ones (abstain & noConfidence)
 */
export interface DelegateRepresentativeRegistration {
  type: "delegateRepresentativeRegistration";
  delegateRepresentative: DelegateRepresentative;
  deposit: ValueAdaOnly;
  metadata?: Anchor;
}
export interface DelegateRepresentativeUpdate {
  type: "delegateRepresentativeUpdate";
  delegateRepresentative: DelegateRepresentative;
  metadata: None | Anchor;
}
/**
 * A delegate representative retirement. Note that this is only possible for 'registered' representatives and not for well-known ones (abstain & noConfidence)
 */
export interface DelegateRepresentativeRetirement {
  type: "delegateRepresentativeRetirement";
  delegateRepresentative: DelegateRepresentative;
  deposit: ValueAdaOnly;
}
export interface Withdrawals {
  [k: string]: ValueAdaOnly;
}
export interface ValidityInterval {
  invalidBefore?: Slot;
  invalidAfter?: Slot;
}
export interface Assets {
  [k: string]: {
    [k: string]: AssetQuantity;
  };
}
export interface GovernanceProposal {
  deposit?: ValueAdaOnly;
  returnAccount?: RewardAccount;
  metadata?: Anchor;
  action:
    | GovernanceActionProtocolParametersUpdate
    | GovernanceActionHardForkInitiation
    | GovernanceActionTreasuryTransfer
    | GovernanceActionTreasuryWithdrawals
    | GovernanceActionConstitutionalCommittee
    | GovernanceActionConstitution
    | GovernanceActionNoConfidence
    | GovernanceActionInformation;
}
/**
 * The 'ancestor' is a reference to the previous governance action of this group. It is optional for the first one and required after so that they all actions of a same group form a chain.
 */
export interface GovernanceActionProtocolParametersUpdate {
  type: "protocolParametersUpdate";
  ancestor?: GovernanceProposalReference;
  parameters: ProposedProtocolParameters;
  guardrails: null | {
    hash: DigestBlake2B224;
  };
}
export interface GovernanceProposalReference {
  transaction: {
    id: TransactionId;
  };
  index: UInt32;
}
export interface ProposedProtocolParameters {
  minFeeCoefficient?: UInt64;
  minFeeConstant?: ValueAdaOnly;
  minFeeReferenceScripts?: {
    range: UInt32;
    base: number;
    multiplier: number;
  };
  minUtxoDepositCoefficient?: UInt64;
  minUtxoDepositConstant?: ValueAdaOnly;
  maxBlockBodySize?: {
    bytes: UInt64;
  };
  maxBlockHeaderSize?: {
    bytes: UInt64;
  };
  maxTransactionSize?: {
    bytes: UInt64;
  };
  maxReferenceScriptsSize?: {
    bytes: UInt64;
  };
  maxValueSize?: {
    bytes: UInt64;
  };
  extraEntropy?: Nonce;
  stakeCredentialDeposit?: ValueAdaOnly;
  stakePoolDeposit?: ValueAdaOnly;
  stakePoolRetirementEpochBound?: UInt64;
  stakePoolPledgeInfluence?: Ratio;
  minStakePoolCost?: ValueAdaOnly;
  desiredNumberOfStakePools?: UInt64;
  federatedBlockProductionRatio?: Ratio;
  monetaryExpansion?: Ratio;
  treasuryExpansion?: Ratio;
  collateralPercentage?: UInt64;
  maxCollateralInputs?: UInt64;
  plutusCostModels?: CostModels;
  scriptExecutionPrices?: ScriptExecutionPrices;
  maxExecutionUnitsPerTransaction?: ExecutionUnits;
  maxExecutionUnitsPerBlock?: ExecutionUnits;
  stakePoolVotingThresholds?: StakePoolVotingThresholds;
  constitutionalCommitteeMinSize?: UInt16;
  constitutionalCommitteeMaxTermLength?: UInt64;
  governanceActionLifetime?: Epoch;
  governanceActionDeposit?: ValueAdaOnly;
  delegateRepresentativeVotingThresholds?: DelegateRepresentativeVotingThresholds;
  delegateRepresentativeDeposit?: ValueAdaOnly;
  delegateRepresentativeMaxIdleTime?: Epoch;
  version?: ProtocolVersion;
}
export interface CostModels {
  [k: string]: CostModel;
}
export interface ScriptExecutionPrices {
  memory: Ratio;
  cpu: Ratio;
}
export interface ExecutionUnits {
  memory: UInt64;
  cpu: UInt64;
}
export interface StakePoolVotingThresholds {
  noConfidence: Ratio;
  constitutionalCommittee: {
    default: Ratio;
    stateOfNoConfidence: Ratio;
  };
  hardForkInitiation: Ratio;
  protocolParametersUpdate: {
    security: Ratio;
  };
}
export interface DelegateRepresentativeVotingThresholds {
  noConfidence: Ratio;
  constitution: Ratio;
  constitutionalCommittee: {
    default: Ratio;
    stateOfNoConfidence: Ratio;
  };
  hardForkInitiation: Ratio;
  protocolParametersUpdate: {
    network: Ratio;
    economic: Ratio;
    technical: Ratio;
    governance: Ratio;
  };
  treasuryWithdrawals: Ratio;
}
export interface ProtocolVersion {
  major: UInt32;
  minor: UInt32;
  patch?: UInt32;
}
export interface GovernanceActionHardForkInitiation {
  type: "hardForkInitiation";
  ancestor?: GovernanceProposalReference;
  version: ProtocolVersion;
}
/**
 * A transfer from or to the treasury / reserves authored by genesis delegates.
 */
export interface GovernanceActionTreasuryTransfer {
  type: "treasuryTransfer";
  source: "reserves" | "treasury";
  target: "reserves" | "treasury";
  value: ValueAdaOnly;
}
/**
 * One of more withdrawals from the treasury.
 */
export interface GovernanceActionTreasuryWithdrawals {
  type: "treasuryWithdrawals";
  withdrawals: RewardTransfer;
  guardrails: null | {
    hash: DigestBlake2B224;
  };
}
export interface RewardTransfer {
  [k: string]: ValueDelta;
}
export interface ValueDelta {
  ada: {
    /**
     * An amount, possibly negative, in Lovelace (1e6 Lovelace = 1 Ada).
     */
    lovelace: number;
  };
}
/**
 * A change (partial or total) in the constitutional committee. The 'ancestor' is a reference to the previous governance action of this group (also includes no confidence actions in this case). It is optional for the first one and required after so that they all actions of a same group form a chain.
 */
export interface GovernanceActionConstitutionalCommittee {
  type: "constitutionalCommittee";
  ancestor?: GovernanceProposalReference;
  members: {
    added: ConstitutionalCommitteeMemberSummary[];
    removed: {
      id: DigestBlake2B224;
      from: CredentialOrigin;
    }[];
  };
  quorum: Ratio;
}
export interface ConstitutionalCommitteeMemberSummary {
  id: DigestBlake2B224;
  from: CredentialOrigin;
  mandate?: Mandate;
}
export interface Mandate {
  epoch: Epoch;
}
/**
 * A change in the constitution. Only its hash is recorded on-chain. The 'ancestor' is a reference to the previous governance action of this group. It is optional for the first one and required after so that they all actions of a same group form a chain.
 */
export interface GovernanceActionConstitution {
  type: "constitution";
  ancestor?: GovernanceProposalReference;
  guardrails: null | {
    hash: DigestBlake2B224;
  };
  metadata: Anchor;
}
/**
 * A motion of no-confidence, indicate a lack of trust in the constitutional committee. The 'ancestor' is a reference to the previous governance action of this group. It is optional for the first one and required after so that they all actions of a same group form a chain.
 */
export interface GovernanceActionNoConfidence {
  type: "noConfidence";
  ancestor?: GovernanceProposalReference;
}
/**
 * An action that has no effect on-chain, other than an on-chain record
 */
export interface GovernanceActionInformation {
  type: "information";
}
/**
 * A vote on a governance proposal. The 'anchor' is optional and 'proposal' is only present from Conway onwards. Before Conway, a vote would always refer to all proposals part of the same transaction.
 */
export interface GovernanceVote {
  issuer: VoterGenesisDelegate | VoterConstitutionalCommittee | VoterDelegateRepresentative | VoterStakePoolOperator;
  metadata?: Anchor;
  vote: "yes" | "no" | "abstain";
  proposal?: GovernanceProposalReference;
}
export interface VoterGenesisDelegate {
  role: "genesisDelegate";
  id: DigestBlake2B224;
  from: CredentialOrigin;
}
export interface VoterConstitutionalCommittee {
  role: "constitutionalCommittee";
  id: DigestBlake2B224;
  from: CredentialOrigin;
}
export interface VoterDelegateRepresentative {
  role: "delegateRepresentative";
  id: DigestBlake2B224;
  from: CredentialOrigin;
}
export interface VoterStakePoolOperator {
  role: "stakePoolOperator";
  id: StakePoolId;
}
export interface Metadata {
  hash: DigestBlake2B256;
  labels: MetadataLabels;
}
export interface MetadataLabels {
  /**
   * An associated metadatum, as a CBOR bytestring or a JSON object if possible. If not possible, default to 'cbor'. Use --include-metadata-cbor to ALWAYS include the cbor field.
   */
  [k: string]: {
    cbor?: string;
    json?: Metadatum;
  };
}
export interface ObjectNoSchema {
  [k: string]: MetadatumNoSchema;
}
export interface IntegerDetailedSchema {
  int: bigint;
}
export interface StringDetailedSchema {
  string: string;
}
export interface BytesDetailedSchema {
  bytes: string;
}
export interface ArrayDetailedSchema {
  list: MetadatumDetailedSchema[];
}
export interface ObjectDetailedSchema {
  map: MetadatumMap[];
}
export interface MetadatumMap {
  k: MetadatumDetailedSchema;
  v: MetadatumDetailedSchema;
}
/**
 * A signatory (EdDSA) for the transaction. The fields 'chainCode' and 'addressAttributes' are only present on bootstrap signatures (when spending from a Byron/Bootstrap address).
 */
export interface Signatory {
  key: VerificationKey;
  signature: Signature;
  chainCode?: ChainCode;
  addressAttributes?: AddressAttributes;
}
export interface Redeemer {
  redeemer: RedeemerData;
  executionUnits: ExecutionUnits;
  validator: RedeemerPointer;
}
export interface RedeemerPointer {
  purpose: "spend" | "mint" | "publish" | "withdraw" | "vote" | "propose";
  index: UInt64;
}
/**
 * A (Byron) delegation certificate.
 */
export interface BootstrapOperationalCertificate {
  issuer: {
    verificationKey: VerificationKey;
  };
  delegate: {
    verificationKey: VerificationKey;
  };
}
export interface SoftwareVersion {
  appName: string;
  number: UInt32;
}
export interface BootstrapProtocolUpdate {
  proposal?: {
    version: ProtocolVersion;
    software: SoftwareVersion;
    parameters: BootstrapProtocolParameters;
    metadata: {
      [k: string]: string;
    };
  };
  votes: BootstrapVote[];
}
export interface BootstrapProtocolParameters {
  heavyDelegationThreshold?: Ratio;
  maxBlockBodySize?: {
    bytes: UInt64;
  };
  maxBlockHeaderSize?: {
    bytes: UInt64;
  };
  maxUpdateProposalSize?: {
    bytes: UInt64;
  };
  maxTransactionSize?: {
    bytes: UInt64;
  };
  multiPartyComputationThreshold?: Ratio;
  scriptVersion?: UInt64;
  slotDuration?: UInt64;
  unlockStakeEpoch?: UInt64;
  updateProposalThreshold?: Ratio;
  updateProposalTimeToLive?: UInt64;
  updateVoteThreshold?: Ratio;
  softForkInitThreshold?: Ratio;
  softForkMinThreshold?: Ratio;
  softForkDecrementThreshold?: Ratio;
  minFeeCoefficient?: UInt64;
  minFeeConstant?: ValueAdaOnly;
}
export interface BootstrapVote {
  voter: {
    verificationKey: VerificationKey;
  };
  proposal: {
    id: DigestBlake2B256;
  };
}
export interface BlockPraos {
  type: "praos";
  era: "shelley" | "allegra" | "mary" | "alonzo" | "babbage" | "conway";
  id: DigestBlake2B256;
  ancestor: DigestBlake2B256 | GenesisHash;
  nonce?: CertifiedVrf;
  height: BlockHeight;
  size: {
    bytes: UInt64;
  };
  slot: Slot;
  transactions?: Transaction[];
  protocol: {
    version: ProtocolVersion;
  };
  issuer: {
    verificationKey: VerificationKey;
    vrfVerificationKey: VerificationKey;
    operationalCertificate: OperationalCertificate;
    leaderValue: CertifiedVrf;
  };
}
export interface CertifiedVrf {
  proof?: VrfProof;
  output?: VrfOutput;
}
/**
 * Certificate identifying a stake pool operator.
 */
export interface OperationalCertificate {
  count: UInt64;
  sigma?: Signature;
  kes: {
    period: UInt64;
    verificationKey: KesVerificationKey;
  };
}
export interface RollBackward {
  direction: "backward";
  tip: TipOrOrigin;
  point: PointOrOrigin;
}
/**
 * Submit a signed and serialized transaction to the network.
 */
export interface SubmitTransaction {
  jsonrpc: "2.0";
  method: "submitTransaction";
  params: {
    transaction: {
      /**
       * CBOR-serialized signed transaction (base16)
       */
      cbor: string;
    };
  };
  id?: unknown;
}
export interface SubmitTransactionSuccess {
  jsonrpc: "2.0";
  method: "submitTransaction";
  result: {
    transaction: {
      id: TransactionId;
    };
  };
  id?: unknown;
}
export interface SubmitTransactionError {
  jsonrpc: "2.0";
  method: "submitTransaction";
  error: SubmitTransactionFailure;
  id?: unknown;
}
/**
 * Failed to submit the transaction in the current era. This may happen when trying to submit a transaction near an era boundary (i.e. at the moment of a hard-fork).
 */
export interface SubmitTransactionFailureEraMismatch {
  code: 3005;
  message: string;
  data: EraMismatch;
}
export interface EraMismatch {
  queryEra: Era;
  ledgerEra: Era;
}
/**
 * Some signatures are invalid. Only the serialised transaction *body*, without metadata or witnesses, must be signed.
 */
export interface SubmitTransactionFailureInvalidSignatories {
  code: 3100;
  message: string;
  data: {
    invalidSignatories: VerificationKey[];
  };
}
/**
 * Some signatures are missing. A signed transaction must carry signatures for all inputs locked by verification keys or a native script. Transaction may also need signatures for each required extra signatories often required by Plutus Scripts.
 */
export interface SubmitTransactionFailureMissingSignatories {
  code: 3101;
  message: string;
  data: {
    missingSignatories: DigestBlake2B224[];
  };
}
/**
 * Some script witnesses are missing. Indeed, any script used in a transaction (when spending, minting, withdrawing or publishing certificates) must be provided in full with the transaction. Scripts must therefore be added either to the witness set or provided as a reference inputs should you use Plutus V2+ and a format from Babbage and beyond.
 */
export interface SubmitTransactionFailureMissingScripts {
  code: 3102;
  message: string;
  data: {
    missingScripts: DigestBlake2B224[];
  };
}
/**
 * The transaction contains failing phase-1 monetary scripts (a.k.a. native scripts). This can be due to either a missing or invalid signature, or because of a time validity issue. The field 'data.failingNativeScripts' contains a list of hash digests of all failing native scripts found in the transaction.
 */
export interface SubmitTransactionFailureFailingNativeScript {
  code: 3103;
  message: string;
  data: {
    failingNativeScripts: DigestBlake2B224[];
  };
}
/**
 * Extraneous (i.e. non-required) scripts found in the transaction. A transaction must not contain scripts that aren't strictly needed for validation, that are present in metadata or that are published in an output. Perhaps you have used provided a wrong script for a validator? Anyway, the 'data.extraneousScripts' field lists hash digests of scripts found to be extraneous.
 */
export interface SubmitTransactionFailureExtraneousScripts {
  code: 3104;
  message: string;
  data: {
    extraneousScripts: DigestBlake2B224[];
  };
}
/**
 * Missing required metadata hash in the transaction body. If the transaction includes metadata, then it must also include a hash digest of these serialised metadata in its body to prevent malicious actors from tempering with the data. The field 'data.metadata.hash' contains the expected missing hash digest of the metadata found in the transaction.
 */
export interface SubmitTransactionFailureMissingMetadataHash {
  code: 3105;
  message: string;
  data: {
    metadata: {
      hash: DigestBlake2B256;
    };
  };
}
/**
 * No metadata corresponding to a specified metadata hash. It appears that you might have forgotten to attach metadata to a transaction, yet included a hash digest of them in the transaction body? The field 'data.metadata.hash' contains the orphan hash found in the body.
 */
export interface SubmitTransactionFailureMissingMetadata {
  code: 3106;
  message: string;
  data: {
    metadata: {
      hash: DigestBlake2B256;
    };
  };
}
/**
 * There's a mismatch between the provided metadata hash digest and the one computed from the actual metadata. The two must match exactly. The field 'data.provided.hash' references the provided hash as found in the transaction body, whereas 'data.computed.hash' contains the one the ledger computed from the actual metadata.
 */
export interface SubmitTransactionFailureMetadataHashMismatch {
  code: 3107;
  message: string;
  data: {
    provided: {
      hash: DigestBlake2B256;
    };
    computed: {
      hash: DigestBlake2B256;
    };
  };
}
/**
 * Invalid metadatum found in transaction metadata. Metadata byte strings must be no longer than 64-bytes and text strings must be no longer than 64 bytes once UTF-8-encoded. Some metadatum in the transaction infringe this rule.
 */
export interface SubmitTransactionFailureInvalidMetadata {
  code: 3108;
  message: string;
}
/**
 * Missing required redeemer(s) for Plutus scripts. There are validators needed for the transaction that do not have an associated redeemer. Redeemer are provided when trying to execute the validation logic of a script (e.g. when spending from an input locked by a script, or minting assets from a Plutus monetary policy. The field 'data.missingRedeemers' lists the different purposes for which a redeemer hasn't been provided.
 */
export interface SubmitTransactionFailureMissingRedeemers {
  code: 3109;
  message: string;
  data: {
    missingRedeemers: ScriptPurpose[];
  };
}
export interface ScriptPurposeSpend {
  purpose: "spend";
  outputReference: TransactionOutputReference;
}
export interface ScriptPurposeMint {
  purpose: "mint";
  policy: PolicyId;
}
export interface ScriptPurposePublish {
  purpose: "publish";
  certificate: Certificate;
}
export interface ScriptPurposeWithdraw {
  purpose: "withdraw";
  rewardAccount: RewardAccount;
}
export interface ScriptPurposePropose {
  purpose: "propose";
  proposal: GovernanceProposal;
}
export interface ScriptPurposeVote {
  purpose: "vote";
  issuer: VoterGenesisDelegate | VoterConstitutionalCommittee | VoterDelegateRepresentative | VoterStakePoolOperator;
}
/**
 * Extraneous (non-required) redeemers found in the transaction. There are some redeemers that aren't pointing to any script. This could be because you've left some orphan redeemer behind, because they are pointing at the wrong thing or because you forgot to include their associated validator. Either way, the field 'data.extraneousRedeemers' lists the different orphan redeemer pointers.
 */
export interface SubmitTransactionFailureExtraneousRedeemers {
  code: 3110;
  message: string;
  data: {
    extraneousRedeemers: RedeemerPointer[];
  };
}
/**
 * Transaction failed because some Plutus scripts are missing their associated datums. 'data.missingDatums' contains a set of data hashes for the missing datums. Ensure all Plutus scripts have an associated datum in the transaction's witness set or, are provided through inline datums in reference inputs.
 */
export interface SubmitTransactionFailureMissingDatums {
  code: 3111;
  message: string;
  data: {
    missingDatums: DigestBlake2B256[];
  };
}
/**
 * The transaction failed because it contains datums not associated with any script or output. This could be because you've left some orphan datum behind, because you've listed the wrong inputs in the transaction or because you've just forgotten to include a datum associated with an input. Either way, the field 'data.extraneousDatums' contains a set of data hashes for these extraneous datums.
 */
export interface SubmitTransactionFailureExtraneousDatums {
  code: 3112;
  message: string;
  data: {
    extraneousDatums: DigestBlake2B256[];
  };
}
/**
 * The transaction failed because the provided script integrity hash doesn't match the computed one. This is crucial for ensuring the integrity of cost models and Plutus version used during script execution. The field 'data.providedScriptIntegrity' correspond to what was given, if any, and 'data.computedScriptIntegrity' is what was expected. If the latter is null, this means you shouldn't have included a script integrity hash to begin with.
 */
export interface SubmitTransactionFailureScriptIntegrityHashMismatch {
  code: 3113;
  message: string;
  data: {
    providedScriptIntegrity: DigestBlake2B256 | null;
    computedScriptIntegrity: DigestBlake2B256 | null;
  };
}
/**
 * This is bad, you're trying to spend inputs that are locked by Plutus scripts, but have no associated datums. Those inputs are so-to-speak unspendable (at least with the current ledger rules). There's nothing you can do apart from re-creating these UTxOs but with a corresponding datum this time. The field 'data.orphanScriptInputs' lists all such inputs found in the transaction.
 */
export interface SubmitTransactionFailureOrphanScriptInputs {
  code: 3114;
  message: string;
  data: {
    orphanScriptInputs: TransactionOutputReference[];
  };
}
/**
 * It seems like the transaction is using a Plutus version for which there's no available cost model yet. This could be because that language version is known of the ledger but hasn't yet been enabled through hard-fork. The field 'data.missingCostModels' lists all the languages for which a cost model is missing.
 */
export interface SubmitTransactionFailureMissingCostModels {
  code: 3115;
  message: string;
  data: {
    missingCostModels: Language[];
  };
}
/**
 * Some Plutus scripts in the witness set or in an output are invalid. Scripts must be well-formed flat-encoded Plutus scripts, CBOR-encoded. Yes, there's a double binary encoding. The outer-most encoding is therefore just a plain CBOR bytestring. Note that some tools such as the cardano-cli triple encode scripts for some reasons, resulting in a double outer-most CBOR encoding. Make sure that your script are correctly encoded. The field 'data.malformedScripts' lists the hash digests of all the problematic scripts.
 */
export interface SubmitTransactionFailureMalformedScripts {
  code: 3116;
  message: string;
  data: {
    malformedScripts: DigestBlake2B224[];
  };
}
/**
 * The transaction contains unknown UTxO references as inputs. This can happen if the inputs you're trying to spend have already been spent, or if you've simply referred to non-existing UTxO altogether. The field 'data.unknownOutputReferences' indicates all unknown inputs.
 */
export interface SubmitTransactionFailureUnknownOutputReferences {
  code: 3117;
  message: string;
  data: {
    unknownOutputReferences: TransactionOutputReference[];
  };
}
/**
 * The transaction is outside of its validity interval. It was either submitted too early or too late. A transaction that has a lower validity bound can only be accepted by the ledger (and make it to the mempool) if the ledger's current slot is greater than the specified bound. The upper bound works similarly, as a time to live. The field 'data.currentSlot' contains the current slot as known of the ledger (this may be different from the current network slot if the ledger is still catching up). The field 'data.validityInterval' is a reminder of the validity interval provided with the transaction.
 */
export interface SubmitTransactionFailureOutsideOfValidityInterval {
  code: 3118;
  message: string;
  data: {
    validityInterval: ValidityInterval;
    currentSlot: Slot;
  };
}
/**
 * The transaction exceeds the maximum size allowed by the protocol. Indeed, once serialized, transactions must be under a bytes limit specified by a protocol parameter. The field 'data.measuredTransactionSize' indicates the actual measured size of your serialized transaction, whereas 'data.maximumTransactionSize' indicates the current maximum size enforced by the ledger.
 */
export interface SubmitTransactionFailureTransactionTooLarge {
  code: 3119;
  message: string;
  data: {
    measuredTransactionSize: {
      bytes: UInt64;
    };
    maximumTransactionSize: {
      bytes: UInt64;
    };
  };
}
/**
 * Some output values in the transaction are too large. Once serialized, values must be below a certain threshold. That threshold sits around 4 KB during the Mary era, and was then made configurable as a protocol parameter in later era. The field 'data.excessivelyLargeOutputs' lists all transaction outputs with values that are above the limit.
 */
export interface SubmitTransactionFailureValueTooLarge {
  code: 3120;
  message: string;
  data: {
    excessivelyLargeOutputs: TransactionOutput[];
  };
}
/**
 * Transaction must have at least one input, but this one has an empty input set. One input is necessary to prevent replayability of transactions, as it piggybacks on the unique spendable property of UTxO.
 */
export interface SubmitTransactionFailureEmptyInputSet {
  code: 3121;
  message: string;
}
/**
 * Insufficient fee! The transaction doesn't not contain enough fee to cover the minimum required by the protocol. Note that fee depends on (a) a flat cost fixed by the protocol, (b) the size of the serialized transaction, (c) the budget allocated for Plutus script execution. The field 'data.minimumRequiredFee' indicates the minimum required fee whereas 'data.providedFee' refers to the fee currently supplied with the transaction.
 */
export interface SubmitTransactionFailureTransactionFeeTooSmall {
  code: 3122;
  message: string;
  data: {
    minimumRequiredFee: ValueAdaOnly;
    providedFee: ValueAdaOnly;
  };
}
/**
 * In and out value not conserved. The transaction must *exactly* balance: every input must be accounted for. There are various things counting as 'in balance': (a) the total value locked by inputs (or collateral inputs in case of a failing script), (b) rewards coming from withdrawals and (c) return deposits from stake credential or pool de-registration. In a similar fashion, various things count towards the 'out balance': (a) the total value assigned to each transaction output, (b) the fee and (c) any deposit for stake credential or pool registration. The field 'data.valueConsumed' contains the total 'in balance', and 'data.valueProduced' indicates the total amount counting as 'out balance'.
 */
export interface SubmitTransactionFailureValueNotConserved {
  code: 3123;
  message: string;
  data: {
    valueConsumed: Value;
    valueProduced: Value;
  };
}
/**
 * Some discriminated entities in the transaction are configured for another network. In fact, payment addresses, stake addresses and stake pool registration certificates are bound to a specific network identifier. This identifier must match the network you're trying to submit them to. Since the Alonzo era, transactions themselves may also contain a network identifier. The field 'data.expectedNetwork' indicates what is the currrently expected network. The field 'data.discriminatedType' indicates what type of entity is causing an issue here. And 'data.invalidEntities' lists all the culprits found in the transaction. The latter isn't present when the transaction's network identifier itself is wrong.
 */
export interface SubmitTransactionFailureNetworkMismatch {
  code: 3124;
  message: string;
  data:
    | {
        expectedNetwork: Network;
        discriminatedType: "address";
        invalidEntities: Address[];
      }
    | {
        expectedNetwork: Network;
        discriminatedType: "rewardAccount";
        invalidEntities: RewardAccount[];
      }
    | {
        expectedNetwork: Network;
        discriminatedType: "stakePoolCertificate";
        invalidEntities: StakePoolId[];
      }
    | {
        expectedNetwork: Network;
        discriminatedType: "transaction";
      };
}
/**
 * Some outputs have an insufficient amount of Ada attached to them. In fact, any new output created in a system must pay for the resources it occupies. Because user-created assets are worthless (from the point of view of the protocol), those resources must be paid in the form of a Ada deposit. The exact depends on the size of the serialized output: the more assets, the higher the amount. The field 'data.insufficientlyFundedOutputs.[].output' contains a list of all transaction outputs that are insufficiently funded. Starting from the Babbage era, the field 'data.insufficientlyFundedOutputs.[].minimumRequiredValue' indicates the required amount of Lovelace (1e6 Lovelace = 1 Ada) needed for each output.
 */
export interface SubmitTransactionFailureInsufficientlyFundedOutputs {
  code: 3125;
  message: string;
  data: {
    insufficientlyFundedOutputs: {
      output: TransactionOutput;
      minimumRequiredValue?: ValueAdaOnly;
    }[];
  };
}
/**
 * Some output associated with legacy / bootstrap (a.k.a. Byron) addresses have attributes that are too large. The field 'data.bootstrapOutputs' lists all affected outputs.
 */
export interface SubmitTransactionFailureBootstrapAttributesTooLarge {
  code: 3126;
  message: string;
  data: {
    bootstrapOutputs: TransactionOutput[];
  };
}
/**
 * The transaction is attempting to mint or burn Ada tokens. That is, fortunately, not allowed by the ledger.
 */
export interface SubmitTransactionFailureMintingOrBurningAda {
  code: 3127;
  message: string;
}
/**
 * Insufficient collateral value for Plutus scripts in the transaction. Indeed, when executing scripts, you must provide a collateral amount which minimum is a percentage of the total execution budget for the transaction. The exact percentage is given by a protocol parameter. The field 'data.providedCollateral' indicates the amount currently provided as collateral in the transaction, whereas 'data.minimumRequiredCollateral' indicates the minimum amount expected by the ledger
 */
export interface SubmitTransactionFailureInsufficientCollateral {
  code: 3128;
  message: string;
  data: {
    providedCollateral: ValueDelta;
    minimumRequiredCollateral: ValueAdaOnly;
  };
}
/**
 * Invalid choice of collateral: an input provided for collateral is locked by script. Collateral inputs must be spendable, and the ledger must be able to assert their validity during the first phase of validations (a.k.a phase-1). This discards any input locked by a Plutus script to be used as collateral. Note that for some reason inputs locked by native scripts are also excluded from candidates collateral. The field 'data.unsuitableCollateralInputs' lists all the problematic output references.
 */
export interface SubmitTransactionFailureCollateralLockedByScript {
  code: 3129;
  message: string;
  data: {
    unsuitableCollateralInputs: TransactionOutputReference[];
  };
}
/**
 * One of the transaction validity bound is outside any foreseeable future. The vision of the ledger in the future when evaluating Plutus scripts is limited because the ledger cannot guarantee that the chain will not hard-fork into a version of the protocol working with a different set of parameters (or even, working with the same consensus protocol). However, the protocol cannot fork in less than `k` blocks, where `k` is the security parameter of the chain. Plus, Ouroboros Praos ensures that there are at least `k` blocks produced in a window of 3 * k / f slots, where `f` is the density parameter, also known as the active slot coefficient. Short story short, you can only set validity interval in a short timespan, which is around ~36h in the future on Mainnet at the moment of writing this error message. The field 'data.unforeseeableSlot' indicates the slot which couldn't be converted to a POSIX time due to hard fork uncertainty.
 */
export interface SubmitTransactionFailureUnforeseeableSlot {
  code: 3130;
  message: string;
  data: {
    unforeseeableSlot: Slot;
  };
}
/**
 * The transaction contains too many collateral inputs. The maximum number of collateral inputs is constrained by a protocol parameter. The field 'data.maximumCollateralInputs' contains the current value of that parameter, and 'data.countedCollateralInputs' indicates how many inputs were actually found in your transaction.
 */
export interface SubmitTransactionFailureTooManyCollateralInputs {
  code: 3131;
  message: string;
  data: {
    maximumCollateralInputs: UInt32;
    countedCollateralInputs: UInt32;
  };
}
/**
 * The transaction doesn't provide any collateral inputs but it must. Indeed, when executing scripts, you must provide a collateral amount which is collected by the ledger in case of script execution failure. That collateral serves as a compensation for nodes that aren't thus able to collect normal fees set on the transaction. Note that ledger validations are split in two phases. The first phase regards pretty much every validation outside of script executions. Anything from the first phase doesn't require a collateral and will not consume the collateral in case of failure because they require little computing resources. Besides, in principle, any client application or wallet will prevent you from submitting an invalid transaction to begin with.
 */
export interface SubmitTransactionFailureMissingCollateralInputs {
  code: 3132;
  message: string;
}
/**
 * One of the input provided as collateral carries something else than Ada tokens. Only Ada can be used as collateral. Since the Babbage era, you also have the option to set a 'collateral return' or 'collateral change' output in order to send the surplus non-Ada tokens to it. Regardless, the field 'data.unsuitableCollateralValue' indicates the actual collateral value found by the ledger
 */
export interface SubmitTransactionFailureNonAdaCollateral {
  code: 3133;
  message: string;
  data: {
    unsuitableCollateralValue: Value;
  };
}
/**
 * The transaction execution budget for scripts execution is above the allowed limit. The protocol limits the amount of execution that a single transaction can do. This limit is set by a protocol parameter. The field 'data.maximumExecutionUnits' indicates the current limit and the field 'data.providedExecutionUnits' indicates how much the transaction requires.
 */
export interface SubmitTransactionFailureExecutionUnitsTooLarge {
  code: 3134;
  message: string;
  data: {
    providedExecutionUnits: ExecutionUnits;
    maximumExecutionUnits: ExecutionUnits;
  };
}
/**
 * There's a mismatch between the declared total collateral amount, and the value computed from the inputs and outputs. These must match exactly. The field 'data.declaredTotalCollateral' reports the amount declared in the transaction whereas 'data.computedTotalCollateral' refers to the amount actually computed.
 */
export interface SubmitTransactionFailureTotalCollateralMismatch {
  code: 3135;
  message: string;
  data: {
    declaredTotalCollateral: ValueAdaOnly;
    computedTotalCollateral: ValueDelta;
  };
}
/**
 * Invalid transaction submitted as valid, or vice-versa. Since Alonzo, the ledger may allow invalid transactions to be submitted and included on-chain, provided that they leave a collateral value as compensation. This prevent certain class of attacks. As a consequence, transactions now have a validity tag with them. Your transaction did not match what that validity tag is stating. The field 'data.declaredSpending' indicates what the transaction is supposed to consume (collaterals or inputs) and the field 'data.mismatchReason' provides more information about the mismatch.
 */
export interface SubmitTransactionFailureSpendsMismatch {
  code: 3136;
  message: string;
  data: {
    declaredSpending: "inputs" | "collaterals";
    mismatchReason: string;
  };
}
/**
 * The transaction contains votes from unauthorized voters. The field 'data.unauthorizedVotes' indicates the faulty voters and the action they attempted to incorrectly vote for.
 */
export interface SubmitTransactionFailureUnauthorizedVotes {
  code: 3137;
  message: string;
  data: {
    unauthorizedVotes: {
      proposal: GovernanceProposalReference;
      voter: VoterGenesisDelegate | VoterConstitutionalCommittee | VoterDelegateRepresentative | VoterStakePoolOperator;
    }[];
  };
}
/**
 * Reference(s) to unknown governance proposals found in transaction. This may be because you've indicated a wrong identifier or because the proposal hasn't yet been submitted on-chain. Note that the order in which transactions are submitted matters. The field 'data.unknownProposals' tells you about the unknown references.
 */
export interface SubmitTransactionFailureUnknownGovernanceProposals {
  code: 3138;
  message: string;
  data: {
    unknownProposals: GovernanceProposalReference[];
  };
}
/**
 * The transaction contains an invalid or unauthorized protocol parameters update. This operation is reserved to genesis key holders.
 */
export interface SubmitTransactionFailureInvalidProtocolParametersUpdate {
  code: 3139;
  message: string;
}
/**
 * The transaction references an unknown stake pool as a target for delegation or update. Double-check the pool id mentioned in 'data.unknownStakePool'. Note also that order in which transactions are submitted matters; if you're trying to register a pool and delegate to it in one go, make sure to submit transactions in the right order.
 */
export interface SubmitTransactionFailureUnknownStakePool {
  code: 3140;
  message: string;
  data: {
    unknownStakePool: StakePoolId;
  };
}
/**
 * The transaction contains incomplete or invalid rewards withdrawals. When present, rewards withdrawals must consume rewards in full, there cannot be any leftover. The field 'data.incompleteWithdrawals' contains a map of withdrawals and their current rewards balance.
 */
export interface SubmitTransactionFailureIncompleteWithdrawals {
  code: 3141;
  message: string;
  data: {
    incompleteWithdrawals: Withdrawals;
  };
}
/**
 * A stake pool retirement certificate is trying to retire too late in the future. Indeed, there's a maximum delay for stake pool retirement, controlled by a protocol parameter. The field 'data.currentEpoch' indicates the current epoch known of the ledger, 'data.declaredEpoch' refers to the epoch declared in the retirement certificate and 'data.firstInvalidEpoch' is the first epoch considered invalid (too far) for retirement
 */
export interface SubmitTransactionFailureRetirementTooLate {
  code: 3142;
  message: string;
  data: {
    currentEpoch: Epoch;
    declaredEpoch: Epoch;
    firstInvalidEpoch: Epoch;
  };
}
/**
 * Stake pool cost declared in a registration or update certificate are below the allowed minimum. The minimum cost of a stake pool is fixed by a protocol parameter. The 'data.minimumStakePoolCost' field holds the current value of that parameter whereas 'data.declaredStakePoolCost' indicates which amount was declared.
 */
export interface SubmitTransactionFailureStakePoolCostTooLow {
  code: 3143;
  message: string;
  data: {
    minimumStakePoolCost: ValueAdaOnly;
    declaredStakePoolCost: ValueAdaOnly;
  };
}
/**
 * Some hash digest of (optional) stake pool metadata is too long. When registering, stake pools can supply an external metadata file and a hash digest of the content. The hashing algorithm is left open but the output digest must be smaller than 32 bytes. The field 'data.infringingStakePool' indicates which stake pool has an invalid metadata hash and 'data.computedMetadataHashSize' documents the computed hash size.
 */
export interface SubmitTransactionFailureMetadataHashTooLarge {
  code: 3144;
  message: string;
  data: {
    infringingStakePool: {
      id: StakePoolId;
    };
    computedMetadataHashSize: {
      bytes: UInt64;
    };
  };
}
/**
 * Trying to re-register some already known credentials. Stake credentials can only be registered once. This is true for both keys and scripts. The field 'data.knownCredential' points to an already known credential that's being re-registered by this transaction.
 */
export interface SubmitTransactionFailureCredentialAlreadyRegistered {
  code: 3145;
  message: string;
  data: {
    knownCredential: DigestBlake2B224;
    from: CredentialOrigin;
  };
}
/**
 * The transaction references an unknown stake credential. For example, to delegate to a stake pool, you must first register the stake key or script used for delegation. This may be done in the same transaction or in an earlier transaction but cannot happen retro-actively. The field 'data.unknownCredential' indicates what credential is used without being registered.
 */
export interface SubmitTransactionFailureUnknownCredential {
  code: 3146;
  message: string;
  data: {
    unknownCredential: DigestBlake2B224;
    from: CredentialOrigin;
  };
}
/**
 * Trying to unregister stake credentials associated to a non empty reward account. You must empty the reward account first (or do it as part of the same transaction) to proceed. The field 'data.nonEmptyRewardAccountBalance' indicates how much Lovelace is left in the account.
 */
export interface SubmitTransactionFailureNonEmptyRewardAccount {
  code: 3147;
  message: string;
  data: {
    nonEmptyRewardAccountBalance: ValueAdaOnly;
  };
}
/**
 * Invalid or unauthorized genesis delegation. The genesis delegate is unknown, invalid or already in use.
 */
export interface SubmitTransactionFailureInvalidGenesisDelegation {
  code: 3148;
  message: string;
}
/**
 * Invalid MIR transfer. The resulting delta is likely negative.
 */
export interface SubmitTransactionFailureInvalidMIRTransfer {
  code: 3149;
  message: string;
}
/**
 * The transaction is attempting to withdraw rewards from stake credentials that do not engage in on-chain governance. Credentials must be associated with a delegate representative (registered, abstain or noConfidence) before associated rewards can be withdrawn. The field 'data.marginalizedCredentials' lists all the affected credentials.
 */
export interface SubmitTransactionFailureForbiddenWithdrawal {
  code: 3150;
  message: string;
  data: {
    marginalizedCredentials: DigestBlake2B224[];
  };
}
/**
 * The deposit specified in a stake credential registration (for delegation or governance) does not match the current value set by protocol parameters. The field 'data.expectedDeposit', when present, indicates the deposit amount as currently expected by ledger.
 */
export interface SubmitTransactionFailureCredentialDepositMismatch {
  code: 3151;
  message: string;
  data: {
    providedDeposit: ValueAdaOnly;
    expectedDeposit?: ValueAdaOnly;
  };
}
/**
 * Trying to re-register some already known delegate representative. Delegate representatives can only be registered once. The field 'data.knownDelegateRepresentatives' points to an already known credential that's being re-registered by this transaction.
 */
export interface SubmitTransactionFailureDRepAlreadyRegistered {
  code: 3152;
  message: string;
  data: {
    knownDelegateRepresentative: DelegateRepresentative;
  };
}
/**
 * The transaction references an unknown delegate representative. To delegate to a representative, it must first register as such. This may be done in the same transaction or in an earlier transaction but cannot happen retro-actively. The field 'data.unknownDelegateRepresentative' indicates what credential is used without being registered.
 */
export interface SubmitTransactionFailureDRepNotRegistered {
  code: 3153;
  message: string;
  data: {
    unknownDelegateRepresentative: DelegateRepresentative;
  };
}
/**
 * The transaction references an unknown constitutional committee member. This can be either because that member does not actually exist or because it was registered but has resigned. The field 'data.unknownConstitutionalCommitteeMember' indicates what credential is unknown.
 */
export interface SubmitTransactionFailureUnknownConstitutionalCommitteeMember {
  code: 3154;
  message: string;
  data: {
    unknownConstitutionalCommitteeMember: {
      id: DigestBlake2B224;
      from: CredentialOrigin;
    };
  };
}
/**
 * There's a mismatch between the proposal deposit amount declared in the transaction and the one expected by the ledger. The deposit is actually configured by a protocol parameter. The field 'data.expectedDeposit' indicates the current configuration and amount expected by the ledger. The field 'data.providedDeposit' is a reminder of the what was set in the submitted transaction.
 */
export interface SubmitTransactionFailureGovernanceProposalDepositMismatch {
  code: 3155;
  message: string;
  data: {
    providedDeposit: ValueAdaOnly;
    expectedDeposit: ValueAdaOnly;
  };
}
/**
 * The transaction contains an invalid governance action: it tries to both add members to the committee and remove some of those same members. The field 'data.conflictingMembers' indicates which members are found on both sides.
 */
export interface SubmitTransactionFailureConflictingCommitteeUpdate {
  code: 3156;
  message: string;
  data: {
    conflictingMembers: {
      id: DigestBlake2B224;
      from: CredentialOrigin;
    }[];
  };
}
/**
 * The transaction contains an invalid governance action: it tries to add new members to the constitutional committee with a retirement epoch in the past. The field 'data.alreadyRetiredMembers' indicates the faulty members that would otherwise be already retired.
 */
export interface SubmitTransactionFailureInvalidCommitteeUpdate {
  code: 3157;
  message: string;
  data: {
    alreadyRetiredMembers: {
      id: DigestBlake2B224;
      from: CredentialOrigin;
    }[];
  };
}
/**
 * The transaction is trying to withdraw more funds than specified in a governance action! The field 'data.providedWithdrawal' indicates the amount specified in the transaction, whereas 'data.computedWithdrawal' is the actual amount as computed by the ledger.
 */
export interface SubmitTransactionFailureTreasuryWithdrawalMismatch {
  code: 3158;
  message: string;
  data: {
    providedWithdrawal: ValueAdaOnly;
    computedWithdrawal: ValueAdaOnly;
  };
}
/**
 * The transaction contains invalid or missing reference to previous (ratified) governance proposals. Indeed, some governance proposals such as protocol parameters update or consitutional committee change must point to last action of the same purpose that was ratified. The field 'data.invalidOrMissingPreviousProposals' contains a list of submitted actions that are missing details. For each item, we provide the anchor of the corresponding proposal, the type of previous proposal that is expected and the invalid proposal reference if relevant.
 */
export interface SubmitTransactionFailureInvalidOrMissingPreviousProposals {
  code: 3159;
  message: string;
  data: {
    invalidOrMissingPreviousProposals: {
      metadata: Anchor;
      type: "hardForkInitiation" | "protocolParametersUpdate" | "constitutionalCommittee" | "constitution";
      invalidPreviousProposal?: GovernanceProposalReference;
    }[];
  };
}
/**
 * The transaction contains votes for an expired proposal. The field 'data.invalidVotes' indicates the faulty voters and the proposal they attempted to vote for.
 */
export interface SubmitTransactionFailureVotingOnExpiredActions {
  code: 3160;
  message: string;
  data: {
    invalidVotes: {
      proposal: GovernanceProposalReference;
      voter: VoterGenesisDelegate | VoterConstitutionalCommittee | VoterDelegateRepresentative | VoterStakePoolOperator;
    }[];
  };
}
/**
 * The transaction ran out of execution budget! This means that the budget granted for the execution of a particular script was too small or exceeding the maximum value allowed by the protocol. The field 'data.budgetUsed' indicates the actual execution units used by the validator before it was interrupted.
 */
export interface SubmitTransactionFailureExecutionBudgetOutOfBounds {
  code: 3161;
  message: string;
  data: {
    budgetUsed: ExecutionUnits;
  };
}
/**
 * The new proposed version for a hard-fork isn't a valid version bump. The version (major, minor, patch) follows strict rules which can be summarized as follow: (1) the new triplet must be greater than the current one in the usual order of priorities (i.e. 'major' -> 'minor' -> 'patch'), (2) 'minor' must be 0 if 'major' is bumped, (3) 'minor' can only be bumped in increments of 1 and only if 'major' isn't bumped and (4) 'major' can only be bumped in increments of 1. The field 'data.proposedVersion' indicates the (invalid) version in the submitted proposal whereas 'data.currentVersion' indicates the current protocol version.
 */
export interface SubmitTransactionFailureInvalidHardForkVersionBump {
  code: 3162;
  message: string;
  data: {
    proposedVersion: ProtocolVersion;
    currentVersion: ProtocolVersion;
  };
}
/**
 * The provided constitution guardrails hash doesn't match the expected on defined in the constitution. Some governance actions such as treasury withdrawals or protocol parameters updates must correctly refer to the constitution guardrails hash digest. The latter can be 'null'. The field 'data.providedHash' indicates the hash provided in the proposal, and the field 'data.expectedHash' the one specified in the constitution
 */
export interface SubmitTransactionFailureConstitutionGuardrailsHashMismatch {
  code: 3163;
  message: string;
  data: {
    providedHash: null | DigestBlake2B224;
    expectedHash: null | DigestBlake2B224;
  };
}
/**
 * Identical UTxO references were found in both the transaction inputs and references. This is redundant and no longer allowed by the ledger. Indeed, if the a UTxO is present in the inputs set, it is already in the transaction context. The field 'data.conflictingReferences' contains the culprit references present in both sets.
 */
export interface SubmitTransactionFailureConflictingInputsAndReferences {
  code: 3164;
  message: string;
  data: {
    conflictingReferences: TransactionOutputReference[];
  };
}
/**
 * The ledger is still in a bootstrapping phase. During that phase, only protocol parameters changes, hard fork initiations and info actions are authorized. The transaction contains other types of governance action and was therefore rejected
 */
export interface SubmitTransactionFailureUnauthorizedGovernanceAction {
  code: 3165;
  message: string;
}
export interface SubmitTransactionFailureReferenceScriptsTooLarge {
  code: 3166;
  message: string;
  data: {
    measuredReferenceScriptsSize: {
      bytes: UInt64;
    };
    maximumReferenceScriptsSize: {
      bytes: UInt64;
    };
  };
}
/**
 * Some voters in the transaction are unknown. Voters must correspond to registered credentials present in the ledger. They can possibly be registered in the same block, but it must imperatively happens before they are used for voting. The field 'data.unknownVoters' indicates the credentials that couldn't be mapped to any known voter.
 */
export interface SubmitTransactionFailureUnknownVoters {
  code: 3167;
  message: string;
  data: {
    unknownVoters: (
      | VoterGenesisDelegate
      | VoterConstitutionalCommittee
      | VoterDelegateRepresentative
      | VoterStakePoolOperator
    )[];
  };
}
/**
 * Some proposals contain empty treasury withdrawals, which is pointless and a waste of resources.
 */
export interface SubmitTransactionFailureEmptyTreasuryWithdrawal {
  code: 3168;
  message: string;
}
/**
 * A transaction was rejected due to custom rules that prevented it from entering the mempool. A justification is given as 'data.error'.
 */
export interface SubmitTransactionFailureUnexpectedMempoolError {
  code: 3997;
  message: string;
  data: {
    [k: string]: unknown;
  };
}
/**
 * Unrecognized certificate type. This error is a placeholder due to how internal data-types are modeled. If you ever run into this, please report the issue as you've likely discoverd a critical bug...
 */
export interface SubmitTransactionFailureUnrecognizedCertificateType {
  code: 3998;
  message: string;
}
export interface SubmitTransactionDeserialisationError {
  jsonrpc: "2.0";
  method: "submitTransaction";
  error: DeserialisationFailure;
  id?: unknown;
}
/**
 * The input failed to deserialize in any of the known era.
 */
export interface DeserialisationFailure {
  code: -32602;
  message: string;
  data: {
    shelley: string;
    allegra: string;
    mary: string;
    alonzo: string;
    babbage: string;
    conway: string;
  };
}
/**
 * Evaluate execution units for which redeemers's budget hasn't yet been set.
 */
export interface EvaluateTransaction {
  jsonrpc: "2.0";
  method: "evaluateTransaction";
  params: {
    transaction: {
      /**
       * CBOR-serialized signed transaction (base16)
       */
      cbor: string;
    };
    additionalUtxo?: Utxo;
  };
  id?: unknown;
}
export interface EvaluateTransactionSuccess {
  jsonrpc: "2.0";
  method: "evaluateTransaction";
  result: {
    validator: RedeemerPointer;
    budget: ExecutionUnits;
  }[];
  id?: unknown;
}
/**
 * Happens when attempting to evaluate execution units on a node that isn't enough synchronized.
 */
export interface EvaluateTransactionError {
  jsonrpc: "2.0";
  method: "evaluateTransaction";
  error: EvaluateTransactionFailure;
  id?: unknown;
}
/**
 * Returned when trying to evaluate execution units of a pre-Alonzo transaction. Note that this isn't possible with Ogmios because transactions are always de-serialized as Alonzo transactions.
 */
export interface EvaluateTransactionFailureIncompatibleEra {
  code: 3000;
  message: string;
  /**
   * The era in which the transaction has been identified.
   */
  data: {
    incompatibleEra: Era;
  };
}
/**
 * Returned when trying to evaluate execution units of an era that is now considered too old and is no longer supported. This can solved by using a more recent transaction format.
 */
export interface EvaluateTransactionFailureUnsupportedEra {
  code: 3001;
  message: string;
  /**
   * The era in which the transaction has been identified.
   */
  data: {
    unsupportedEra: Era;
  };
}
/**
 * Happens when providing an additional UTXO set which overlaps with the UTXO on-chain.
 */
export interface EvaluateTransactionFailureOverlappingAdditionalUtxo {
  code: 3002;
  message: string;
  data: {
    overlappingOutputReferences: TransactionOutputReference[];
  };
}
/**
 * Happens when attempting to evaluate execution units on a node that isn't enough synchronized.
 */
export interface EvaluateTransactionFailureNodeTipTooOld {
  code: 3003;
  message: string;
  data: {
    minimumRequiredEra: Era;
    currentNodeEra: Era;
  };
}
/**
 * The transaction is malformed or missing information; making evaluation impossible.
 */
export interface EvaluateTransactionFailureCannotCreateEvaluationContext {
  code: 3004;
  message: string;
  data: {
    reason: string;
  };
}
/**
 * One or more script execution terminated with an error.
 */
export interface EvaluateTransactionFailureScriptExecutionFailure {
  code: 3010;
  message: string;
  data: {
    validator: RedeemerPointer;
    error: ScriptExecutionFailure;
  }[];
}
/**
 * Some script witnesses are missing. Indeed, any script used in a transaction (when spending, minting, etc...) must be provided in full with the transaction. Scripts must therefore be added either to the witness set or provided as a reference input should you use plutus:v2 or higher and a format from Babbage and beyond. The field 'data.missingScripts' contain hash digests of required but missing script.
 */
export interface ScriptExecutionFailureInvalidRedeemerPointers {
  code: 3011;
  message: string;
  data: {
    missingScripts: RedeemerPointer[];
  };
}
/**
 * Some of the scripts failed to evaluate to a positive outcome. The field 'data.validationError' informs about the nature of the error, and 'data.traces' lists all the execution traces collected during the script execution.
 */
export interface ScriptExecutionFailureValidationFailure {
  code: 3012;
  message: string;
  data: {
    validationError: string;
    traces: string[];
  };
}
/**
 * A redeemer points to an input that isn't locked by a Plutus script. Double-check your redeemer pointers and note that, inputs are ordered lexicographically by the ledger (using their transaction id and output index). This order may differ from the one you originally defined in your transaction and may be the cause of misalignment of your redeemer pointers. The field 'data.unsuitableOutputReference' indicates which input was wrongly targeted by a redeemer.
 */
export interface ScriptExecutionFailureUnsuitableOutputReference {
  code: 3013;
  message: string;
  data: {
    unsuitableOutputReference: TransactionOutputReference;
  };
}
export interface EvaluateTransactionDeserialisationError {
  jsonrpc: "2.0";
  method: "evaluateTransaction";
  error: DeserialisationFailure;
  id?: unknown;
}
/**
 * Acquire a point on chain from which to run ledger-state queries.
 */
export interface AcquireLedgerState {
  jsonrpc: "2.0";
  method: "acquireLedgerState";
  params: {
    point: PointOrOrigin;
  };
  id?: unknown;
}
export interface AcquireLedgerStateFailure {
  jsonrpc: "2.0";
  method: "acquireLedgerState";
  /**
   * Unable to acquire the ledger state at the request point.
   */
  error: {
    code: 2000;
    message: string;
    /**
     * A reason for the failure.
     */
    data: string;
  };
  id?: unknown;
}
/**
 * Response to an 'acquireLedgerState' request.
 */
export interface AcquireLedgerStateSuccess {
  jsonrpc: "2.0";
  method: "acquireLedgerState";
  result: {
    acquired: "ledgerState";
    point: PointOrOrigin;
  };
  id?: unknown;
}
/**
 * Release a previously acquired ledger state.
 */
export interface ReleaseLedgerState {
  jsonrpc: "2.0";
  method: "releaseLedgerState";
  id?: unknown;
}
/**
 * Response to a 'releaseLedgerState' request.
 */
export interface ReleaseLedgerStateResponse {
  jsonrpc: "2.0";
  method: "releaseLedgerState";
  result: {
    released: "ledgerState";
  };
  id?: unknown;
}
export interface QueryLedgerStateEraMismatch {
  jsonrpc: "2.0";
  method:
    | "queryLedgerState/constitution"
    | "queryLedgerState/constitutionalCommittee"
    | "queryLedgerState/delegateRepresentatives"
    | "queryLedgerState/epoch"
    | "queryLedgerState/eraStart"
    | "queryLedgerState/eraSummaries"
    | "queryLedgerState/governanceProposals"
    | "queryLedgerState/liveStakeDistribution"
    | "queryLedgerState/projectedRewards"
    | "queryLedgerState/protocolParameters"
    | "queryLedgerState/proposedProtocolParameters"
    | "queryLedgerState/rewardAccountSummaries"
    | "queryLedgerState/rewardsProvenance"
    | "queryLedgerState/stakePools"
    | "queryLedgerState/utxo"
    | "queryLedgerState/tip"
    | "queryLedgerState/treasuryAndReserves";
  /**
   * An era mismatch between a client request and the era the ledger is in. This may occur when running queries on a syncing node and/or when the node is crossing an era.
   */
  error: {
    code: 2001;
    message: string;
    data: EraMismatch;
  };
  id?: unknown;
}
export interface QueryLedgerStateUnavailableInCurrentEra {
  jsonrpc: "2.0";
  method:
    | "queryLedgerState/constitution"
    | "queryLedgerState/constitutionalCommittee"
    | "queryLedgerState/delegateRepresentatives"
    | "queryLedgerState/epoch"
    | "queryLedgerState/eraStart"
    | "queryLedgerState/eraSummaries"
    | "queryLedgerState/governanceProposals"
    | "queryLedgerState/liveStakeDistribution"
    | "queryLedgerState/projectedRewards"
    | "queryLedgerState/protocolParameters"
    | "queryLedgerState/proposedProtocolParameters"
    | "queryLedgerState/rewardAccountSummaries"
    | "queryLedgerState/rewardsProvenance"
    | "queryLedgerState/stakePools"
    | "queryLedgerState/utxo"
    | "queryLedgerState/tip"
    | "queryLedgerState/treasuryAndReserves";
  /**
   * Some query is not available for the requested ledger era.
   */
  error: {
    code: 2002;
    message: string;
  };
  id?: unknown;
}
export interface QueryLedgerStateAcquiredExpired {
  jsonrpc: "2.0";
  method:
    | "queryLedgerState/constitution"
    | "queryLedgerState/constitutionalCommittee"
    | "queryLedgerState/delegateRepresentatives"
    | "queryLedgerState/epoch"
    | "queryLedgerState/eraStart"
    | "queryLedgerState/eraSummaries"
    | "queryLedgerState/governanceProposals"
    | "queryLedgerState/liveStakeDistribution"
    | "queryLedgerState/projectedRewards"
    | "queryLedgerState/protocolParameters"
    | "queryLedgerState/proposedProtocolParameters"
    | "queryLedgerState/rewardAccountSummaries"
    | "queryLedgerState/rewardsProvenance"
    | "queryLedgerState/stakePools"
    | "queryLedgerState/utxo"
    | "queryLedgerState/tip"
    | "queryLedgerState/treasuryAndReserves";
  /**
   * Previously acquired ledger state is no longer available.
   */
  error: {
    code: 2003;
    message: string;
    /**
     * A reason for the failure.
     */
    data: string;
  };
  id?: unknown;
}
/**
 * Query the current constitution definition (only available from Conway onwards).
 */
export interface QueryLedgerStateConstitution {
  jsonrpc: "2.0";
  method: "queryLedgerState/constitution";
  id?: unknown;
}
export interface QueryLedgerStateConstitutionResponse {
  jsonrpc: "2.0";
  method: "queryLedgerState/constitution";
  result: Constitution;
  id?: unknown;
}
export interface Constitution {
  guardrails: null | {
    hash: DigestBlake2B224;
  };
  metadata: Anchor;
}
/**
 * Get the state of the constitutional committee (only available from Conway onwards).
 */
export interface QueryLedgerStateConstitutionalCommittee {
  jsonrpc: "2.0";
  method: "queryLedgerState/constitutionalCommittee";
  id?: unknown;
}
export interface QueryLedgerStateConstitutionalCommitteeResponse {
  jsonrpc: "2.0";
  method: "queryLedgerState/constitutionalCommittee";
  result: null | {
    members: ConstitutionalCommitteeMember[];
    quorum: null | Ratio;
  };
  id?: unknown;
}
/**
 * A constitutional committee member as seen in the context of a specific epoch. Statuses and next states are to be seen from this specific epoch. The field 'next', when present, refers to any change happening to this member in the following epoch.
 */
export interface ConstitutionalCommitteeMember {
  id: DigestBlake2B224;
  from: CredentialOrigin;
  /**
   * A member status. 'active' indicates that this member vote will count during the ratification of the ongoing epoch. 'unrecognized' means that some hot credential currently points to a non-existing (or no longer existing) member.
   */
  status: "active" | "expired" | "unrecognized";
  delegate: ConstitutionalCommitteeDelegate;
  mandate?: Mandate;
  next?:
    | {
        change: "toBeEnacted";
      }
    | {
        change: "toBeRemoved";
      }
    | {
        change: "expiring";
      }
    | {
        change: "adjustingMandate";
        mandate: Mandate;
      };
}
/**
 * Query currently registered delegate representatives, their stake (i.e. voting powers) and metadata about them. Note that 'params' is optional and can be used to filter out delegates. When omitted, ALL delegates are returned. Pre-defined options (always abstain and always no confidence) are ALWAYS returned.
 */
export interface QueryLedgerStateDelegateRepresentatives {
  jsonrpc: "2.0";
  method: "queryLedgerState/delegateRepresentatives";
  params?: {
    scripts?: AnyDelegateRepresentativeCredential[];
    keys?: AnyDelegateRepresentativeCredential[];
  };
  id?: unknown;
}
export interface QueryLedgerStateDelegateRepresentativesResponse {
  jsonrpc: "2.0";
  method: "queryLedgerState/delegateRepresentatives";
  result: DelegateRepresentativeSummary[];
  id?: unknown;
}
export interface DelegateRepresentativeSummaryRegistered {
  id: DigestBlake2B224;
  from: CredentialOrigin;
  type: "registered";
  mandate: Mandate;
  metadata?: Anchor;
  deposit: ValueAdaOnly;
  stake: ValueAdaOnly;
  delegators: {
    credential: DigestBlake2B224;
    from: CredentialOrigin;
  }[];
}
export interface DelegateRepresentativeSummaryNoConfidence {
  /**
   * A special delegate representative which always vote no, except on votes of no-confidence.
   */
  type: "noConfidence";
  stake: ValueAdaOnly;
}
export interface DelegateRepresentativeAbstain1 {
  /**
   * A special delegate representative which always abstain.
   */
  type: "abstain";
  stake: ValueAdaOnly;
}
/**
 * Get a dump of the entire Cardano ledger state (base16-encoded CBOR) corresponding to the 'EpochState'. Use at your own risks.
 */
export interface QueryLedgerStateDump {
  jsonrpc: "2.0";
  method: "queryLedgerState/dump";
  id?: unknown;
}
export interface QueryLedgerStateDumpResponse {
  jsonrpc: "2.0";
  method: "queryLedgerState/dump";
  result: string;
  id?: unknown;
}
/**
 * Query the current epoch number the ledger is at.
 */
export interface QueryLedgerStateEpoch {
  jsonrpc: "2.0";
  method: "queryLedgerState/epoch";
  id?: unknown;
}
export interface QueryLedgerStateEpochResponse {
  jsonrpc: "2.0";
  method: "queryLedgerState/epoch";
  result: Epoch;
  id?: unknown;
}
/**
 * Query the start of the current ledger era.
 */
export interface QueryLedgerStateEraStart {
  jsonrpc: "2.0";
  method: "queryLedgerState/eraStart";
  id?: unknown;
}
export interface QueryLedgerStateEraStartResponse {
  jsonrpc: "2.0";
  method: "queryLedgerState/eraStart";
  result: Bound;
  id?: unknown;
}
/**
 * An era bound which captures the time, slot and epoch at which the era start. The time is relative to the start time of the network.
 */
export interface Bound {
  time: RelativeTime;
  slot: Slot;
  epoch: Epoch;
}
/**
 * A time in seconds relative to another one (typically, system start or era start).
 */
export interface RelativeTime {
  seconds: bigint;
}
/**
 * Query a summary of the slotting parameters and boundaries for each known era. Useful for doing slot-arithmetic and time conversions.
 */
export interface QueryLedgerStateEraSummaries {
  jsonrpc: "2.0";
  method: "queryLedgerState/eraSummaries";
  id?: unknown;
}
export interface QueryLedgerStateEraSummariesResponse {
  jsonrpc: "2.0";
  method: "queryLedgerState/eraSummaries";
  result: EraSummary[];
  id?: unknown;
}
/**
 * Summary of the confirmed parts of the ledger.
 */
export interface EraSummary {
  start: Bound;
  end?: Bound;
  parameters: EraParameters;
}
/**
 * Parameters that can vary across hard forks.
 */
export interface EraParameters {
  epochLength: Epoch;
  slotLength: SlotLength;
  safeZone: SafeZone | null;
}
/**
 * A slot length in milliseconds
 */
export interface SlotLength {
  milliseconds: bigint;
}
/**
 * Query currently active governance proposals, optionally restricted to specific governance proposal references.
 */
export interface QueryLedgerStateGovernanceProposals {
  jsonrpc: "2.0";
  method: "queryLedgerState/governanceProposals";
  params?: GovernanceProposalsByReferences | WholeGovernanceProposals;
  id?: unknown;
}
export interface GovernanceProposalsByReferences {
  proposals: GovernanceProposalReference[];
}
export interface WholeGovernanceProposals {}
export interface QueryLedgerStateGovernanceProposalsResponse {
  jsonrpc: "2.0";
  method: "queryLedgerState/governanceProposals";
  result: GovernanceProposalState[];
  id?: unknown;
}
export interface GovernanceProposalState {
  proposal: GovernanceProposalReference;
  deposit: ValueAdaOnly;
  returnAccount: RewardAccount;
  metadata: Anchor;
  action:
    | GovernanceActionProtocolParametersUpdate
    | GovernanceActionHardForkInitiation
    | GovernanceActionTreasuryTransfer
    | GovernanceActionTreasuryWithdrawals
    | GovernanceActionConstitutionalCommittee
    | GovernanceActionConstitution
    | GovernanceActionNoConfidence
    | GovernanceActionInformation;
  since: {
    epoch: Epoch;
  };
  until: {
    epoch: Epoch;
  };
  votes: GovernanceVote[];
}
/**
 * Query the current distribution of the stake across all known stake pools, relative to the TOTAL stake in the network.
 */
export interface QueryLedgerStateLiveStakeDistribution {
  jsonrpc: "2.0";
  method: "queryLedgerState/liveStakeDistribution";
  id?: unknown;
}
export interface QueryLedgerStateLiveStakeDistributionResponse {
  jsonrpc: "2.0";
  method: "queryLedgerState/liveStakeDistribution";
  result: LiveStakeDistribution;
  id?: unknown;
}
/**
 * Distribution of stake across registered stake pools. Each key in the map corresponds to a pool id.
 */
export interface LiveStakeDistribution {
  [k: string]: {
    stake: Ratio;
    vrf: DigestBlake2B256;
  };
}
/**
 * Query the projected rewards of an account in a context where the top stake pools are fully saturated. This projection gives, in principle, a ranking of stake pools that maximizes delegator rewards.
 */
export interface QueryLedgerStateProjectedRewards {
  jsonrpc: "2.0";
  method: "queryLedgerState/projectedRewards";
  params: {
    stake?: ValueAdaOnly[];
    scripts?: AnyStakeCredential[];
    keys?: AnyStakeCredential[];
  };
  id?: unknown;
}
export interface QueryLedgerStateProjectedRewardsResponse {
  jsonrpc: "2.0";
  method: "queryLedgerState/projectedRewards";
  result: ProjectedRewards;
  id?: unknown;
}
/**
 * Rewards that can be expected assuming a pool is fully saturated. Such rewards are said non-myopic, in opposition to short-sighted rewards looking at immediate benefits. Keys of the map can be either Lovelace amounts or account credentials depending on the query.
 */
export interface ProjectedRewards {
  [k: string]: {
    [k: string]: ValueAdaOnly;
  };
}
/**
 * Query the last update proposal w.r.t. protocol parameters, if any.
 */
export interface QueryLedgerStateProposedProtocolParameters {
  jsonrpc: "2.0";
  method: "queryLedgerState/proposedProtocolParameters";
  id?: unknown;
}
export interface QueryLedgerStateProposedProtocolParametersResponse {
  jsonrpc: "2.0";
  method: "queryLedgerState/proposedProtocolParameters";
  result: ProposedProtocolParameters[];
  id?: unknown;
}
/**
 * Query the current protocol parameters.
 */
export interface QueryLedgerStateProtocolParameters {
  jsonrpc: "2.0";
  method: "queryLedgerState/protocolParameters";
  id?: unknown;
}
export interface QueryLedgerStateProtocolParametersResponse {
  jsonrpc: "2.0";
  method: "queryLedgerState/protocolParameters";
  result: ProtocolParameters;
  id?: unknown;
}
export interface ProtocolParameters {
  minFeeCoefficient: UInt64;
  minFeeConstant: ValueAdaOnly;
  minFeeReferenceScripts?: {
    range: UInt32;
    /**
     * The base cost for the tier-price calculation.
     */
    base: number;
    /**
     * The multiplier increasing the cost of each tier.
     */
    multiplier: number;
  };
  minUtxoDepositCoefficient: UInt64;
  minUtxoDepositConstant: ValueAdaOnly;
  maxBlockBodySize: {
    bytes: UInt64;
  };
  maxBlockHeaderSize: {
    bytes: UInt64;
  };
  maxTransactionSize?: {
    bytes: UInt64;
  };
  maxValueSize?: {
    bytes: UInt64;
  };
  extraEntropy?: Nonce;
  stakeCredentialDeposit: ValueAdaOnly;
  stakePoolDeposit: ValueAdaOnly;
  stakePoolRetirementEpochBound: UInt64;
  stakePoolPledgeInfluence: Ratio;
  minStakePoolCost: ValueAdaOnly;
  desiredNumberOfStakePools: UInt64;
  federatedBlockProductionRatio?: Ratio;
  monetaryExpansion: Ratio;
  treasuryExpansion: Ratio;
  collateralPercentage?: UInt64;
  maxCollateralInputs?: UInt64;
  plutusCostModels?: CostModels;
  scriptExecutionPrices?: ScriptExecutionPrices;
  maxExecutionUnitsPerTransaction?: ExecutionUnits;
  maxExecutionUnitsPerBlock?: ExecutionUnits;
  maxReferenceScriptsSize?: {
    bytes: UInt64;
  };
  stakePoolVotingThresholds?: StakePoolVotingThresholds;
  constitutionalCommitteeMinSize?: UInt16;
  constitutionalCommitteeMaxTermLength?: UInt64;
  governanceActionLifetime?: Epoch;
  governanceActionDeposit?: ValueAdaOnly;
  delegateRepresentativeVotingThresholds?: DelegateRepresentativeVotingThresholds;
  delegateRepresentativeDeposit?: ValueAdaOnly;
  delegateRepresentativeMaxIdleTime?: Epoch;
  version: ProtocolVersion;
}
/**
 * Query current delegation settings and rewards of some given reward accounts.
 */
export interface QueryLedgerStateRewardAccountSummaries {
  jsonrpc: "2.0";
  method: "queryLedgerState/rewardAccountSummaries";
  params: {
    scripts?: AnyStakeCredential[];
    keys?: AnyStakeCredential[];
  };
  id?: unknown;
}
export interface QueryLedgerStateRewardAccountSummariesResponse {
  jsonrpc: "2.0";
  method: "queryLedgerState/rewardAccountSummaries";
  result: RewardAccountSummaries;
  id?: unknown;
}
export interface RewardAccountSummaries {
  [k: string]: RewardAccountSummary;
}
export interface RewardAccountSummary {
  delegate: {
    id: StakePoolId;
  };
  rewards: ValueAdaOnly;
  deposit: ValueAdaOnly;
}
/**
 * Query details about rewards calculation for the ongoing epoch.
 */
export interface QueryLedgerStateRewardsProvenance {
  jsonrpc: "2.0";
  method: "queryLedgerState/rewardsProvenance";
  id?: unknown;
}
export interface QueryLedgerStateRewardsProvenanceResponse {
  jsonrpc: "2.0";
  method: "queryLedgerState/rewardsProvenance";
  result: RewardsProvenance;
  id?: unknown;
}
/**
 * Details about how rewards are calculated for the ongoing epoch.
 */
export interface RewardsProvenance {
  /**
   * Desired number of stake pools.
   */
  desiredNumberOfStakePools: number;
  /**
   * Influence of the pool owner's pledge on rewards, as a ratio of two integers.
   */
  stakePoolPledgeInfluence: string;
  totalRewardsInEpoch: ValueAdaOnly;
  totalStakeInEpoch: ValueAdaOnly;
  activeStakeInEpoch: ValueAdaOnly;
  stakePools: {
    [k: string]: StakePoolSummary;
  };
}
export interface StakePoolSummary {
  id: StakePoolId;
  stake: ValueAdaOnly;
  ownerStake: ValueAdaOnly;
  /**
   * Number of blocks produced divided by expected number of blocks (based on stake and epoch progress). Can be larger than 1.0 for pools that get lucky.
   */
  approximatePerformance: number;
  /**
   * Some of the pool parameters relevant for the reward calculation.
   */
  parameters: {
    cost: ValueAdaOnly;
    margin: Ratio;
    pledge: ValueAdaOnly;
  };
}
/**
 * Query the list of all stake pools currently registered and active, optionally filtered by ids.
 */
export interface QueryLedgerStateStakePools {
  jsonrpc: "2.0";
  method: "queryLedgerState/stakePools";
  params?: {
    stakePools: {
      id: StakePoolId;
    }[];
  };
  id?: unknown;
}
export interface QueryLedgerStateStakePoolsResponse {
  jsonrpc: "2.0";
  method: "queryLedgerState/stakePools";
  result: {
    [k: string]: StakePool;
  };
  id?: unknown;
}
/**
 * Query the current tip the ledger is at. Said differently, the slot number and header hash of the last block that has been processed by the ledger.
 */
export interface QueryLedgerStateTip {
  jsonrpc: "2.0";
  method: "queryLedgerState/tip";
  id?: unknown;
}
export interface QueryLedgerStateTipResponse {
  jsonrpc: "2.0";
  method: "queryLedgerState/tip";
  result: PointOrOrigin;
  id?: unknown;
}
/**
 * Query the Ada value of the treasury and reserves accounts.
 */
export interface QueryLedgerStateTreasuryAndReserves {
  jsonrpc: "2.0";
  method: "queryLedgerState/treasuryAndReserves";
  id?: unknown;
}
export interface QueryLedgerStateTreasuryAndReservesResponse {
  jsonrpc: "2.0";
  method: "queryLedgerState/treasuryAndReserves";
  result: {
    treasury: ValueAdaOnly;
    reserves: ValueAdaOnly;
  };
  id?: unknown;
}
/**
 * Query the current Utxo set, restricted to some output references or addresses.
 */
export interface QueryLedgerStateUtxo {
  jsonrpc: "2.0";
  method: "queryLedgerState/utxo";
  params?: UtxoByOutputReferences | UtxoByAddresses | WholeUtxo;
  id?: unknown;
}
export interface UtxoByOutputReferences {
  outputReferences: TransactionOutputReference[];
}
export interface UtxoByAddresses {
  addresses: Address[];
}
export interface WholeUtxo {}
export interface QueryLedgerStateUtxoResponse {
  jsonrpc: "2.0";
  method: "queryLedgerState/utxo";
  result: Utxo;
  id?: unknown;
}
/**
 * Query the networks highest block number.
 */
export interface QueryNetworkBlockHeight {
  jsonrpc: "2.0";
  method: "queryNetwork/blockHeight";
  id?: unknown;
}
export interface QueryNetworkBlockHeightResponse {
  jsonrpc: "2.0";
  method: "queryNetwork/blockHeight";
  result: BlockHeight | Origin;
  id?: unknown;
}
/**
 * Query the genesis configuration of a given era.
 */
export interface QueryNetworkGenesisConfiguration {
  jsonrpc: "2.0";
  method: "queryNetwork/genesisConfiguration";
  params: {
    era: EraWithGenesis;
  };
  id?: unknown;
}
export interface QueryNetworkGenesisConfigurationResponse {
  jsonrpc: "2.0";
  method: "queryNetwork/genesisConfiguration";
  result: QueryNetworkInvalidGenesis | (GenesisByron | GenesisShelley | GenesisAlonzo | GenesisConway);
  id?: unknown;
}
export interface QueryNetworkInvalidGenesis {
  jsonrpc: "2.0";
  method: "queryNetwork/genesisConfiguration";
  /**
   * Something went wrong (e.g. misconfiguration) in reading genesis file for the latest era.
   */
  error?: {
    code: 2004;
    message: string;
    /**
     * A reason for the failure.
     */
    data: string;
  };
  id?: unknown;
}
/**
 * A Byron genesis configuration, with information used to bootstrap the era. Some parameters are also updatable across the era.
 */
export interface GenesisByron {
  era: "byron";
  genesisKeyHashes: DigestBlake2B224[];
  genesisDelegations: {
    [k: string]: BootstrapOperationalCertificate;
  };
  startTime: UtcTime;
  initialFunds: {
    [k: string]: ValueAdaOnly;
  };
  initialVouchers: {
    [k: string]: ValueAdaOnly;
  };
  securityParameter: UInt64;
  networkMagic: NetworkMagic;
  updatableParameters?: ProtocolParameters;
}
/**
 * A Shelley genesis configuration, with information used to bootstrap the era. Some parameters are also updatable across the era.
 */
export interface GenesisShelley {
  era: "shelley";
  startTime: UtcTime;
  networkMagic: NetworkMagic;
  network: Network;
  activeSlotsCoefficient: Ratio;
  securityParameter: UInt64;
  epochLength: Epoch;
  slotsPerKesPeriod: UInt64;
  maxKesEvolutions: UInt64;
  slotLength: SlotLength;
  updateQuorum: UInt64;
  maxLovelaceSupply: UInt64;
  initialParameters: ProtocolParameters;
  initialDelegates: InitialDelegates;
  initialFunds: InitialFunds;
  initialStakePools: GenesisStakePools;
}
export interface InitialFunds {
  [k: string]: ValueAdaOnly;
}
/**
 * A Genesis stake pools configuration; primarily used for bootstrapping test networks.
 */
export interface GenesisStakePools {
  stakePools: {
    [k: string]: StakePool;
  };
  delegators: {
    [k: string]: StakePoolId;
  };
}
/**
 * An Alonzo genesis configuration, with information used to bootstrap the era. Some parameters are also updatable across the era.
 */
export interface GenesisAlonzo {
  era: "alonzo";
  updatableParameters: {
    minUtxoDepositCoefficient: UInt64;
    collateralPercentage: UInt64;
    plutusCostModels: CostModels;
    maxCollateralInputs: UInt64;
    maxExecutionUnitsPerBlock: ExecutionUnits;
    maxExecutionUnitsPerTransaction: ExecutionUnits;
    maxValueSize: {
      bytes: UInt64;
    };
    scriptExecutionPrices: ScriptExecutionPrices;
  };
}
/**
 * An Conway genesis configuration, with information used to bootstrap the era. Some parameters are also updatable across the era.
 */
export interface GenesisConway {
  era: "conway";
  constitution: Constitution;
  constitutionalCommittee: {
    members: ConstitutionalCommitteeMemberSummary[];
    quorum: Ratio;
  };
  updatableParameters: {
    stakePoolVotingThresholds: StakePoolVotingThresholds;
    constitutionalCommitteeMinSize: UInt64;
    constitutionalCommitteeMaxTermLength: UInt64;
    governanceActionLifetime: Epoch;
    governanceActionDeposit: ValueAdaOnly;
    delegateRepresentativeVotingThresholds: DelegateRepresentativeVotingThresholds;
    delegateRepresentativeDeposit: ValueAdaOnly;
    delegateRepresentativeMaxIdleTime: Epoch;
  };
}
/**
 * Query the network start time.
 */
export interface QueryNetworkStartTime {
  jsonrpc: "2.0";
  method: "queryNetwork/startTime";
  id?: unknown;
}
export interface QueryNetworkStartTimeResponse {
  jsonrpc: "2.0";
  method: "queryNetwork/startTime";
  result: UtcTime;
  id?: unknown;
}
/**
 * Get the current network tip. Said differently, this is the most recent slot and block header hash that the node it aware of.
 */
export interface QueryNetworkTip {
  jsonrpc: "2.0";
  method: "queryNetwork/tip";
  id?: unknown;
}
export interface QueryNetworkTipResponse {
  jsonrpc: "2.0";
  method: "queryNetwork/tip";
  result: PointOrOrigin;
  id?: unknown;
}
/**
 * Acquire a mempool snapshot. This is blocking until a new (i.e different) snapshot is available.
 */
export interface AcquireMempool {
  jsonrpc: "2.0";
  method: "acquireMempool";
  id?: unknown;
}
/**
 * Response to a 'acquireMempool' request.
 */
export interface AcquireMempoolResponse {
  jsonrpc: "2.0";
  method: "acquireMempool";
  result: {
    acquired: "mempool";
    slot: Slot;
  };
  id?: unknown;
}
/**
 * Request the next transaction from an acquired mempools napshot.
 */
export interface NextTransaction {
  jsonrpc: "2.0";
  method: "nextTransaction";
  params?: {
    fields?: "all";
  };
  id?: unknown;
}
export interface MustAcquireMempoolFirst {
  jsonrpc: "2.0";
  method: "hasTransaction" | "nextTransaction" | "sizeOfMempool" | "releaseMempool";
  /**
   * Must acquire a mempool snapshot prior to performing any query.
   */
  error: {
    code: 4000;
    message: string;
  };
  id?: unknown;
}
/**
 * Response to a 'nextTransaction' request.
 */
export interface NextTransactionResponse {
  jsonrpc: "2.0";
  method: "nextTransaction";
  /**
   * A transaction (or id) or an empty object if there's no more transactions.
   */
  result: {
    transaction:
      | {
          id: TransactionId;
        }
      | Transaction
      | null;
  };
  id?: unknown;
}
/**
 * Ask whether a given transaction is present in the acquired mempool snapshot.
 */
export interface HasTransaction {
  jsonrpc: "2.0";
  method: "hasTransaction";
  params: {
    id: TransactionId;
  };
  id?: unknown;
}
/**
 * Response to a 'HasTransaction' request.
 */
export interface HasTransactionResponse {
  jsonrpc: "2.0";
  method: "hasTransaction";
  result: boolean;
  id?: unknown;
}
/**
 * Get size and capacities of the mempool (acquired snapshot).
 */
export interface SizeOfMempool {
  jsonrpc: "2.0";
  method: "sizeOfMempool";
  id?: unknown;
}
/**
 * Response to a 'sizeOfMempool' request.
 */
export interface SizeOfMempoolResponse {
  jsonrpc: "2.0";
  method: "sizeOfMempool";
  result: MempoolSizeAndCapacity;
  id?: unknown;
}
export interface MempoolSizeAndCapacity {
  maxCapacity: {
    bytes: UInt64;
  };
  currentSize: {
    bytes: UInt64;
  };
  transactions: {
    count: UInt32;
  };
}
/**
 * Release a previously acquired mempool snapshot.
 */
export interface ReleaseMempool {
  jsonrpc: "2.0";
  method: "releaseMempool";
  id?: unknown;
}
/**
 * Response to a 'releaseMempool' request.
 */
export interface ReleaseMempoolResponse {
  jsonrpc: "2.0";
  method: "releaseMempool";
  result: {
    released: "mempool";
  };
  id?: unknown;
}
/**
 * A generic error in the JSON-RPC protocol. This is returned by the server when a request from clients is deemed invalid or, when the server was unable to reply to a well-formed request.
 */
export interface RpcError {
  jsonrpc: "2.0";
  error: {
    /**
     * An error code telling about the nature of the error.
     */
    code: number;
    /**
     * A descriptive error message giving hints about the error.
     */
    message?: string;
    data?: unknown;
  };
  id?: unknown;
}
