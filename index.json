[{"uri":"https://ogmios.dev/getting-started/","title":"Getting Started","tags":[],"description":"","content":"Getting Started Find in this section information about building and running Ogmios. This will cover installation from both sources and docker ğŸ³, as well as details about options and configuration for running Ogmios.\n"},{"uri":"https://ogmios.dev/deployment/aws/","title":"AWS","tags":[],"description":"","content":"Pre-Requisites   Make sure to have an AWS account, and an AWS_ACCESS_KEY_ID \u0026amp; AWS_SECRET_ACCESS_KEY.\n  Make sure to grant AmazonEC2FullAccess to your AWS user.\n  You\u0026rsquo;ll need to create a security group which allows inbound TCP connections. See also: Working With Security Groups.\n  Install docker-machine\n  Create an SSH key/pair $ ssh-keygen -t rsa -b 4096 -C \u0026quot;your_email@example.com\u0026quot; -f aws_rsa $ eval \u0026quot;$(ssh-agent -s)\u0026quot; $ ssh-add ~/.ssh/aws_rsa Create The Docker Machine AWS_ACCESS_KEY_ID=\u0026lt;YOUR_ACCESS_KEY_ID\u0026gt; AWS_SECRET_ACCESS_KEY=\u0026lt;YOUR_SECRET_KEY\u0026gt; docker-machine create -d amazonec2 \\  --amazonec2-access-key $AWS_ACCESS_KEY_ID \\  --amazonec2-secret-key $AWS_SECRET_ACCESS_KEY \\  --amazonec2-region eu-west-3 \\  --amazonec2-instance-type \u0026#34;t2.medium\u0026#34; \\  --amazonec2-ssh-keypath ~/.ssh/aws_rsa \\  aws-ogmios Push The Stack First, configure your shell and activate your docker-machine:\n$ eval $(docker-machine env aws-ogmios) Then, simply push the stack using docker-compose:\n$ COMPOSE_TLS_VERSION=TLSv1_2 docker-compose up -d  Compose may use a wrong TLS version for pulling layers from dockerhub. Hence the ENV var.\n ğŸ‰ Enjoy $ docker-machine ls NAME ACTIVE DRIVER STATE URL SWARM DOCKER ERRORS aws-ogmios * amazonec2 Running tcp://xx.xxx.xxx.xxx:xxxx v19.03.8 (Optional) Adding TLS with a registered domain   Install nginx.\n    Configure a new server as /etc/nginx/sites-enabled/domain.extension   server { server_name DOMAIN.EXTENSION; listen 80; location ^~ /.well-known/acme-challenge/ { try_files $uri /dev/null =404; } }    ğŸ‘† Make sure to replace \u0026lsquo;DOMAIN.EXTENSION\u0026rsquo; with your actual registered domain.\n  Reload your nginx configuration with: sudo systemctl reload nginx.service.\n  Install certbot and let certbot configure your nginx server (sudo certbot --nginx).\n  Once done, edit your nginx configuration one more time\u0026hellip;\n    Remove (no longer needed after certbot has successfully configured the server)   location ^~ /.well-known/acme-challenge/ { try_files $uri /dev/null =404; }        And add the following clause to enable routing all traffic (including WebSockets) to ogmios   location ~* / { proxy_pass http://localhost:1337; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \u0026#34;Upgrade\u0026#34;; proxy_set_header Host $host; }        The final configuration should look like this:\nserver { server_name ogmios.dev; location ~* / { proxy_pass http://localhost:1337; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \u0026#34;Upgrade\u0026#34;; proxy_set_header Host $host; } listen 443 ssl; # managed by Certbot  ssl_certificate /etc/letsencrypt/live/ogmios.dev/fullchain.pem; # managed by Certbot  ssl_certificate_key /etc/letsencrypt/live/ogmios.dev/privkey.pem; # managed by Certbot  include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot  ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot } server { server_name ogmios.dev; listen 80; if ($host = ogmios.dev) { return 301 https://$host$request_uri; } # managed by Certbot  return 404; # managed by Certbot } "},{"uri":"https://ogmios.dev/getting-started/docker/","title":"Docker","tags":[],"description":"","content":"ğŸ³ The easiest way to get started is to use docker. This guide won\u0026rsquo;t cover installing docker, so make sure you have the docker daemon installed and running. Since Ogmios requires the presence of a Cardano node, we\u0026rsquo;ll be using docker-compose to orchestrate both services. A compose file is available on the Ogmios repository, get it via:\n$ git clone --depth 1 git@github.com:KtorZ/cardano-ogmios.git $ cd cardano-ogmios Then, starts the components stack using:\n$ docker-compose up ğŸ‘†This will run and connect together:\n A Cardano node, connected to mainnet. An Ogmios server using the latest Dockerhub build, listening to localhost on port :1337.  To build the Ogmios image from sources, pass the --build flag. This is useful if you need a different version than the latest one available on Dockerhub.\nIf you\u0026rsquo;re building locally using docker build, make sure to leverage existing cache steps from Docker Hub setting the env DOCKER_BUILDKIT=1 and passing --cache-from ktorz/ogmios:latest. For docker-compose build or docker-compose up --build, also setCOMPOSE_DOCKER_CLI_BUILD=1. A full build of Ogmios without cache may take up to 45 minutes!\n Configuration The compose file allows for minimal (albeit useful) configuration parameters via environment variables:\n   Variable Description Values Default     NETWORK Which Cardano network to connect to. This impacts both Ogmios and the underlying Cardano node. mainnet, testnet mainnet   OGMIOS_PORT Which ports to listen to (both for WebSockets and health endpoints) Any valid port number. 1337    Ogmios doesn\u0026rsquo;t use any form of persistent storage, but cardano-node does. The mainnet and testnet databases are not compatible, so it is recommended to instrument docker-compose to use different namespaces for different networks (so that you can switch from one another without risking any database conflicts). Compose can do this easily by passing an extra flag: --project-name.\n For example, for running cardano-node + ogmios on the testnet, listening to tcp/1338, do:\n$ NETWORK=testnet OGMIOS_PORT=1338 docker-compose --project-name cardano-ogmios-testnet up "},{"uri":"https://ogmios.dev/mini-protocols/local-chain-sync/","title":"Local Chain Sync","tags":[],"description":"","content":" â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ Intersect â”‚â—€â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•— â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜ FindIntersect â•‘ â”‚ â•‘ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ Intersect.{Found,NotFound} â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚ â”‚ â”‚ Idle â”‚ â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â”‚ â”‚ â•‘ RequestNext â”‚ â”‚â‡¦ START â•‘ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â–¼ â–² â”Œâ”€â”€â”€â”€â”€â”€â” Roll.{Backward,Forward} â”‚ â”‚ Next â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”˜   Overview Clients that wish to synchronise blocks from the Cardano chain can use the Local Chain Sync protocol.\nThe protocol is stateful, which means that each connection between clients and Ogmios has a state: a cursor locating a point on the chain. Typically, a client will start by looking for an intersection between its own local chain and the one from the node / Ogmios. Then, it\u0026rsquo;ll simply request the next action to take: either rolling forward and adding new blocks, or rolling backward.\nHow To Use When a connection is opened with Ogmios, it automatically starts a local chain-sync session with the underlying cardano-node. There\u0026rsquo;s an implicit state maintained by the node which one can imagine as a cursor, pointing to a point on the Cardano chain. Initially, this cursor starts at a special point called: origin (as in, the origin of the chain). After each request, the node will move the cursor either forward or backward and remembers its location for the next request. To move the cursor, the protocols gives two mechanisms: RequestNext and FindIntersect.\n ____ ____ ____ ____ ____ ____ / /\\ / /\\ / /\\ / /\\ / /\\ / /\\ o === /____/ \\ === /____/ \\ === /____/ \\ === /____/ \\ === /____/ \\ === /____/ \\ == ... \\ \\ / \\ \\ / \\ \\ / \\ \\ / \\ \\ / \\ \\ / \\____\\/ \\____\\/ \\____\\/ \\____\\/ \\____\\/ \\____\\/ ^ | | origin \n RequestNext Clients may ask for the next block where \u0026lsquo;next\u0026rsquo; refers directly to that implicit cursor. This translates to a message with RequestNext as a method name. This request does not accept any arguments.\n{ \u0026#34;type\u0026#34;: \u0026#34;jsonwsp/request\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0\u0026#34;, \u0026#34;servicename\u0026#34;: \u0026#34;ogmios\u0026#34;, \u0026#34;methodname\u0026#34;: \u0026#34;RequestNext\u0026#34;, \u0026#34;args\u0026#34;: {} } As a response, Ogmios will send back a response which can be either RollForward or RollBackward. Rolling forward is pretty straightforward and is the main type of response one can expect; such response will include the next block, which itself includes a header, transactions, certificates, metadata and all sort of information.\nRolling backward however may occur when, since the last request, the underlying node decided to switch to a different fork of the chain to the extent that the previous cursor is no longer pointing to a block that exists on the chain. The node therefore asks (kindly) to roll backward to a previously known point that is the earliest ancestor that is common between the client\u0026rsquo;s own chain locally and the one that was just adopted by the node.\n ____ ____ / /\\ / /\\ /____/ \\ === /____/ \\ (node's chain) \\ \\ / \\ \\ / / \\____\\/ \\____\\/ / ____ ____ / ____ ____ / /\\ / /\\ / / /\\ / /\\ === /____/ \\ === /____/ \\ =.= /____/ \\ === /____/ \\ (local chain) \\ \\ / \\ \\ / ^ \\ \\ / \\ \\ / \\____\\/ \\____\\/ | \\____\\/ \\____\\/ |  | common chain prefix | | point of rollback   When rolling backward, the node will not provide a block but instead, a point which is made of a block header hash and a slot.\nAs a client, it is therefore crucial to be able to rollback to a previous point of the chain. In practice, Ouroboros guarantees that forks cannot be longer than a certain length. This maximum length is called k in the Ouroboros protocol, and also known as the security parameter.\n Pipelining Ogmios will do its best to pipeline requests to the Cardano node. Yet unlike WebSocket, the local chain-sync protocol only allows for finite pipelining. Said differently, Ogmios cannot pipeline an arbitrary and potentially infinite number of requests and will actually starts collecting responses if too many requests are pipelined. Pipelining with WebSocket is however straightforward for most clients permit sending many requests at once and handle responses using callbacks on event handlers.\nA good rule of thumb with Ogmios is to pipeline some requests when starting a long-run chain-sync, and then simply put back a new request in the queue every time you receive a response back. In that way, there are always some requests in flight and Ogmios can make a good use of the available bandwith. How many requests to pipeline depends on various factors including the network latency and machine resources. In a local setup where Ogmios and its client are located on the same machine, pipelining a few requests (up to 1000) can be quite effective and drastically speed up the chain-sync.\nFor example, here below is a comparison of the effect of pipelining on a full synchronization of the Mary era:\n   Num pipelined / in-flight requests Time     1 (i.e. no pipelining) 6min 22s   10 4min 51s   25 3min 44s   50 2min 40s   100 2min 37s   1000 2min 38s    Exact numbers depends on your application and machine resources. But this charts give an order of magnitude. If you\u0026rsquo;re pipelining many requests in a client application, make sure to also take times to collect some responses because there will be no extra benefits coming from too much pipelining.\n FindIntersect On the first connection with the node, clients will likely synchronize from the origin. Yet, on subsequent connections one may want to resume syncing to a point that is much more recent than the origin. Ideally, one would like to carry on exactly at the point where the chain was left yet as we just saw, this is not always possible. The local chain-sync protocol gives however clients a way to find a common intersection between a client\u0026rsquo;s current version of the chain and whatever version the node has. This is via the FindIntersect message. This message accepts one argument which is a list of header hashes (or the special keyword \u0026quot;origin\u0026quot;).\n{ \u0026#34;type\u0026#34;: \u0026#34;jsonwsp/request\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0\u0026#34;, \u0026#34;servicename\u0026#34;: \u0026#34;ogmios\u0026#34;, \u0026#34;methodname\u0026#34;: \u0026#34;FindIntersect\u0026#34;, \u0026#34;args\u0026#34;: { \u0026#34;points\u0026#34;: [ \u0026#34;9e871633f7aa356ef11cdcabb6fdd6d8f4b00bc919c57aed71a91af8f86df590\u0026#34;, \u0026#34;d184f428159290bf3558b4d1d139e6a07ec6589738c28a0925a7ab776bde4d62\u0026#34;, \u0026#34;origin\u0026#34; ] }, } If an intersection is found, great, the node will set the cursor to that point and let you know. If not, the cursor will remain where it was and the failure will also be broadcast. As we\u0026rsquo;ve seen in the previous section, a node may switch to longer forks based quite arbitrarily. Hence, a good list of intersections candidates is preferably dense near the tip of the chain, and goes far back in the past (k is typically not enough).\nFor example, imagine the following scenario:\n Local chain: [P01,P02,P03,..,P98,P99A,P100A] Node\u0026rsquo;s chain: [P01,P02,P03,..,P98,P99B,P100B]  As a client, providing any point before or at P98 will result in finding an intersection. Yet, if one only provides [P99A, P100A], the node will not be able to figure out where to continue the protocol and will remain at the origin.\nThe order of the list matters! The node will intersect with the best match, considering that the preferred points are first in the list. If one provides origin as a first point, an intersection is guaranteed to always find a match, and always at origin (and that is quite useless!).\n Points of interest For several applications, it may be quite useful to know the last point of each era; This allows to start syncing blocks from the beginning of a particular era. For instance, after seeking an intersection with the last point of the Shelley, RequestNext would yield the first block of the Allegra era. Handy!\n   Era Bound SlotNo Hash     Last Byron Block (mainnet) 4492799 f8084c61b6a238acec985b59310b6ecec49c0ab8352249afd7268da5cff2a457   Last Shelley Block (mainnet) 16588737 4e9bbbb67e3ae262133d94c3da5bffce7b1127fc436e7433b87668dba34c354a   Last Allegra Block (mainnet) 23068793 69c44ac1dda2ec74646e4223bc804d9126f719b1c245dadc2ad65e8de1b276d7   Last Mary Block (mainnet) N/A N/A    Remember also that \u0026quot;origin\u0026quot; is a special point that can be queried and will always yield a success.\nFull Example Let\u0026rsquo;s see a full example that is synchronizing the first 14 blocks of the Shelley chain and printing them to the console.\nconst WebSocket = require(\u0026#39;ws\u0026#39;); const client = new WebSocket(\u0026#34;ws://localhost:1337\u0026#34;); function wsp(methodname, args, mirror) { client.send(JSON.stringify({ type: \u0026#34;jsonwsp/request\u0026#34;, version: \u0026#34;1.0\u0026#34;, servicename: \u0026#34;ogmios\u0026#34;, methodname, args, mirror })); } client.once(\u0026#39;open\u0026#39;, () =\u0026gt; { const lastByronBlock = { slot: 4492799, hash: \u0026#34;f8084c61b6a238acec985b59310b6ecec49c0ab8352249afd7268da5cff2a457\u0026#34; }; wsp(\u0026#34;FindIntersect\u0026#34;, { points: [lastByronBlock] }); }); client.on(\u0026#39;message\u0026#39;, function(msg) { const response = JSON.parse(msg); switch (response.methodname) { case \u0026#34;FindIntersect\u0026#34;: if (!response.result.IntersectionFound) { throw \u0026#34;Whoops? Last Byron block disappeared?\u0026#34; } wsp(\u0026#34;RequestNext\u0026#34;, {}, { n: 14 }); break; case \u0026#34;RequestNext\u0026#34;: if (response.result.RollForward) { console.log(response.result); } if (response.reflection.n \u0026gt; 0) { wsp(\u0026#34;RequestNext\u0026#34;, {}, { n: response.reflection.n - 1 }); } else { client.close(); } break; } }); A few important takes from this excerpt:\n  The node streams blocks that are after the intersection point. Thus to get the first 14 Shelley blocks, one needs to set the intersection at the last Byron block!\n  After successfully finding an intersection, the node will always ask to roll backward to that intersection point. This is because it is possible to provide many points when looking for an intersection and the protocol makes sure that both the node and the client are in sync. This allows clients applications to be somewhat \u0026ldquo;dumb\u0026rdquo; and blindly follow instructions from the node.\n  In this schema, we are sending each request one-by-one, using the mirror field as counter. An alternative could have been:\ncase \u0026#34;FindIntersect\u0026#34;: if (!response.result.IntersectionFound) { throw \u0026#34;Whoops? First Shelley block disappeared?\u0026#34; } for (let i = 14; i \u0026gt; 0; i += 1) { wsp(\u0026#34;RequestNext\u0026#34;, {}); } break; We need not to wait for replies to send requests and can collect all responses at a later stage!\n  Compact Serialization Since version v3.2.0, Ogmios supports a WebSocket sub-protocol which has an influence on the representation of some data objects. When set, this so-called compact mode will omit proofs, signatures and other voluminous pieces of information from responses that are somewhat superfluous in a trustworthy setup (where for instance, your application fully trusts its node / Ogmios). As a consequence, responses are twice smaller, less bloated and the overall chain-sync synchronization is sped up by about 20%. To enable the compact serialization, use:\nogmios.v1:compact as a sub-protocol when establishing the WebSocket connection. Omitted fields are documented in the API reference using the $omitted-if-compact field of relevant objects.\n"},{"uri":"https://ogmios.dev/getting-started/building/","title":"Building","tags":[],"description":"","content":" You may skip this section if you\u0026rsquo;re using Docker ğŸ³.\n Pre-requisites Ogmios is built using the great Haskell build tool stack. You\u0026rsquo;ll also need git to clone the source code, that is:\n git 2.11.* stack 2.*.*  Ogmios in itself is a rather small project, yet it\u0026rsquo;s using library directly from the ouroboros-network, cardano-ledger-specs and cardano-node projects. This is handy for re-using existing logic, but comes at the cost of several system dependencies that are required for building everything. Some may already be installed on your system, but the complete list is:\n libsodium-dev 1.0.* libgmp-dev 6.1.* libssl-dev 1.1.* libpcre3-dev 2.8.* libsystemd-dev zlib1g-dev 1.2.*  ğŸ”¨ Ogmios Clone the git repository from Github:\n$ git clone --depth 1 --recursive --shallow-submodules git@github.com:KtorZ/cardano-ogmios.git $ cd cardano-ogmios/server Then, use Stack to compile the project source code from the \u0026lsquo;server\u0026rsquo; repository:\n$ stack build ogmios The first time, this may take a while as Stack needs to setup a compilation environment and to download a lot of dependencies. Subsequent executions are much faster.\nFrom there, you can run Ogmios via stack using the exec command:\n$ stack exec -- ogmios --help Alternatively, you can instrument Stack to copy the compiled executable elsewhere so that you can run Ogmios all by itself:\n$ stack install ogmios $ ogmios --help ğŸ“š Documentation API Reference Install json-schema-for-humans using pip3:\n$ pip3 install json-schema-for-humans And then, run:\n$ cd docs \u0026amp;\u0026amp; generate-schema-doc --no-link-to-reused-ref static/ogmios.wsp.json static/api-reference.html The documentation will be generated to static/api-reference.html.\n"},{"uri":"https://ogmios.dev/mini-protocols/local-tx-submission/","title":"Local Tx Submission","tags":[],"description":"","content":" â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ Busy â”‚â—€â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•— â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜ SubmitTx â•‘ â”‚ â•‘ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ SubmitTxResponse â”‚ Idle â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚ â”‚ â”‚ â”‚â‡¦ START â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   Overview Transaction submission is pretty simple \u0026amp; works by submitting an already serialized and signed transaction as one single message.\nIn case of success, Ogmios / the node returns an empty response. Otherwise, it returns an error with some details about what went wrong. Clients must thereby know how to construct valid transactions.\nDisclaimer The local tx-submission protocol is the simplest one in appearance. It nevertheless a quite extensive knowledge of the on-chain data-types used by Cardano. Indeed, the protocol in itself is straightforward so long as you already know how to produce and sign a transaction.\nThis guide doesn\u0026rsquo;t cover the creation and serialization of Cardano transactions. This is a rather vast topic and there is a handful of tools out there to help on the matter already, in particular:\n  cardano-serialization-lib which gives JavaScript and WASM bindings for every Cardano on-chain types.\n  cardano-transactions which offers a Haskell library and a command-line interface for constructing and signing transactions.\n  cardano-cli which offers another command-line interface for constructing and signing transactions.\n  In any case, one can always refer to the source CDDL specifications to know how to construct and serialize Cardano transactions.\nProviding a more user-friendly interface with regards to transactions in Ogmios is still under consideration. Yet, since in order to handle and sign transactions, one needs some knowledge about the on-chain binary format anyway, I\u0026rsquo;ve made the (effortless) choice to only treat with already serialized blobs in Ogmios. I am open to suggestions about how this could be made better, drop me a message on Github if you have ideas!\n How to Use Sending a transaction through the Cardano network requires one message using the method SubmitTx, and with a single mandatory arguments with bytes, representing a serialized signed transactions with its full witness.\nNote that JSON does not support embedding raw bytes in objects. Bytes needs therefore to be encoded in either Base16 or Base64; Ogmios will try both encoding.\n{ \u0026#34;type\u0026#34;: \u0026#34;jsonwsp/request\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0\u0026#34;, \u0026#34;servicename\u0026#34;: \u0026#34;ogmios\u0026#34;, \u0026#34;methodname\u0026#34;: \u0026#34;SubmitTx\u0026#34;, \u0026#34;args\u0026#34;: { \u0026#34;bytes\u0026#34;: \u0026#34;\u0026lt;base16 or base64\u0026gt;\u0026#34; } } The response will indicate either a SubmitSuccess or SubmitFail. In case of failure, Ogmios will return a list of failures reported by the underlying node. Note that, if the transaction fails to parse, Ogmios will reply with a generic error.\nTransactions in Shelley are rather complicated and there is a lot of possible validation errors that can be returned. Be sure to have a look at the API reference for an exhaustive list.\nFull Example For what it\u0026rsquo;s worth, here\u0026rsquo;s an example of a transaction submission to the Cardano mainnet via Ogmios. This transaction is using dummy data and will obviously fail. It is however structurally valid, so useful to test if an integration works correctly.\nconst WebSocket = require(\u0026#39;ws\u0026#39;); const client = new WebSocket(\u0026#34;ws://localhost:1337\u0026#34;); function wsp(methodname, args) { client.send(JSON.stringify({ type: \u0026#34;jsonwsp/request\u0026#34;, version: \u0026#34;1.0\u0026#34;, servicename: \u0026#34;ogmios\u0026#34;, methodname, args })); } client.once(\u0026#39;open\u0026#39;, () =\u0026gt; { const bytes = \u0026#34;g6QAgYJYIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGCglg5AQEBAQEBAQEB\u0026#34;+ \u0026#34;AQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBGgAehICC\u0026#34;+ \u0026#34;WDkBAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC\u0026#34;+ \u0026#34;AgICAgIaAHgXXAIaAAH6pAMZHkahAIGCWCABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\u0026#34;+ \u0026#34;AAAAAFhA169grjPSrzUUEcFEXHlZBSaZC/pzy7NzK1TvMi2qFC5ohAI0EPi+PBbpvVIHbyuz\u0026#34;+ \u0026#34;a/ON/gNKnwRljp9WGXq4D/Y=\u0026#34;; wsp(\u0026#34;SubmitTx\u0026#34;, { bytes }); }); client.on(\u0026#39;message\u0026#39;, function(msg) { const response = JSON.parse(msg); console.log(response); client.close(); }); Ogmios replies negatively to the request, returning 4 errors reported by the ledger. Yet, this was indeed reported by the ledger itself, amazing isn\u0026rsquo;t it?\n  SubmitFail   { \u0026#34;version\u0026#34;: \u0026#34;1.0\u0026#34;, \u0026#34;servicename\u0026#34;: \u0026#34;ogmios\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;jsonwsp/response\u0026#34;, \u0026#34;methodname\u0026#34;: \u0026#34;SubmitTx\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;SubmitTxResponse\u0026#34;: { \u0026#34;error\u0026#34;: { \u0026#34;SubmitFail\u0026#34;: [ { \u0026#34;expiredUtxo\u0026#34;: { \u0026#34;transactionTimeToLive\u0026#34;: 7750, \u0026#34;currentSlot\u0026#34;: 12588967 } }, { \u0026#34;feeTooSmall\u0026#34;: { \u0026#34;requiredFee\u0026#34;: 168009, \u0026#34;actualFee\u0026#34;: 129700 } }, { \u0026#34;badInputs\u0026#34;: [ { \u0026#34;index\u0026#34;: 0, \u0026#34;txId\u0026#34;: \u0026#34;0000000000000000000000000000000000000000000000000000000000000000\u0026#34; } ] }, { \u0026#34;valueNotConserved\u0026#34;: { \u0026#34;consumed\u0026#34;: 0, \u0026#34;produced\u0026#34;: 10000000 } } ] } } }, \u0026#34;reflection\u0026#34;: null }    "},{"uri":"https://ogmios.dev/mini-protocols/","title":"Ouroboros Mini-Protocols","tags":[],"description":"","content":"Ouroboros Mini-Protocols In this section, we\u0026rsquo;ll give practical insights about interacting with the Ouroboros mini-protocols. Each sub-section will focus on one particular protocol, give an overview and give examples in JavaScript using Ogmios.\n"},{"uri":"https://ogmios.dev/deployment/","title":"Deployment","tags":[],"description":"","content":"Deployment Find in this section information about deployment Ogmios with various service providers.\n"},{"uri":"https://ogmios.dev/mini-protocols/local-state-query/","title":"Local State Query","tags":[],"description":"","content":" â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â–¶â”‚ Idle â”‚â‡¦ START â”‚ â””â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚ â–² â”‚ Acquire â”‚ â”‚ Failure â”‚ â–¼ â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â” Release â”‚ â”‚ Acquiring â”‚â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â””â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚ â”‚ â–² â”‚ Result â”‚ Acquired â”‚ â”‚ ReAcquire â”‚ â”‚ â–¼ â”‚ â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â” â””â”€â”€â”€â”€â”€â”€â”€â”¤ Acquired â”‚â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚ Querying â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ Query â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   Overview The state query protocol is likely the most versatile of the three Ouroboros mini-protocols. As a matter of fact, it allows for querying various types of information directly from the ledger. In essence, it is like a very simpler request/response pattern where the types of questions one can ask are specified by the protocols. Those questions include: information about the chain tip, information about stake pools but also the balance of a particular address.\nIn order to run a question by the ledger, one must first acquire a particular position on the chain, so that the node can reliably answer a few questions on a chosen, frozen state while continuing maintaining more recent version of the ledger on the side. It is important to note that:\n  The node cannot acquire any arbitrary state. One can only rewind up to a certain point.\n  Should a client keep a state acquired for too long, it is likely to become unreachable at some point, forcing clients to re-acquire.\n  How To Use Ogmios uses a simplified version of the above state-machine. Or more exactly, it exposes a simplified version and handles some of the complexity behind the scene for you. As clients, Ogmios will give you 3 possible requests: Acquire, Query, Release. A typical sequence would be to start by Acquiring a state on a given point and then make a few queries, and then release. The release step is optional although it is a bit more polite to say goodbye at the end of a conversation.\nIt is also possible to submit queries directly without acquiring. As a consequence, Ogmios will acquire the tip of the chain, run the query and release it for you. This is the easiest way to send queries if you don\u0026rsquo;t care about capturing a particular state. Note however that this may create race conditions if you send multiple queries via this method. Indeed, the tip is changing quite often on the network, and two subsequent queries may actually run on two different points of the chain. While this is generally safe for most queries, it may also put your application in an unexpected state when crossing epoch boundaries or hard-forks.\nAcquire The Acquire request expect one argument named point. The point has the same format as points in the local-chain-sync protocol. That is, they can be block header hashes or the special keyword \u0026quot;origin\u0026quot; (though there\u0026rsquo;s very little chance that one will be able to acquire the origin!).\n{ \u0026#34;type\u0026#34;: \u0026#34;jsonwsp/request\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0\u0026#34;, \u0026#34;servicename\u0026#34;: \u0026#34;ogmios\u0026#34;, \u0026#34;methodname\u0026#34;: \u0026#34;Acquire\u0026#34;, \u0026#34;args\u0026#34;: { \u0026#34;point\u0026#34;: \u0026#34;9e871633f7aa356ef11cdcabb6fdd6d8f4b00bc919c57aed71a91af8f86df590\u0026#34; } } One thing that doesn\u0026rsquo;t strike as obvious is that, as clients, you need points to query any information. There are many ways to get those hashes but in the context of Ogmios, the most logical way is via the local-chain-sync protocol.\nYou can acquire multiple times, the last one will prevail. If you need to re-acquire, simply send another Acquire request.\n Query There are many queries that can be sent to the ledger, and the list is growing days after days as the Cardano team implements new ones. With Ogmios, all queries follow the same pattern and use the method name Query. All of them also take one argument named query which specifies the query to run and, optionally some extra argument given to the query. For example:\n{ \u0026quot;type\u0026quot;: \u0026quot;jsonwsp/request\u0026quot;, \u0026quot;version\u0026quot;: \u0026quot;1.0\u0026quot;, \u0026quot;servicename\u0026quot;: \u0026quot;ogmios\u0026quot;, \u0026quot;methodname\u0026quot;: \u0026quot;Query\u0026quot;, \u0026quot;args\u0026quot;: { \u0026quot;query\u0026quot;: \u0026quot;ledgerTip\u0026quot; } } At the moment of writing this guide, the following queries are available:\n   Query Result     eraStart The information regarding the beginning of the current era.   ledgerTip The most recent block tip known of the ledger.   currentEpoch The current epoch of the ledger.   nonMyopicMemberRewards Non-myopic member rewards for each pool. Used in ranking.   delegationsAndRewards Current delegation settings and rewards of given reward accounts.   currentProtocolParameters The current protocol parameters.   proposedProtocolParameters The last update proposal w.r.t. protocol parameters, if any.   stakeDistribution Distribution of the stake across all known stake pools.   utxo Current UTxO, possibly filtered by address.   genesisConfig Get a compact version of the era\u0026rsquo;s genesis configuration.    To know more about arguments and results of each query, have a look at the API reference.\nSimplified Example In this example, we\u0026rsquo;ll consider a simple direct query on the network tip to fetch the latest protocol parameters. The next section gives a more elaborate example which shows how to acquire a specific point on chain.\nconst WebSocket = require(\u0026#39;ws\u0026#39;); const client = new WebSocket(\u0026#34;ws://localhost:1337\u0026#34;); function wsp(methodname, args) { client.send(JSON.stringify({ type: \u0026#34;jsonwsp/request\u0026#34;, version: \u0026#34;1.0\u0026#34;, servicename: \u0026#34;ogmios\u0026#34;, methodname, args })); } client.once(\u0026#39;open\u0026#39;, () =\u0026gt; { wsp(\u0026#34;Query\u0026#34;, { query: \u0026#34;currentProtocolParameters\u0026#34; } ); }); client.on(\u0026#39;message\u0026#39;, function(msg) { const response = JSON.parse(msg); console.log(JSON.stringify(response.result, null, 4)); client.close(); }); This little excerpt outputs the most recent protocol parameters in a nice JSON:\n{ \u0026#34;poolDeposit\u0026#34;: 500000000, \u0026#34;protocolVersion\u0026#34;: { \u0026#34;minor\u0026#34;: 0, \u0026#34;major\u0026#34;: 3 }, \u0026#34;minUtxoValue\u0026#34;: 1000000, \u0026#34;minFeeConstant\u0026#34;: 155381, \u0026#34;maxTxSize\u0026#34;: 16384, \u0026#34;minPoolCost\u0026#34;: 340000000, \u0026#34;maxBlockBodySize\u0026#34;: 65536, \u0026#34;extraEntropy\u0026#34;: \u0026#34;neutral\u0026#34;, \u0026#34;minFeeCoefficient\u0026#34;: 44, \u0026#34;poolInfluence\u0026#34;: \u0026#34;3/10\u0026#34;, \u0026#34;maxBlockHeaderSize\u0026#34;: 1100, \u0026#34;stakeKeyDeposit\u0026#34;: 2000000, \u0026#34;decentralizationParameter\u0026#34;: \u0026#34;1/5\u0026#34;, \u0026#34;desiredNumberOfPools\u0026#34;: 500, \u0026#34;poolRetirementEpochBound\u0026#34;: 18, \u0026#34;monetaryExpansion\u0026#34;: \u0026#34;3/1000\u0026#34;, \u0026#34;treasuryExpansion\u0026#34;: \u0026#34;1/5\u0026#34; } Full Example Let\u0026rsquo;s see a full example getting the stake distribution of all stake pools of the Cardano mainnet. In the example, we\u0026rsquo;ll also use the FindIntersect method from the local-chain-sync protocol to get an easy point to acquire.\nconst WebSocket = require(\u0026#39;ws\u0026#39;); const client = new WebSocket(\u0026#34;ws://localhost:1337\u0026#34;); function wsp(methodname, args) { client.send(JSON.stringify({ type: \u0026#34;jsonwsp/request\u0026#34;, version: \u0026#34;1.0\u0026#34;, servicename: \u0026#34;ogmios\u0026#34;, methodname, args })); } client.once(\u0026#39;open\u0026#39;, () =\u0026gt; { wsp(\u0026#34;FindIntersect\u0026#34;, { points: [\u0026#34;origin\u0026#34;] }); }); client.on(\u0026#39;message\u0026#39;, function(msg) { const response = JSON.parse(msg); switch (response.methodname) { case \u0026#34;FindIntersect\u0026#34;: const point = response.result.IntersectionFound.tip; wsp(\u0026#34;Acquire\u0026#34;, { point }); break; case \u0026#34;Acquire\u0026#34;: wsp(\u0026#34;Query\u0026#34;, { query: \u0026#34;stakeDistribution\u0026#34; }); break; case \u0026#34;Query\u0026#34;: console.log(response.result); client.close(); break; } }); Here\u0026rsquo;s a walk-though describing what happens when running the above script:\n  An initial request ask to FindIntersect that is guaranteed to succeed is sent. This is a little trick in order to access the ledger tip easily. As a response, Ogmios replies with:\n  IntersectionFound   { \u0026#34;version\u0026#34;: \u0026#34;1.0\u0026#34;, \u0026#34;servicename\u0026#34;: \u0026#34;ogmios\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;jsonwsp/response\u0026#34;, \u0026#34;methodname\u0026#34;: \u0026#34;FindIntersect\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;IntersectionFound\u0026#34;: { \u0026#34;point\u0026#34;: \u0026#34;origin\u0026#34;, \u0026#34;tip\u0026#34;: { \u0026#34;hash\u0026#34;: \u0026#34;dbafebb0146b2ec45186dfba6c287ad69c83d3fd9a186b39d99ab955631539e0\u0026#34;, \u0026#34;blockNo\u0026#34;: 4887546, \u0026#34;slot\u0026#34;: 12526684 } } }, \u0026#34;reflection\u0026#34;: null }      Using the tip from the previous response, we can now safely Acquire a state on that particular tip which we know exists and is not too old. Ogmios replies successfully with:\n  AcquireSuccess   { \u0026#34;version\u0026#34;: \u0026#34;1.0\u0026#34;, \u0026#34;servicename\u0026#34;: \u0026#34;ogmios\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;jsonwsp/response\u0026#34;, \u0026#34;methodname\u0026#34;: \u0026#34;Acquire\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;AcquireSuccess\u0026#34;: { \u0026#34;acquired\u0026#34;: { \u0026#34;hash\u0026#34;: \u0026#34;dbafebb0146b2ec45186dfba6c287ad69c83d3fd9a186b39d99ab955631539e0\u0026#34;, \u0026#34;slot\u0026#34;: 12526684 } } }, \u0026#34;reflection\u0026#34;: null }      Now in a position to make an actual Query, we do it and ask for the stake distribution across all stake pools. The (truncated) response from the server looks like:\n  QueryResponse   { \u0026#34;version\u0026#34;: \u0026#34;1.0\u0026#34;, \u0026#34;servicename\u0026#34;: \u0026#34;ogmios\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;jsonwsp/response\u0026#34;, \u0026#34;methodname\u0026#34;: \u0026#34;Query\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;pool1w3s6gk83y2g3670emy3yfjw9myz3u4whph7peah653rmsfegyj3\u0026#34;: { \u0026#34;stake\u0026#34;: 0, \u0026#34;vrf\u0026#34;: \u0026#34;29c1a293c550beea756bc0c01416bacd7030ae8992e13ca242d4d6c2aebaac0d\u0026#34; }, \u0026#34;pool1n5shd9xdt4s2gm27fxcnuejaqhhmpepn6chw2c82kqnuzdtpsem\u0026#34;: { \u0026#34;stake\u0026#34;: 0.00003058882418046271, \u0026#34;vrf\u0026#34;: \u0026#34;7e363eb8bfd8fef018da4c397d6a6ec25998363434e92276e40ee6c706da3ae5\u0026#34; }, \u0026#34;...\u0026#34; }, \u0026#34;reflection\u0026#34;: null }      Be aware that it is possible for an Acquire request to fail even if (and in particular if) made immediately after finding the ledger tip. In Ouroboros Praos frequent small rollbacks of the chain are not rare and the few last blocks of the chain can be a bit volatile. A real application may require more elaborate error handling than the toy example above.\n "},{"uri":"https://ogmios.dev/getting-started/testing/","title":"Testing","tags":[],"description":"","content":" You may skip this section if you\u0026rsquo;re not interested in contributing to Ogmios.\n ğŸ”§ Unit Tests First, make sure to pull and update git submodules:\n$ git submodule update --init Then, simply use stack as follows:\n$ stack test ogmios:unit ğŸ’¨ Smoke Tests Run the whole components stack using docker-compose as follows:\n$ docker-compose up Assuming the default configuration, Ogmios should be listening on :1337. Make sure that cardano-node is up-and-running and has finished its bootstraping phase (Ogmios should no longer print any warnings about HealthFailedToConnect). Then, open your favorite browser and visit http://localhost:1337/tests.html.\nTo tear down, press CTRL+C and then run:\n$ docker-compose down "},{"uri":"https://ogmios.dev/api-reference/","title":"API Reference","tags":[],"description":"","content":"Ogmios as a JSON-WSP service is entirely described using JSON Schema - Draft 7. This can be fed into various tools to generate code, data-types or definitions in many languages. Ogmios is tested against this schema as well, to make sure that it remains up-to-date as new features are added.\n Explore JSON Schema   Download JSON Schema  "},{"uri":"https://ogmios.dev/getting-started/monitoring/","title":"Monitoring","tags":[],"description":"","content":"Dashboard Ogmios offers a simple dashboard through HTTP with a real-time visualization of some of the server runtime metrics. If you\u0026rsquo;ve Ogmios up-and-running on the default port, visit http://localhost:1337 to view Ogmios' dashboard.\nHealth / Metrics Behind the scene, the dashboard is powered by metrics served over HTTP as JSON by the server. Reach /health (e.g. http://localhost:1337/health to get real-time information about your running server, including runtime metrics.\n$ curl -H 'Accept: application/json' http://localhost:1337/health { \u0026#34;metrics\u0026#34;: { \u0026#34;totalUnrouted\u0026#34;: 1, \u0026#34;totalMessages\u0026#34;: 30029, \u0026#34;runtimeStats\u0026#34;: { \u0026#34;gcCpuTime\u0026#34;: 1233009354, \u0026#34;cpuTime\u0026#34;: 81064672549, \u0026#34;maxHeapSize\u0026#34;: 41630, \u0026#34;currentHeapSize\u0026#34;: 1014 }, \u0026#34;totalConnections\u0026#34;: 10, \u0026#34;sessionDurations\u0026#34;: { \u0026#34;max\u0026#34;: 57385, \u0026#34;mean\u0026#34;: 7057, \u0026#34;min\u0026#34;: 0 }, \u0026#34;activeConnections\u0026#34;: 0 }, \u0026#34;startTime\u0026#34;: \u0026#34;2021-03-15T16:16:41.470782977Z\u0026#34;, \u0026#34;lastTipUpdate\u0026#34;: \u0026#34;2021-03-15T16:28:36.853115034Z\u0026#34;, \u0026#34;lastKnownTip\u0026#34;: { \u0026#34;hash\u0026#34;: \u0026#34;c29428f386c701c1d1ba1fd259d4be78921ee9ee6c174eac898245ceb55e8061\u0026#34;, \u0026#34;blockNo\u0026#34;: 5034297, \u0026#34;slot\u0026#34;: 15520688 }, \u0026#34;networkSynchronization\u0026#34;: 0.99, \u0026#34;currentEra\u0026#34;: \u0026#34;Mary\u0026#34; } All information are computed at runtime and not preserved between restarts (at least not yet). The health response includes:\n   field description     startTime UTC timestamp at which the server was started.   lastTipUpdate UTC timestamp when lastKnownTip was last updated (can be null)   lastKnownTip Last known chain tip received from the node (can be null)   networkSynchronization A percentage indicator of how far the server/node is from the network tip. 1 means it is synchronized.   currentEra The current Cardano era of the underlying node. Useful for state-queries and debugging.   metrics.activeConnections Number of WebSocket connections currently established with the server.   metrics.totalConnections Total number of WebSocket connections established with the server since it\u0026rsquo;s started.   metrics.sessionDurations Some time measures (min, max, mean) of the duration of each sessions, in milliseconds.   metrics.totalMessages Total number of messages received from all / any WebSocket connections.   metrics.totalUnrouted Total number of invalid messages not routed to one of the mini-protocols, received from all / any WebSocket connections.   metrics.runtimeStats.gcCpuTime Time spent by the garbage collector cleaning up previously allocated data objects, in nano-seconds.   metrics.runtimeStats.cpuTime Time spent by the CPU doing work (at the last GC), in nano-seconds.   metrics.runtimeStats.maxHeapSize Maximum live data allocated in the heap, in kilo-bytes.   metrics.runtimeStats.currentHeapSize Current live data allocated in the heap, in kilo-bytes.    All dates / timestamps are given as ISO-8601 date-time strings.\n Runtime metrics (i.e. runtimeStats) are only available when the server is started with the +T runtime flag. This is the case by default, but can be manually turned on and off using the +RTS / -RTS options. For example ogmios --node-socket /path/to/socket +RTS -T -RTS will run Ogmios with runtime stats activated.\n "},{"uri":"https://ogmios.dev/getting-started/basics/","title":"Basics","tags":[],"description":"","content":"JSON-WSP Ogmios' interface is built on top of JSON-WSP which is a tiny standard to give some structure to the various messages that can be exchanged with Ogmios. The standard specifies a top-level JSON envelope by which messages must abide, as well as a semantic for some of the fields. In particular, there are 4 types of messages possible in JSON-WSP:\n descriptions requests responses faults (which are a special kind of responses).  We won\u0026rsquo;t be covering the JSON-WSP standard in this guide but gives a few extra insights about how it relates to Ogmios and some good takes from it. Each request in Ogmios yields exactly one response, might it be a normal response or a fault. Furthermore, requests which relate to a particular protocol are guaranteed to yield responses in the same order.\nRequests Requests messages are sent by client applications (you) to Ogmios. Requests have 3 fields of interest: methodname, args and mirror. The methodname identifies the request itself and translates to a corresponding message of one of the 3 Ouroboros mini-protocols. Possible values for the methodname are described in section 3 - Ouroboros mini-protocols and the complete reference is available in section 4 - API Reference.\nHere is an example of valid request message:\n{ \u0026#34;type\u0026#34;: \u0026#34;jsonwsp/request\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0\u0026#34;, \u0026#34;servicename\u0026#34;: \u0026#34;ogmios\u0026#34;, \u0026#34;methodname\u0026#34;: \u0026#34;FindIntersect\u0026#34;, \u0026#34;args\u0026#34;: { \u0026#34;points\u0026#34;: [ \u0026#34;origin\u0026#34; ] }, \u0026#34;mirror\u0026#34;: { \u0026#34;step\u0026#34;: \u0026#34;INIT\u0026#34; } } As you can see, the methodname specifies the method FindIntersect which relates to the local chain-sync Ouroboros mini-protocol. This particular request expects one argument named points, which contains a list of points we want to intersect with (don\u0026rsquo;t panic, this is explained in further details in the next section!). Another interesting, albeit optional, field is the mirror field. This is completely free-form and will be spit back identically by Ogmios in the response. This can be useful to keep track of states on the client application or pass in extra context to each request/response. Be careful though that anything you send for a request will come back in the response; send something big, get something big.\nResponses Let\u0026rsquo;s start with a possible response to the request above:\n{ \u0026quot;type\u0026quot;: \u0026quot;jsonwsp/response\u0026quot;, \u0026quot;version\u0026quot;: \u0026quot;1.0\u0026quot;, \u0026quot;servicename\u0026quot;: \u0026quot;ogmios\u0026quot;, \u0026quot;methodname\u0026quot;: \u0026quot;FindIntersect\u0026quot;, \u0026quot;result\u0026quot;: { \u0026quot;IntersectionFound\u0026quot;: { \u0026quot;point\u0026quot;: \u0026quot;origin\u0026quot;, \u0026quot;tip\u0026quot;: { \u0026quot;hash\u0026quot;: \u0026quot;d184f428159290bf3558b4d1d139e6a07ec6589738c28a0925a7ab776bde4d62\u0026quot;, \u0026quot;blockNo\u0026quot;: 4870185, \u0026quot;slot\u0026quot;: 12176171 } } }, \u0026quot;reflection\u0026quot;: { \u0026quot;step\u0026quot;: \u0026quot;INIT\u0026quot; } } The response kindly indicates which requests it corresponds to and has the same methodname as the matching request. It also gives a result under a specific field. Responses can have various results which are fully specified in section 4. - API Reference. Also, notice the reflection field which reflects exactly the mirror field that was set for the request.\nOgmios' responses may correspond to possible errors that are part of the Ouroboros mini-protocols. For example, if you submit an invalid transaction, you\u0026rsquo;ll get back a message of type jsonwsp/response because it is a valid message in the context of the mini-protocols. Yet, Ogmios will yield a message of type jsonwsp/fault if you submit an invalid Ogmios message (for instance, an unknown request constructor, or something that is not a valid JSON-WSP message).\n WebSocket Ogmios uses WebSocket as a communication protocol. The WebSocket protocol is full-duplex, which means that Ogmios and clients can send messages to each other all at the same time. That is very convenient for clients who can pipeline many requests at once and process responses later on as they arrive.\nTherefore, to send a message to ogmios, you only need a WebSocket client! For example, using the well-established ws Node.js package and assuming a local instance of Ogmios started through Docker, you can interact with Ogmios as simply as:\nconst WebSocket = require(\u0026#39;ws\u0026#39;); const client = new WebSocket(\u0026#34;ws://localhost:1337\u0026#34;); client.once(\u0026#39;open\u0026#39;, () =\u0026gt; { const request = { \u0026#34;type\u0026#34;: \u0026#34;jsonwsp/request\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0\u0026#34;, \u0026#34;servicename\u0026#34;: \u0026#34;ogmios\u0026#34;, \u0026#34;methodname\u0026#34;: \u0026#34;FindIntersect\u0026#34;, \u0026#34;args\u0026#34;: { \u0026#34;points\u0026#34;: [ \u0026#34;origin\u0026#34; ] } }; client.send(JSON.stringify(request)); }); client.on(\u0026#39;message\u0026#39;, function(msg) { const response = JSON.parse(msg); // do something with \u0026#39;response\u0026#39; }); That\u0026rsquo;s all for the basics. The rest isn\u0026rsquo;t really specific to Ogmios, but is about the Ouroboros mini-protocols themselves. See the next sections for a deep dive!\n"},{"uri":"https://ogmios.dev/changelog/","title":"Changelog","tags":[],"description":"","content":"edge / unreleased Added   Integrated with the Cardano eco-system corresponding to cardano-node@1.27.0. Bumped the docker-compose installation accordingly.\n  Three new possible errors from the transaction submission coming with cardano-node@1.27.0:\n mirTransferNotCurrentlyAllowed mirNegativeTransferNotCurrentlyAllowed mirProducesNegativeUpdate  These errors are related to transactions issuing MIR certificates which can only be done by genesis delegates. So this change should not impact any \u0026lsquo;standard\u0026rsquo; user.\n  Changed   The moveInstantaneousRewards certificates have a new optional field value and not only a rewards map as before. When value is present, it signifies that rewards are moved to the other pot.\n  The \u0026lsquo;networkMismatch` error can now also be related to a mismatch from the network and the reward account coming from a pool registration certificate.\n  Removed Ã¸\n[3.2.0] - 2021-05-09 Added  New TypeScript client! The client comes in three packages:  An interactive REPL to play with Ogmios using the command-line. A generator to derive TypeScript type definitions from the JSON schema. The actual client library providing nice wrapper around the various protocol, in a typed way. The TypeScript client also includes a new battery of automated integration tests against the testnet.   Support for WebSocket sub-protocols, with currently one support sub-protocol: ogmios.compact.v1. When enabled, Ogmios will omit fields such as witnesses, proofs and signatures from responses to make responses smaller. Provide missing documentation / JSON-schema for:  JSON-WSP faults Allegra \u0026amp; Mary SubmitTx failures:   Allegra:\n expiredUtxo is replaced by outsideOfValidityInterval new error triesToForgeAda  Mary:\n valueNotConserved.consumed is now a Value (instead of a DeltaCoin) valueNotConserved.produced is now a Value (instead of a DeltaCoin) outputTooSmall items are now of type TxOut[Mary] new error tooManyAssetsInOutput       Continuous integration job checking for code style and lint on the server source code. The /health endpoint now returns two additional pieces of information:  A networkSynchronization percentage to indicate how far Ogmios / the node is from the network. A currentEra value to indicate the corresponding Cardano era Ogmios / the node is currently running in.   Nix support for building Ogmios (this also include a cabal.project to enable cabal support as well).  Changed  Rework Docker setup to not require an external snapshot image. Everything is now built in a single Dockerfile, but cache from DockerHub can be leveraged to reduce overall build time when building from scratch. Fixed typo in the JSON-schema w.r.t to the \u0026lsquo;Acquire\u0026rsquo; request (points â†’ point), and introduce more automated test to catch this kind of errors more easily.  Removed Ã¸\n[3.1.0] - 2021-04-04 Added  Extend the local-state query protocol with support for \u0026lsquo;GetCompactGenesis\u0026rsquo;. Extend the local-state query protocol with support for \u0026lsquo;GetFilteredDelegationsAndRewards\u0026rsquo;. Add missing mint field to transaction\u0026rsquo;s body (added since mary). The documentation is now hosted on https://ogmios.dev.  Changed  Use \u0026lsquo;contentEncoding\u0026rsquo; over \u0026lsquo;format\u0026rsquo; in appropriate part of the JSON schema. Fix various errors in the JSON-schema definition \u0026amp; extend test suite coverage in consequence. Implement a \u0026lsquo;fast-bech32\u0026rsquo; encoding library, to speed-up Ogmios serialization of blocks beyond the Shelley era. Use faster (and recommended) JSON encoding techniques to speed up overall JSON serialization. Improve generated documentation from JSON schema by:  Providing titles to \u0026lsquo;oneOf\u0026rsquo; items Adding descriptions to top-level definitions Adding examples to top-level definitions   Customized API reference\u0026rsquo;s stylesheet to enhance readability. Upgrade dependency and code to work with GHC-8.10.4 (from GHC 8.6.5) Handle more gracefully unknown exceptions (avoid infinite fast loop of retries on errors). Handle more gracefully network mismatches (e.g. connecting Ogmios in testnet mode to a mainnet network) Repository reorganization:  \u0026lsquo;ogmios-server\u0026rsquo; renamed into \u0026lsquo;server\u0026rsquo; move Haskell-specific dotfiles and configuration files under \u0026lsquo;server\u0026rsquo; move \u0026lsquo;modules\u0026rsquo; under \u0026lsquo;server\u0026rsquo; move \u0026lsquo;Dockerfile\u0026rsquo; and \u0026lsquo;snapshot.Dockerfile\u0026rsquo; under \u0026lsquo;server\u0026rsquo;    Removed  Support for GHC-8.6.5 The docker image no longer shows git revision / version on \u0026lsquo;\u0026ndash;version\u0026rsquo;  [3.0.0] \u0026ndash; 2021-02-26 Added  Support for the Allegra era on the chain-sync, tx submission and state query protocols. Support for the Mary era on the chain-sync, tx submission and state query protocols. Support for multi-era state queries, or said differently, Ogmios can survive a hard-fork without being restarted or re-compiled. Allow clients to also make state queries based on the node\u0026rsquo;s tip (instead of passing an explicit point to acquire). Interactive dashboard leveraging Ogmios health\u0026rsquo;s endpoint and local state query protocol to show metrics in real-time. Automated smoke sanity tests executed on a running instance, running queries and chain-syncs across all eras. Various internal optimization, in particular with rewards to the chain-sync protocol (~14.000 blocks/s in Byron, ~2500 block/s in Shelley and beyond). Additional metrics for monitoring: current heap size, total messages, total unrouted messages and start time. Configurable HTTP server timeout from the command-line, with sensible defaults.  Changed  Improve error responses to invalid clients\u0026rsquo; requests (instead of generic error messages). Fixed various typos and clumsy wording in the user manual. Reworked internal architecture as a Three-Layer Haskell Cake. Changed internal dependencies for base16 and base64 encoding for better performances. Upgraded internal dependencies to the Cardano eco-system working with cardano-node@1.25.1 Improved error handling of the Ogmios server, in particular in case of connections lost with the underlying node. The server now returns an explicit client error when interleaving \u0026lsquo;FindIntersect\u0026rsquo; messages in-between pipelined \u0026lsquo;RequestNext\u0026rsquo;. Revised default compilation flags .  Removed Ã¸\n[2.0.0-beta] \u0026ndash; 2020-10-31 Added  Support for the Shelley chain in the local-chain-sync protocol. Support for the local-state-query protocol. Health / Heartbeat endpoint for monitoring. Runtime and application metrics measured and served on endpoint (/health). Ogmios now includes an HTTP static server hosting both the WSP definition and, a /benchmark.html to run some quick benchmark / smoke test. Added additional configuration options via command-line or environment. Revised user manual with detailed step-by-step examples.  Changed  Several JSON fields renamed to increase consistency between Shelley and Byron. Improved logging, more messages and with more context. Improved error handling with regards to connection of websocket clients.  Removed Ã¸\nChanged [1.0.0-beta] \u0026ndash; 2020-04-04 Added   Initial release and support for:\n Chain Synchronization (no pipelining between cardano-node \u0026amp; ogmios) Local Transaction Submission    JSON-WSP version 1.0, full support with reflection.\n  Full docker stack via docker-compose.\n  Basic command-line and logging.\n  Changed Ã¸\nRemoved Ã¸\n"},{"uri":"https://ogmios.dev/faq/","title":"F.A.Q","tags":[],"description":"","content":"Can you explain Ogmios in one three sentences? Ogmios is a protocol translation service written in Haskell running on top of cardano-node. It offers a JSON interface through WebSockets and enables applications to speak Ouroboros' client mini-protocols via remote procedure calls. Ogmios is a fast and lightweight solution that can be deployed alongside relays to create entry points on the Cardano network for various types of applications (e.g. wallets, explorers, chatbots, dashboardsâ€¦).\nCan you explain Ogmios to me like I\u0026rsquo;m five? To understand what Ogmios is, you must first understand where it fits in Cardano landscape. Cardano is a network of programs (a.k.a nodes) connected to each other and exchanging messages to run the Cardano blockchain. A Cardano node has an interface that allows for other programs to interact with it (very much like buttons on a remote to control the TV). However, that interface relies on novel communication methods, that were designed in-house by the networking team at IOG. To this day, the only tooling that can implement those unique communication methods is written in Haskell (as if all the buttons on the remote control were in Chinese, but you only speak French). So to interact with a Cardano node, one has no other choice than to write a Haskell program, which is a bummer for many application developers.\nThis is where Ogmios comes into play. Ogmios is written in Haskell, so it can speak with Cardano nodes just fine. But it also translates all the interfaces provided by the node using communication methods that are more common and accessible to the vast majority of developers (namely, WebSockets \u0026amp; JSON). Ogmios is a sort of translator; instead of speaking to a Cardano node directly, applications can speak to Ogmios using a language they know, and Ogmios translates it to the node and back to the applications.\nWhere does the name come from? Ogmios is a celtic deity of eloquence, language and learning. This relates to the way this project helps users communicate with Cardano. And while it doesnâ€™t translate languages, it translates protocols to protocols.\nWhy do I care? Well, it depends. In essence, Ogmios doesn\u0026rsquo;t do much more than what the node itself does. It\u0026rsquo;s pretty much as low-level as things can get with the Cardano network. For many applications, this is too low in the abstraction layer and they would be better off using higher-level services like cardano-graphql, Rosetta, or Blockfrost.\nHowever, building such services demands to be able to interact with the blockchain using a more direct interface. This interface can be Ogmios. Currently, the choices given to services like these are limited: talk directly to the node using the Haskell client library, or use cardano-db-sync which is a component that talks to the node and dumps blockchain data in a PostgreSQL database. For those who don\u0026rsquo;t write Haskell, the choice is even more limited; down to a single option. Plus, like any solution, it comes with trade-offs. Deploying a cardano-db-sync instance can be quite heavy, requires extra space, and already forces applications to operate in some specific ways. Ogmios gives a lightweight alternative that is also much closer to what the node offers. It would be possible for example to re-implement cardano-db-sync in a different programming language using Ogmios.\nSo in the end, if you\u0026rsquo;re writing a DApp or an application that needs to interact with the Cardano blockchain only at a high level using pre-defined abstractions, then you probably don\u0026rsquo;t care. However, if you\u0026rsquo;re doing some low-level work, and need to access every bit of the protocol or, if you\u0026rsquo;re building a service on top of Cardano for which the blockchain itself is the right level of abstraction, then Ogmios is most likely a good fit for you.\nCan I build X using Ogmios? The short answer is: if you can build X with a Cardano node, then yes. Ogmios is as capable as the client interface for Cardano nodes. Can I build a wallet with Ogmios? Yes. Can I build an explorer with Ogmios? Yes. Can I build a smart-contract application backend with Ogmios? Yes. Anything available on-chain is available through Ogmios which has so far also transitioned through the 4 eras of Cardano. Ogmios' first release was a bit before the Shelley hard-fork, and its development followed the on-chain upgrades and protocol updates.\nWhat\u0026rsquo;s the overhead from running Ogmios? Almost none. Ogmios runs within a handful of megabytes of memory and its CPU usage is very much driven by whatever application you\u0026rsquo;ll be connecting to it. That is if your application is syncing the entire blockchain and sending thousands of messages per second to the underlying node, then of course your CPU will get pretty busy; not from Ogmios itself, however, but mostly from the underlying node and your client. In between, Ogmios acts as a bridge and passes messages around. Once a message has been passed, Ogmios forgets about it. That makes the memory footprint of Ogmios quite low, and its resource usages tightly linked to whatever application consumes data from it.\nI secretly keep a hope that someday, many operators will deploy Ogmios alongside their relays. Enabling many application developers to interact with the Cardano blockchain seamlessly by connecting to a relay close to them.\nIs there any client for Ogmios? As a matter of fact, there is. A TypeScript client library and REPL have been developed by a colleague of mine (thanks again Rhys, you\u0026rsquo;re awesome!). This is huge and comparable to what web3.js is for Ethereum. And this is only a beginning. We\u0026rsquo;ll keep working on this to grow the client into a more capable SDK for Cardano. In a future where Ogmios is deployed alongside relays, it could become dead simple to get started with web applications development for Cardano. Simply import the TypeScript client, connect to a relay nearby and start hacking.\nBesides, it goes without saying that as an open-source project Ogmios welcomes contributions; especially on the client library and/or around tools built on top.\nIs Ogmios production ready? Probably, yes. But I\u0026rsquo;d like to point that I am obviously biased on this topic. I am myself a professional and seasoned software engineer and I\u0026rsquo;ve helped to put various systems in production throughout my career. Ogmios is nevertheless an open-source project I\u0026rsquo;ve been working on during my free time, I\u0026rsquo;ve got a mad passion for software quality and I have put quite a lot of effort into making Ogmios of the highest quality.\nI\u0026rsquo;ve been testing various parts of Ogmios using in particular property testing and generators from the Cardano consensus and ledger codebases. The interfaces are well-documented, and the code itself follows a strict organization while abiding by Haskell battle-tested coding practices and code architecture. The application also comes with logging and metrics for monitoring and has already undergone a few rounds of optimizations.\nNow, this is as good as it gets for an open-source project. I\u0026rsquo;ve been incorporating feedback from various users over the past year which has been great so far. For the rest, everything is open-source licensed under MPL-2.0 and you\u0026rsquo;re the best judge.\nAre there any projects using it? I\u0026rsquo;ve got some positive feedback from a handful of stake pool operators using it for various projects, for example:\n https://gimbalabs.com/dandelionapis/ogmios-api https://www.f2lb.org/  There are also projects in preparation which looked into Ogmios as an alternative to cardano-db-sync for it better suited their need. Ogmios only reached a good enough feature-set and stability recently, thus most projects currently using it are still in the hoven. With the Ogmios TypeScript client now available, I have also good hope that more and more projects will see the light. This goes hand-and-hand with adoption from stake pools relays of course: the more relays are avaiable and provide entry points to the network, the more applications can rely on it.\n"},{"uri":"https://ogmios.dev/","title":"Overview","tags":[],"description":"","content":"Ogmios Ogmios is a protocol translation service written in Haskell running on top of cardano-node. It offers a JSON interface through WebSockets and enables applications to speak Ouroboros' client mini-protocols via remote procedure calls. Ogmios is a fast and lightweight solution that can be deployed alongside relays to create entry points on the Cardano network for various types of applications (e.g. wallets, explorers, chatbots, dashboards\u0026hellip;).\n Need more information? Have a look at the Frequently Asked Questions!\n"},{"uri":"https://ogmios.dev/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"https://ogmios.dev/tags/","title":"Tags","tags":[],"description":"","content":""}]