[{"uri":"https://ktorz.github.io/cardano-ogmios/getting-started/","title":"Getting Started","tags":[],"description":"","content":"Getting Started Find in this section information about building and running Ogmios. This will cover installation from both sources and docker 🐳, as well as details about options and configuration for running Ogmios.\n"},{"uri":"https://ktorz.github.io/cardano-ogmios/deployment/aws/","title":"AWS","tags":[],"description":"","content":"Pre-Requisites   Make sure to have an AWS account, and an AWS_ACCESS_KEY_ID \u0026amp; AWS_SECRET_ACCESS_KEY.\n  Make sure to grant AmazonEC2FullAccess to your AWS user.\n  You\u0026rsquo;ll need to create a security group which allows inbound TCP connections. See also: Working With Security Groups.\n  Install docker-machine\n  Create an SSH key/pair $ ssh-keygen -t rsa -b 4096 -C \u0026quot;your_email@example.com\u0026quot; -f aws_rsa $ eval \u0026quot;$(ssh-agent -s)\u0026quot; $ ssh-add ~/.ssh/aws_rsa Create The Docker Machine AWS_ACCESS_KEY_ID=\u0026lt;YOUR_ACCESS_KEY_ID\u0026gt; AWS_SECRET_ACCESS_KEY=\u0026lt;YOUR_SECRET_KEY\u0026gt; docker-machine create -d amazonec2 \\  --amazonec2-access-key $AWS_ACCESS_KEY_ID \\  --amazonec2-secret-key $AWS_SECRET_ACCESS_KEY \\  --amazonec2-region eu-west-3 \\  --amazonec2-instance-type \u0026#34;t2.medium\u0026#34; \\  --amazonec2-ssh-keypath ~/.ssh/aws_rsa \\  aws-ogmios Push The Stack First, configure your shell and activate your docker-machine:\n$ eval $(docker-machine env aws-ogmios) Then, simply push the stack using docker-compose:\n$ COMPOSE_TLS_VERSION=TLSv1_2 docker-compose up -d  Compose may use a wrong TLS version for pulling layers from dockerhub. Hence the ENV var.\n 🎉 Enjoy $ docker-machine ls NAME ACTIVE DRIVER STATE URL SWARM DOCKER ERRORS aws-ogmios * amazonec2 Running tcp://xx.xxx.xxx.xxx:xxxx v19.03.8 (Optional) Adding TLS with a registered domain   Install nginx.\n    Configure a new server as /etc/nginx/sites-enabled/domain.extension   server { server_name DOMAIN.EXTENSION; listen 80; location ^~ /.well-known/acme-challenge/ { try_files $uri /dev/null =404; } }    👆 Make sure to replace \u0026lsquo;DOMAIN.EXTENSION\u0026rsquo; with your actual registered domain.\n  Reload your nginx configuration with: sudo systemctl reload nginx.service.\n  Install certbot and let certbot configure your nginx server (sudo certbot --nginx).\n  Once done, edit your nginx configuration one more time\u0026hellip;\n    Remove (no longer needed after certbot has successfully configured the server)   location ^~ /.well-known/acme-challenge/ { try_files $uri /dev/null =404; }        And add the following clause to enable routing all traffic (including WebSockets) to ogmios   location ~* / { proxy_pass http://localhost:1337; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \u0026#34;Upgrade\u0026#34;; proxy_set_header Host $host; }        The final configuration should look like this:\nserver { server_name ogmios.dev; location ~* / { proxy_pass http://localhost:1337; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \u0026#34;Upgrade\u0026#34;; proxy_set_header Host $host; } listen 443 ssl; # managed by Certbot  ssl_certificate /etc/letsencrypt/live/ogmios.dev/fullchain.pem; # managed by Certbot  ssl_certificate_key /etc/letsencrypt/live/ogmios.dev/privkey.pem; # managed by Certbot  include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot  ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot } server { server_name ogmios.dev; listen 80; if ($host = ogmios.dev) { return 301 https://$host$request_uri; } # managed by Certbot  return 404; # managed by Certbot } "},{"uri":"https://ktorz.github.io/cardano-ogmios/getting-started/docker/","title":"Docker","tags":[],"description":"","content":"🐳 The easiest way to get started is to use docker. This guide won\u0026rsquo;t cover installing docker, so make sure you have the docker daemon installed and running. Since Ogmios requires the presence of a Cardano node, we\u0026rsquo;ll be using docker-compose to orchestrate both services. A compose file is available on the Ogmios repository, get it via:\n$ wget https://raw.githubusercontent.com/KtorZ/cardano-ogmios/master/docker-compose.yml -O docker-compose.yml Then, starts the components stack using:\n$ docker-compose up 👆This will run and connect together:\n A Cardano node, connected to mainnet. An Ogmios server using the latest Dockerhub build, listening to localhost on port :1337.  To build the Ogmios image from sources, pass the --build flag. This is useful if you need a different version than the latest one available on Dockerhub.\nConfiguration The compose file allows for minimal (albeit useful) configuration parameters via environment variables:\n   Variable Description Values Default     NETWORK Which Cardano network to connect to. This impacts both Ogmios and the underlying Cardano node. mainnet, testnet mainnet   OGMIOS_PORT Which ports to listen to (both for WebSockets and health endpoints) Any valid port number. 1337    Ogmios doesn\u0026rsquo;t use any form of persistent storage, but cardano-node does. The mainnet and testnet databases are not compatible, so it is recommended to instrument docker-compose to use different namespaces for different networks (so that you can switch from one another without risking any database conflicts). Compose can do this easily by passing an extra flag: --project-name.\n For example, for running cardano-node + ogmios on the testnet, listening to tcp/1338, do:\n$ NETWORK=testnet OGMIOS_PORT=1338 docker-compose --project-name cardano-ogmios-testnet up "},{"uri":"https://ktorz.github.io/cardano-ogmios/mini-protocols/local-chain-sync/","title":"Local Chain Sync","tags":[],"description":"","content":"┌───────────┐ │ Intersect │◀══════════════════════════════╗ └─────┬─────┘ FindIntersect ║ │ ║ │ ┌──────────┐ │ Intersect.{Found,NotFound} │ │ └───────────────────────────────▶│ │ │ Idle │ ╔═══════════════════════════════════│ │ ║ RequestNext │ │⇦ START ║ └──────────┘ ▼ ▲ ┌──────┐ Roll.{Backward,Forward} │ │ Next ├────────────────────────────────────┘ └──────┘  Overview Clients that wish to synchronise blocks from the Cardano chain can use the Local Chain Sync protocol.\nThe protocol is stateful, which means that each connection between clients and Ogmios has a state: a cursor locating a point on the chain. Typically, a client will start by looking for an intersection between its own local chain and the one from the node / Ogmios. Then, it\u0026rsquo;ll simply request the next action to take: either rolling forward and adding new blocks, or rolling backward.\nHow To Use When a connection is opened with Ogmios, it automatically starts a local chain-sync session with the underlying cardano-node. There\u0026rsquo;s an implicit state maintained by the node which one can imagine as a cursor, pointing to a point on the Cardano chain. Initially, this cursor starts at a special point called: origin (as in, the origin of the chain). After each request, the node will move the cursor either forward or backward and remembers its location for the next request. To move the cursor, the protocols gives two mechanisms: RequestNext and FindIntersect.\n* -- * -- * -- * -- * -- * .. Cardano chain ^ | | origin RequestNext Clients may ask for the next block where \u0026lsquo;next\u0026rsquo; refers directly to that implicit cursor. This translates to a message with RequestNext as a method name. This request does not accept any arguments.\n{ \u0026#34;type\u0026#34;: \u0026#34;jsonwsp/request\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0\u0026#34;, \u0026#34;servicename\u0026#34;: \u0026#34;ogmios\u0026#34;, \u0026#34;methodname\u0026#34;: \u0026#34;RequestNext\u0026#34;, \u0026#34;args\u0026#34;: {} } As a response, Ogmios will send back a response which can be either RollForward or RollBackward. Rolling forward is pretty straightforward and is the main type of response one can expect; such response will include the next block, which itself includes a header, transactions, certificates, metadata and all sort of information.\nRolling backward however may occur when, since the last request, the underlying node decided to switch to a different fork of the chain to the extent that the previous cursor is no longer pointing to a block that exists on the chain. The node therefore asks (kindly) to roll backward to a previously known point that is the earliest ancestor that is common between the client\u0026rsquo;s own chain locally and the one that was just adopted by the node.\n* -- * -- * -- * (node's chain) / common chain prefix * \u0026lt;------------------------\u0026gt; / * -- * -- * -- * -- * -- * -- * -- * -- * -- * (local chain) ^ | | Point of rollback When rolling backward, the node will not provide a block but instead, a point which is made of a block header hash and a slot.\nAs a client, it is therefore crucial to be able to rollback to a previous point of the chain. In practice, Ouroboros guarantees that forks cannot be longer than a certain length. This maximum length is called k in the Ouroboros protocol, and also known as the security parameter.\n FindIntersect On the first connection with the node, clients will likely synchronize from the origin. Yet, on subsequent connections one may want to resume syncing to a point that is much more recent than the origin. Ideally, one would like to carry on exactly at the point where the chain was left yet as we just saw, this is not always possible. The local chain-sync protocol gives however clients a way to find a common intersection between a client\u0026rsquo;s current version of the chain and whatever version the node has. This is via the FindIntersect message. This message accepts one argument which is a list of header hashes (or the special keyword \u0026quot;origin\u0026quot;).\n{ \u0026#34;type\u0026#34;: \u0026#34;jsonwsp/request\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0\u0026#34;, \u0026#34;servicename\u0026#34;: \u0026#34;ogmios\u0026#34;, \u0026#34;methodname\u0026#34;: \u0026#34;FindIntersect\u0026#34;, \u0026#34;args\u0026#34;: { \u0026#34;points\u0026#34;: [ \u0026#34;9e871633f7aa356ef11cdcabb6fdd6d8f4b00bc919c57aed71a91af8f86df590\u0026#34;, \u0026#34;d184f428159290bf3558b4d1d139e6a07ec6589738c28a0925a7ab776bde4d62\u0026#34;, \u0026#34;origin\u0026#34; ] }, } If an intersection is found, great, the node will set the cursor to that point and let you know. If not, the cursor will remain where it was and the failure will also be broadcast. As we\u0026rsquo;ve seen in the previous section, a node may switch to longer forks based quite arbitrarily. Hence, a good list of intersections candidates is preferably dense near the tip of the chain, and goes far back in the past (k is typically not enough).\nFor example, imagine the following scenario:\nP01 P02 P03 P04 P05 P98 P99A P100A Local chain: * -- * -- * -- * -- * ... * -- * -- * P01 P02 P03 P04 P05 P98 P99B P100B Node's chain: * -- * -- * -- * -- * ... * -- * -- * As a client, providing any point before or at P98 will result in finding an intersection. Yet, if one only provides [P99A, P100A], the node will not be able to figure out where to continue the protocol and will remain at the origin.\nThe order of the list matters! The node will intersect with the best match, considering that the preferred points are first in the list. If one provides origin as a first point, an intersection is guaranteed to always find a match, and always at origin (and that is quite useless!).\n Full Example Let\u0026rsquo;s see a full example that is synchronizing the first 14 blocks of the Shelley chain and printing them to the console.\nconst WebSocket = require(\u0026#39;ws\u0026#39;); const client = new WebSocket(\u0026#34;ws://localhost:1337\u0026#34;); function wsp(methodname, args, mirror) { client.send(JSON.stringify({ type: \u0026#34;jsonwsp/request\u0026#34;, version: \u0026#34;1.0\u0026#34;, servicename: \u0026#34;ogmios\u0026#34;, methodname, args, mirror })); } client.once(\u0026#39;open\u0026#39;, () =\u0026gt; { const lastByronBlock = { slot: 4492799, hash: \u0026#34;f8084c61b6a238acec985b59310b6ecec49c0ab8352249afd7268da5cff2a457\u0026#34; }; wsp(\u0026#34;FindIntersect\u0026#34;, { points: [lastByronBlock] }); }); client.on(\u0026#39;message\u0026#39;, function(msg) { const response = JSON.parse(msg); switch (response.methodname) { case \u0026#34;FindIntersect\u0026#34;: if (!response.result.IntersectionFound) { throw \u0026#34;Whoops? Last Byron block disappeared?\u0026#34; } wsp(\u0026#34;RequestNext\u0026#34;, {}, { n: 14 }); break; case \u0026#34;RequestNext\u0026#34;: if (response.result.RollForward) { console.log(response.result); } if (response.reflection.n \u0026gt; 0) { wsp(\u0026#34;RequestNext\u0026#34;, {}, { n: response.reflection.n - 1 }); } else { client.close(); } break; } }); A few important takes from this excerpt:\n  The node streams blocks that are after the intersection point. Thus to get the first 14 Shelley blocks, one needs to set the intersection at the last Byron block!\n  After successfully finding an intersection, the node will always ask to roll backward to that intersection point. This is because it is possible to provide many points when looking for an intersection and the protocol makes sure that both the node and the client are in sync. This allows clients applications to be somewhat \u0026ldquo;dumb\u0026rdquo; and blindly follow instructions from the node.\n  In this schema, we are sending each request one-by-one, using the mirror field as counter. An alternative could have been:\ncase \u0026#34;FindIntersect\u0026#34;: if (!response.result.IntersectionFound) { throw \u0026#34;Whoops? First Shelley block disappeared?\u0026#34; } for (let i = 14; i \u0026gt; 0; i += 1) { wsp(\u0026#34;RequestNext\u0026#34;, {}); } break; We need not to wait for replies to send requests and can collect all responses at a later stage!\n  Note that Ogmios will do its best to pipeline requests to the Cardano node. Nevertheless, unlike WebSocket the local chain-sync protocol only allows for finite pipelining. Said differently, Ogmios cannot pipeline an arbitrary and potentially infinite number of requests and will actually starts collecting responses if too many requests are pipelined. So, if you\u0026rsquo;re pipelining many requests in a client application, make sure to also take times to collect some responses because there will be no extra benefits coming from too much pipelining.\n "},{"uri":"https://ktorz.github.io/cardano-ogmios/getting-started/building/","title":"Building","tags":[],"description":"","content":" You may skip this section if you\u0026rsquo;re using Docker 🐳.\n Pre-requisites Ogmios is built using the great Haskell build tool stack. You\u0026rsquo;ll also need git to clone the source code, that is:\n git 2.11.* stack 2.*.*  Ogmios in itself is a rather small project, yet it\u0026rsquo;s using library directly from the ouroboros-network, cardano-ledger-specs and cardano-node projects. This is handy for re-using existing logic, but comes at the cost of several system dependencies that are required for building everything. Some may already be installed on your system, but the complete list is:\n libsodium-dev 1.0.* libgmp-dev 6.1.* libssl-dev 1.1.* libpcre3-dev 2.8.* libsystemd-dev zlib1g-dev 1.2.*  🔨 Ogmios Clone the git repository from Github:\n$ git clone git@github.com:KtorZ/cardano-ogmios.git \u0026amp;\u0026amp; cd cardano-ogmios Then, use Stack to compile the project source code from the repository root:\n$ stack build ogmios The first time, this may take a while as Stack needs to setup a compilation environment and to download a lot of dependencies. Subsequent executions are much faster.\nFrom there, you can run Ogmios via stack using the exec command:\n$ stack exec -- ogmios --help Alternatively, you can instrument Stack to copy the compiled executable elsewhere so that you can run Ogmios all by itself:\n$ stack install ogmios $ ogmios --help 📚 Documentation API Reference Install json-schema-for-humans using pip3:\n$ pip3 install json-schema-for-humans And then, run:\n$ cd docs \u0026amp;\u0026amp; generate-schema-doc --config no_link_to_reused_ref ../ogmios.wsp.json index.html "},{"uri":"https://ktorz.github.io/cardano-ogmios/mini-protocols/local-tx-submission/","title":"Local Tx Submission","tags":[],"description":"","content":"┌──────────┐ │ Busy │◀══════════════════════════════╗ └────┬─────┘ SubmitTx ║ │ ║ │ ┌──────────┐ │ │ │ │ │ │ │ SubmitTxResponse │ Idle │ └───────────────────────────────▶│ │ │ │⇦ START └──────────┘  Overview Transaction submission is pretty simple \u0026amp; works by submitting an already serialized and signed transaction as one single message.\nIn case of success, Ogmios / the node returns an empty response. Otherwise, it returns an error with some details about what went wrong. Clients must thereby know how to construct valid transactions.\nDisclaimer The local tx-submission protocol is the simplest one in appearance. It nevertheless a quite extensive knowledge of the on-chain data-types used by Cardano. Indeed, the protocol in itself is straightforward so long as you already know how to produce and sign a transaction.\nThis guide doesn\u0026rsquo;t cover the creation and serialization of Cardano transactions. This is a rather vast topic and there is a handful of tools out there to help on the matter already, in particular:\n  cardano-serialization-lib which gives JavaScript and WASM bindings for every Cardano on-chain types.\n  cardano-transactions which offers a Haskell library and a command-line interface for constructing and signing transactions.\n  cardano-cli which offers another command-line interface for constructing and signing transactions.\n  In any case, one can always refer to the source CDDL specifications to know how to construct and serialize Cardano transactions.\nProviding a more user-friendly interface with regards to transactions in Ogmios is still under consideration. Yet, since in order to handle and sign transactions, one needs some knowledge about the on-chain binary format anyway, I\u0026rsquo;ve made the (effortless) choice to only treat with already serialized blobs in Ogmios. I am open to suggestions about how this could be made better, drop me a message on Github if you have ideas!\n How to Use Sending a transaction through the Cardano network requires one message using the method SubmitTx, and with a single mandatory arguments with bytes, representing a serialized signed transactions with its full witness.\nNote that JSON does not support embedding raw bytes in objects. Bytes needs therefore to be encoded in either Base16 or Base64; Ogmios will try both encoding.\n{ \u0026#34;type\u0026#34;: \u0026#34;jsonwsp/request\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0\u0026#34;, \u0026#34;servicename\u0026#34;: \u0026#34;ogmios\u0026#34;, \u0026#34;methodname\u0026#34;: \u0026#34;SubmitTx\u0026#34;, \u0026#34;args\u0026#34;: { \u0026#34;bytes\u0026#34;: \u0026#34;\u0026lt;base16 or base64\u0026gt;\u0026#34; } } The response will indicate either a SubmitSuccess or SubmitFail. In case of failure, Ogmios will return a list of failures reported by the underlying node. Note that, if the transaction fails to parse, Ogmios will reply with a generic error.\nTransactions in Shelley are rather complicated and there is a lot of possible validation errors that can be returned. Be sure to have a look at the API reference for an exhaustive list.\nFull Example For what it\u0026rsquo;s worth, here\u0026rsquo;s an example of a transaction submission to the Cardano mainnet via Ogmios. This transaction is using dummy data and will obviously fail. It is however structurally valid, so useful to test if an integration works correctly.\nconst WebSocket = require(\u0026#39;ws\u0026#39;); const client = new WebSocket(\u0026#34;ws://localhost:1337\u0026#34;); function wsp(methodname, args) { client.send(JSON.stringify({ type: \u0026#34;jsonwsp/request\u0026#34;, version: \u0026#34;1.0\u0026#34;, servicename: \u0026#34;ogmios\u0026#34;, methodname, args })); } client.once(\u0026#39;open\u0026#39;, () =\u0026gt; { const bytes = \u0026#34;g6QAgYJYIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGCglg5AQEBAQEBAQEB\u0026#34;+ \u0026#34;AQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBGgAehICC\u0026#34;+ \u0026#34;WDkBAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC\u0026#34;+ \u0026#34;AgICAgIaAHgXXAIaAAH6pAMZHkahAIGCWCABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\u0026#34;+ \u0026#34;AAAAAFhA169grjPSrzUUEcFEXHlZBSaZC/pzy7NzK1TvMi2qFC5ohAI0EPi+PBbpvVIHbyuz\u0026#34;+ \u0026#34;a/ON/gNKnwRljp9WGXq4D/Y=\u0026#34;; wsp(\u0026#34;SubmitTx\u0026#34;, { bytes }); }); client.on(\u0026#39;message\u0026#39;, function(msg) { const response = JSON.parse(msg); console.log(response); client.close(); }); Ogmios replies negatively to the request, returning 4 errors reported by the ledger. Yet, this was indeed reported by the ledger itself, amazing isn\u0026rsquo;t it?\n  SubmitFail   { \u0026#34;version\u0026#34;: \u0026#34;1.0\u0026#34;, \u0026#34;servicename\u0026#34;: \u0026#34;ogmios\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;jsonwsp/response\u0026#34;, \u0026#34;methodname\u0026#34;: \u0026#34;SubmitTx\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;SubmitTxResponse\u0026#34;: { \u0026#34;error\u0026#34;: { \u0026#34;SubmitFail\u0026#34;: [ { \u0026#34;expiredUtxo\u0026#34;: { \u0026#34;transactionTimeToLive\u0026#34;: 7750, \u0026#34;currentSlot\u0026#34;: 12588967 } }, { \u0026#34;feeTooSmall\u0026#34;: { \u0026#34;requiredFee\u0026#34;: 168009, \u0026#34;actualFee\u0026#34;: 129700 } }, { \u0026#34;badInputs\u0026#34;: [ { \u0026#34;index\u0026#34;: 0, \u0026#34;txId\u0026#34;: \u0026#34;0000000000000000000000000000000000000000000000000000000000000000\u0026#34; } ] }, { \u0026#34;valueNotConserved\u0026#34;: { \u0026#34;consumed\u0026#34;: 0, \u0026#34;produced\u0026#34;: 10000000 } } ] } } }, \u0026#34;reflection\u0026#34;: null }    "},{"uri":"https://ktorz.github.io/cardano-ogmios/mini-protocols/","title":"Ouroboros Mini-Protocols","tags":[],"description":"","content":"Ouroboros Mini-Protocols In this section, we\u0026rsquo;ll give practical insights about interacting with the Ouroboros mini-protocols. Each sub-section will focus on one particular protocol, give an overview and give examples in JavaScript using Ogmios.\n"},{"uri":"https://ktorz.github.io/cardano-ogmios/deployment/","title":"Deployment","tags":[],"description":"","content":"Deployment Find in this section information about deployment Ogmios with various service providers.\n"},{"uri":"https://ktorz.github.io/cardano-ogmios/mini-protocols/local-state-query/","title":"Local State Query","tags":[],"description":"","content":"┌───────────────┐ ┌──────▶│ Idle │⇦ START │ └───┬───────────┘ │ │ ▲ │ Acquire │ │ Failure │ ▼ │ │ ┌───────────┴───┐ Release │ │ Acquiring │◀─────────────────┐ │ └───┬───────────┘ │ │ │ ▲ │ Result │ Acquired │ │ ReAcquire │ │ ▼ │ │ │ ┌───────────┴───┐ ┌────────┴───────┐ └───────┤ Acquired │────────▶│ Querying │ └───────────────┘ Query └────────────────┘  Overview The state query protocol is likely the most versatile of the three Ouroboros mini-protocols. As a matter of fact, it allows for querying various types of information directly from the ledger. In essence, it is like a very simpler request/response pattern where the types of questions one can ask are specified by the protocols. Those questions include: information about the chain tip, information about stake pools but also the balance of a particular address.\nIn order to run a question by the ledger, one must first acquire a particular position on the chain, so that the node can reliably answer a few questions on a chosen, frozen state while continuing maintaining more recent version of the ledger on the side. It is important to note that:\n  The node cannot acquire any arbitrary state. One can only rewind up to a certain point.\n  Should a client keep a state acquired for too long, it is likely to become unreachable at some point, forcing clients to re-acquire.\n  How To Use Ogmios uses a simplified version of the above state-machine. Or more exactly, it exposes a simplified version and handles some of the complexity behind the scene for you. As clients, Ogmios will give you 3 possible requests: Acquire, Query, Release. A typical sequence would be to start by Acquiring a state on a given point and then make a few queries, and then release. The release step is optional although it is a bit more polite to say goodbye at the end of a conversation.\nIt is also possible to submit queries directly without acquiring. As a consequence, Ogmios will acquire the tip of the chain, run the query and release it for you. This is the easiest way to send queries if you don\u0026rsquo;t care about capturing a particular state. Note however that this may create race conditions if you send multiple queries via this method. Indeed, the tip is changing quite often on the network, and two subsequent queries may actually run on two different points of the chain. While this is generally safe for most queries, it may also put your application in an unexpected state when crossing epoch boundaries or hard-forks.\nAcquire The Acquire request expect one argument named point. The point has the same format as points in the local-chain-sync protocol. That is, they can be block header hashes or the special keyword \u0026quot;origin\u0026quot; (though there\u0026rsquo;s very little chance that one will be able to acquire the origin!).\n{ \u0026#34;type\u0026#34;: \u0026#34;jsonwsp/request\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0\u0026#34;, \u0026#34;servicename\u0026#34;: \u0026#34;ogmios\u0026#34;, \u0026#34;methodname\u0026#34;: \u0026#34;Acquire\u0026#34;, \u0026#34;args\u0026#34;: { \u0026#34;point\u0026#34;: \u0026#34;9e871633f7aa356ef11cdcabb6fdd6d8f4b00bc919c57aed71a91af8f86df590\u0026#34; } } One thing that doesn\u0026rsquo;t strike as obvious is that, as clients, you need points to query any information. There are many ways to get those hashes but in the context of Ogmios, the most logical way is via the local-chain-sync protocol.\nYou acquire multiple times, the last one will prevail. If you need to re-acquire, simply send another Acquire request.\n Query There are many queries that can be sent to the ledger, and the list is growing days after days as the Cardano team implements new ones. With Ogmios, all queries follow the same pattern and use the method name Query. All of them also take one argument named query which specifies the query to run and, optionally some extra argument given to the query. For example:\n{ \u0026quot;type\u0026quot;: \u0026quot;jsonwsp/request\u0026quot;, \u0026quot;version\u0026quot;: \u0026quot;1.0\u0026quot;, \u0026quot;servicename\u0026quot;: \u0026quot;ogmios\u0026quot;, \u0026quot;methodname\u0026quot;: \u0026quot;Query\u0026quot;, \u0026quot;args\u0026quot;: { \u0026quot;query\u0026quot;: \u0026quot;ledgerTip\u0026quot; } } At the moment of writing this guide, the following queries are available:\n   Query Result     ledgerTip The most recent block tip known of the ledger.   currentEpoch The current epoch of the ledger.   nonMyopicMemberRewards Non-myopic member rewards for each pool. Used in ranking.   currentProtocolParameters The current protocol parameters.   proposedProtocolParameters The last update proposal w.r.t. protocol parameters, if any.   stakeDistribution Distribution of the stake across all known stake pools.   utxo Current UTxO, possibly filtered by address.    To know more about arguments and results of each query, have a look at the API reference.\nSimplified Example In this example, we\u0026rsquo;ll consider a simple direct query on the network tip to fetch the latest protocol parameters. The next section gives a more elaborate example which shows how to acquire a specific point on chain.\nconst WebSocket = require(\u0026#39;ws\u0026#39;); const client = new WebSocket(\u0026#34;ws://localhost:1337\u0026#34;); function wsp(methodname, args) { client.send(JSON.stringify({ type: \u0026#34;jsonwsp/request\u0026#34;, version: \u0026#34;1.0\u0026#34;, servicename: \u0026#34;ogmios\u0026#34;, methodname, args })); } client.once(\u0026#39;open\u0026#39;, () =\u0026gt; { wsp(\u0026#34;Query\u0026#34;, { query: \u0026#34;currentProtocolParameters\u0026#34; } ); }); client.on(\u0026#39;message\u0026#39;, function(msg) { const response = JSON.parse(msg); console.log(JSON.stringify(response.result, null, 4)); client.close(); }); This little excerpt outputs the most recent protocol parameters in a nice JSON:\n{ \u0026#34;poolDeposit\u0026#34;: 500000000, \u0026#34;protocolVersion\u0026#34;: { \u0026#34;minor\u0026#34;: 0, \u0026#34;major\u0026#34;: 3 }, \u0026#34;minUtxoValue\u0026#34;: 1000000, \u0026#34;minFeeConstant\u0026#34;: 155381, \u0026#34;maxTxSize\u0026#34;: 16384, \u0026#34;minPoolCost\u0026#34;: 340000000, \u0026#34;maxBlockBodySize\u0026#34;: 65536, \u0026#34;extraEntropy\u0026#34;: \u0026#34;neutral\u0026#34;, \u0026#34;minFeeCoefficient\u0026#34;: 44, \u0026#34;poolInfluence\u0026#34;: \u0026#34;3/10\u0026#34;, \u0026#34;maxBlockHeaderSize\u0026#34;: 1100, \u0026#34;stakeKeyDeposit\u0026#34;: 2000000, \u0026#34;decentralizationParameter\u0026#34;: \u0026#34;1/5\u0026#34;, \u0026#34;desiredNumberOfPools\u0026#34;: 500, \u0026#34;poolRetirementEpochBound\u0026#34;: 18, \u0026#34;monetaryExpansion\u0026#34;: \u0026#34;3/1000\u0026#34;, \u0026#34;treasuryExpansion\u0026#34;: \u0026#34;1/5\u0026#34; } Full Example Let\u0026rsquo;s see a full example getting the stake distribution of all stake pools of the Cardano mainnet. In the example, we\u0026rsquo;ll also use the FindIntersect method from the local-chain-sync protocol to get an easy point to acquire.\nconst WebSocket = require(\u0026#39;ws\u0026#39;); const client = new WebSocket(\u0026#34;ws://localhost:1337\u0026#34;); function wsp(methodname, args) { client.send(JSON.stringify({ type: \u0026#34;jsonwsp/request\u0026#34;, version: \u0026#34;1.0\u0026#34;, servicename: \u0026#34;ogmios\u0026#34;, methodname, args })); } client.once(\u0026#39;open\u0026#39;, () =\u0026gt; { wsp(\u0026#34;FindIntersect\u0026#34;, { points: [\u0026#34;origin\u0026#34;] }); }); client.on(\u0026#39;message\u0026#39;, function(msg) { const response = JSON.parse(msg); switch (response.methodname) { case \u0026#34;FindIntersect\u0026#34;: const point = response.result.IntersectionFound.tip; wsp(\u0026#34;Acquire\u0026#34;, { point }); break; case \u0026#34;Acquire\u0026#34;: wsp(\u0026#34;Query\u0026#34;, { query: \u0026#34;stakeDistribution\u0026#34; }); break; case \u0026#34;Query\u0026#34;: console.log(response.result); client.close(); break; } }); Here\u0026rsquo;s a walk-though describing what happens when running the above script:\n  An initial request ask to FindIntersect that is guaranteed to succeed is sent. This is a little trick in order to access the ledger tip easily. As a response, Ogmios replies with:\n  IntersectionFound   { \u0026#34;version\u0026#34;: \u0026#34;1.0\u0026#34;, \u0026#34;servicename\u0026#34;: \u0026#34;ogmios\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;jsonwsp/response\u0026#34;, \u0026#34;methodname\u0026#34;: \u0026#34;FindIntersect\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;IntersectionFound\u0026#34;: { \u0026#34;point\u0026#34;: \u0026#34;origin\u0026#34;, \u0026#34;tip\u0026#34;: { \u0026#34;hash\u0026#34;: \u0026#34;dbafebb0146b2ec45186dfba6c287ad69c83d3fd9a186b39d99ab955631539e0\u0026#34;, \u0026#34;blockNo\u0026#34;: 4887546, \u0026#34;slot\u0026#34;: 12526684 } } }, \u0026#34;reflection\u0026#34;: null }      Using the tip from the previous response, we can now safely Acquire a state on that particular tip which we know exists and is not too old. Ogmios replies successfully with:\n  AcquireSuccess   { \u0026#34;version\u0026#34;: \u0026#34;1.0\u0026#34;, \u0026#34;servicename\u0026#34;: \u0026#34;ogmios\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;jsonwsp/response\u0026#34;, \u0026#34;methodname\u0026#34;: \u0026#34;Acquire\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;AcquireSuccess\u0026#34;: { \u0026#34;acquired\u0026#34;: { \u0026#34;hash\u0026#34;: \u0026#34;dbafebb0146b2ec45186dfba6c287ad69c83d3fd9a186b39d99ab955631539e0\u0026#34;, \u0026#34;slot\u0026#34;: 12526684 } } }, \u0026#34;reflection\u0026#34;: null }      Now in a position to make an actual Query, we do it and ask for the stake distribution across all stake pools. The (truncated) response from the server looks like:\n  QueryResponse   { \u0026#34;version\u0026#34;: \u0026#34;1.0\u0026#34;, \u0026#34;servicename\u0026#34;: \u0026#34;ogmios\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;jsonwsp/response\u0026#34;, \u0026#34;methodname\u0026#34;: \u0026#34;Query\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;pool1w3s6gk83y2g3670emy3yfjw9myz3u4whph7peah653rmsfegyj3\u0026#34;: { \u0026#34;stake\u0026#34;: 0, \u0026#34;vrf\u0026#34;: \u0026#34;29c1a293c550beea756bc0c01416bacd7030ae8992e13ca242d4d6c2aebaac0d\u0026#34; }, \u0026#34;pool1n5shd9xdt4s2gm27fxcnuejaqhhmpepn6chw2c82kqnuzdtpsem\u0026#34;: { \u0026#34;stake\u0026#34;: 0.00003058882418046271, \u0026#34;vrf\u0026#34;: \u0026#34;7e363eb8bfd8fef018da4c397d6a6ec25998363434e92276e40ee6c706da3ae5\u0026#34; }, \u0026#34;...\u0026#34; }, \u0026#34;reflection\u0026#34;: null }      Be aware that it is possible for an Acquire request to fail even if (and in particular if) made immediately after finding the ledger tip. In Ouroboros Praos frequent small rollbacks of the chain are not rare and the few last blocks of the chain can be a bit volatile. A real application may require more elaborate error handling than the toy example above.\n "},{"uri":"https://ktorz.github.io/cardano-ogmios/getting-started/testing/","title":"Testing","tags":[],"description":"","content":" You may skip this section if you\u0026rsquo;re not interested in contributing to Ogmios.\n 🔧 Unit Tests First, make sure to pull and update git submodules:\n$ git submodule update --init Then, simply use stack as follows:\n$ stack test ogmios:unit 💨 Smoke Tests Run the whole components stack using docker-compose as follows:\n$ docker-compose up To tear down, press CTRL+C and then run:\n$ docker-compose down "},{"uri":"https://ktorz.github.io/cardano-ogmios/api-reference/","title":"API Reference","tags":[],"description":"","content":"Ogmios as a JSON-WSP service is entirely described using JSON Schema - Draft 4. This can be fed into various tools to generate code, data-types or definitions in many languages. Ogmios is tested against this schema as well, to make sure that it remains up-to-date as new features are added.\n Explore JSON Schema   Download JSON Schema  "},{"uri":"https://ktorz.github.io/cardano-ogmios/getting-started/basics/","title":"Basics","tags":[],"description":"","content":"JSON-WSP Ogmios' interface is built on top of JSON-WSP which is a tiny standard to give some structure to the various messages that can be exchanged with Ogmios. The standard specifies a top-level JSON envelope by which messages must abide, as well as a semantic for some of the fields. In particular, there are 4 types of messages possible in JSON-WSP:\n descriptions requests responses faults (which are a special kind of responses).  We won\u0026rsquo;t be covering the JSON-WSP standard in this guide but gives a few extra insights about how it relates to Ogmios and some good takes from it. Each request in Ogmios yields exactly one response, might it be a normal response or a fault. Furthermore, requests which relate to a particular protocol are guaranteed to yield responses in the same order.\nRequests Requests messages are sent by client applications (you) to Ogmios. Requests have 3 fields of interest: methodname, args and mirror. The methodname identifies the request itself and translates to a corresponding message of one of the 3 Ouroboros mini-protocols. Possible values for the methodname are described in section 3 - Ouroboros mini-protocols and the complete reference is available in section 4 - API Reference.\nHere is an example of valid request message:\n{ \u0026#34;type\u0026#34;: \u0026#34;jsonwsp/request\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0\u0026#34;, \u0026#34;servicename\u0026#34;: \u0026#34;ogmios\u0026#34;, \u0026#34;methodname\u0026#34;: \u0026#34;FindIntersect\u0026#34;, \u0026#34;args\u0026#34;: { \u0026#34;points\u0026#34;: [ \u0026#34;origin\u0026#34; ] }, \u0026#34;mirror\u0026#34;: { \u0026#34;step\u0026#34;: \u0026#34;INIT\u0026#34; } } As you can see, the methodname specifies the method FindIntersect which relates to the local chain-sync Ouroboros mini-protocol. This particular request expects one argument named points, which contains a list of points we want to intersect with (don\u0026rsquo;t panic, this is explained in further details in the next section!). Another interesting, albeit optional, field is the mirror field. This is completely free-form and will be spit back identically by Ogmios in the response. This can be useful to keep track of states on the client application or pass in extra context to each request/response. Be careful though that anything you send for a request will come back in the response; send something big, get something big.\nResponses Let\u0026rsquo;s start with a possible response to the request above:\n{ \u0026quot;type\u0026quot;: \u0026quot;jsonwsp/response\u0026quot;, \u0026quot;version\u0026quot;: \u0026quot;1.0\u0026quot;, \u0026quot;servicename\u0026quot;: \u0026quot;ogmios\u0026quot;, \u0026quot;methodname\u0026quot;: \u0026quot;FindIntersect\u0026quot;, \u0026quot;result\u0026quot;: { \u0026quot;IntersectionFound\u0026quot;: { \u0026quot;point\u0026quot;: \u0026quot;origin\u0026quot;, \u0026quot;tip\u0026quot;: { \u0026quot;hash\u0026quot;: \u0026quot;d184f428159290bf3558b4d1d139e6a07ec6589738c28a0925a7ab776bde4d62\u0026quot;, \u0026quot;blockNo\u0026quot;: 4870185, \u0026quot;slot\u0026quot;: 12176171 } } }, \u0026quot;reflection\u0026quot;: { \u0026quot;step\u0026quot;: \u0026quot;INIT\u0026quot; } } The response kindly indicates which requests it corresponds to and has the same methodname as the matching request. It also gives a result under a specific field. Responses can have various results which are fully specified in section 4. - API Reference. Also, notice the reflection field which reflects exactly the mirror field that was set for the request.\nOgmios' responses may correspond to possible errors that are part of the Ouroboros mini-protocols. For example, if you submit an invalid transaction, you\u0026rsquo;ll get back a message of type jsonwsp/response because it is a valid message in the context of the mini-protocols. Yet, Ogmios will yield a message of type jsonwsp/fault if you submit an invalid Ogmios message (for instance, an unknown request constructor, or something that is not a valid JSON-WSP message).\n WebSocket Ogmios uses WebSocket as a communication protocol. The WebSocket protocol is full-duplex, which means that Ogmios and clients can send messages to each other all at the same time. That is very convenient for clients who can pipeline many requests at once and process responses later on as they arrive.\nTherefore, to send a message to ogmios, you only need a WebSocket client! For example, using the well-established ws Node.js package and assuming a local instance of Ogmios started through Docker, you can interact with Ogmios as simply as:\nconst WebSocket = require(\u0026#39;ws\u0026#39;); const client = new WebSocket(\u0026#34;ws://localhost:1337\u0026#34;); client.once(\u0026#39;open\u0026#39;, () =\u0026gt; { const request = { \u0026#34;type\u0026#34;: \u0026#34;jsonwsp/request\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0\u0026#34;, \u0026#34;servicename\u0026#34;: \u0026#34;ogmios\u0026#34;, \u0026#34;methodname\u0026#34;: \u0026#34;FindIntersect\u0026#34;, \u0026#34;args\u0026#34;: { \u0026#34;points\u0026#34;: [ \u0026#34;origin\u0026#34; ] } }; client.send(JSON.stringify(request)); }); client.on(\u0026#39;message\u0026#39;, function(msg) { const response = JSON.parse(msg); // do something with \u0026#39;response\u0026#39; }); That\u0026rsquo;s all for the basics. The rest isn\u0026rsquo;t really specific to Ogmios, but is about the Ouroboros mini-protocols themselves. See the next sections for a deep dive!\n"},{"uri":"https://ktorz.github.io/cardano-ogmios/","title":"Overview","tags":[],"description":"","content":"Overview Ogmios is a protocol translation service written in Haskell running on top of cardano-node. It offers a JSON-WSP interface through WebSockets and enables applications to speak Ouroboros' mini-protocols via remote procedure calls over JSON. Ogmios is very lightweight too and can be deployed alongside relays to create entry points on the Cardano network for various types of applications (e.g. wallets, explorers, chatbots, dashboards\u0026hellip;).\nMotivation All programs offer more or less elaborated interfaces for either user or program interactions. That is, most user-facing programs include a graphical user interface (a.k.a GUI) where users can send signals via buttons and switches, and receive visual or auditive feedback from the program. Some programs are also meant to be used by other programs and are typically called services; such services offer application programming interfaces (a.k.a API) in various forms to enable other programs (or services) to interact. The nodes from Cardano belong to the second category, yet they offer a rather exotic interface: ad-hoc protocols designed in-house by IOHK to be extremely efficient and secure.\nIn order to interact with a Cardano node, one must therefore speak one of these so-called Ouroboros mini-protocols. This is an impediment to mass adoption for the only existing implementation of those protocols is written in Haskell (and therefore, only available to Haskell applications). Ogmios is an attempt to lower down that entry barrier by translating the interface with a set of technologies that is well-known on the Web. In essence, it is very much like putting a power socket adaptor on the wall in order to branch a device with a peculiar plug; Cardano node is the device, Ogmios is the socket adaptor.\nOgmios is very lightweight and doesn\u0026rsquo;t do much on its own. It is running next to a Cardano node and it acts as an intermediary for other client applications. Ogmios emulates the Ouroboros mini-protocols through WebSockets and translates the binary on-chain data from and to JSON; both WebSockets and JSON are widespread over the Web and in many other applications so much that they offer the ideal mainstream interface that I hope will help getting more and more application developers to build with Cardano!\nAbout me My name is Matthias (a.k.a KtorZ) and I currently work with the engineering teams of IOHK to build Cardano. My main area of focus within the Cardano project is basically anything that deals with a Cardano node, which means a lot of things! From a very young age, I\u0026rsquo;ve been enjoying designing and writing programs. Ogmios is yet another instance of this which I started as a proof-of-concept on my free-time, and which rapidly became one of my most sophisticated side-project.\n"},{"uri":"https://ktorz.github.io/cardano-ogmios/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"https://ktorz.github.io/cardano-ogmios/tags/","title":"Tags","tags":[],"description":"","content":""}]