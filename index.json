[{"uri":"https://ogmios.dev/getting-started/","title":"Getting Started","tags":[],"description":"","content":"Getting Started Find in this section information about building and running Ogmios. This will cover installation from both sources and docker ğŸ³, as well as details about options and configuration for running Ogmios.\n"},{"uri":"https://ogmios.dev/deployment/aws/","title":"AWS","tags":[],"description":"","content":"Pre-Requisites   Make sure to have an AWS account, and an AWS_ACCESS_KEY_ID \u0026amp; AWS_SECRET_ACCESS_KEY.\n  Make sure to grant AmazonEC2FullAccess to your AWS user.\n  You\u0026rsquo;ll need to create a security group which allows inbound TCP connections. See also: Working With Security Groups.\n  Install docker-machine\n  Create an SSH key/pair $ ssh-keygen -t rsa -b 4096 -C \u0026quot;your_email@example.com\u0026quot; -f aws_rsa $ eval \u0026quot;$(ssh-agent -s)\u0026quot; $ ssh-add ~/.ssh/aws_rsa Create The Docker Machine AWS_ACCESS_KEY_ID=\u0026lt;YOUR_ACCESS_KEY_ID\u0026gt; AWS_SECRET_ACCESS_KEY=\u0026lt;YOUR_SECRET_KEY\u0026gt; docker-machine create -d amazonec2 \\  --amazonec2-access-key $AWS_ACCESS_KEY_ID \\  --amazonec2-secret-key $AWS_SECRET_ACCESS_KEY \\  --amazonec2-region eu-west-3 \\  --amazonec2-instance-type \u0026#34;t2.medium\u0026#34; \\  --amazonec2-ssh-keypath ~/.ssh/aws_rsa \\  aws-ogmios Push The Stack First, configure your shell and activate your docker-machine:\n$ eval $(docker-machine env aws-ogmios) Then, simply push the stack using docker-compose:\n$ COMPOSE_TLS_VERSION=TLSv1_2 docker-compose up -d  Compose may use a wrong TLS version for pulling layers from dockerhub. Hence the ENV var.\n ğŸ‰ Enjoy $ docker-machine ls NAME ACTIVE DRIVER STATE URL SWARM DOCKER ERRORS aws-ogmios * amazonec2 Running tcp://xx.xxx.xxx.xxx:xxxx v19.03.8 (Optional) Adding TLS with a registered domain   Install nginx.\n    Configure a new server as /etc/nginx/sites-enabled/domain.extension   server { server_name DOMAIN.EXTENSION; listen 80; location ^~ /.well-known/acme-challenge/ { try_files $uri /dev/null =404; } }    ğŸ‘† Make sure to replace \u0026lsquo;DOMAIN.EXTENSION\u0026rsquo; with your actual registered domain.\n  Reload your nginx configuration with: sudo systemctl reload nginx.service.\n  Install certbot and let certbot configure your nginx server (sudo certbot --nginx).\n  Once done, edit your nginx configuration one more time\u0026hellip;\n    Remove (no longer needed after certbot has successfully configured the server)   location ^~ /.well-known/acme-challenge/ { try_files $uri /dev/null =404; }        And add the following clause to enable routing all traffic (including WebSockets) to ogmios   location ~* / { proxy_pass http://localhost:1337; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \u0026#34;Upgrade\u0026#34;; proxy_set_header Host $host; }        The final configuration should look like this:\nserver { server_name ogmios.dev; location ~* / { proxy_pass http://localhost:1337; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \u0026#34;Upgrade\u0026#34;; proxy_set_header Host $host; } listen 443 ssl; # managed by Certbot  ssl_certificate /etc/letsencrypt/live/ogmios.dev/fullchain.pem; # managed by Certbot  ssl_certificate_key /etc/letsencrypt/live/ogmios.dev/privkey.pem; # managed by Certbot  include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot  ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot } server { server_name ogmios.dev; listen 80; if ($host = ogmios.dev) { return 301 https://$host$request_uri; } # managed by Certbot  return 404; # managed by Certbot } "},{"uri":"https://ogmios.dev/getting-started/docker/","title":"Docker","tags":[],"description":"","content":"ğŸ³ Overview The easiest way to get started with Ogmios is to use docker. This guide won\u0026rsquo;t cover installing docker, so make sure you have the Docker daemon installed and running.\nOgmios docker images come in two flavours: cardano-node-ogmios and ogmios. The former is used to run a single container that bundles both a Cardano-node and an Ogmios server running side-by-side. It is likely the easiest way to get started. The latter is a standalone Ogmios server, and you\u0026rsquo;ll need to run that container in orchestration with a cardano-node; this is made relatively easy with Docker compose.\nImages are uploaded to Dockerhub and are tagged using release versions combined with the supported network name, or with :latest if you\u0026rsquo;re living on the edge. If using the mainnet image you can omit the network name.\n   image repository tags     cardano-node-ogmios cardanosolutions/cardano-node-ogmios latest, latest-{NETWORK}, v*.*.*, v*.*.*-{NETWORK}   ogmios cardanosolutions/ogmios latest, latest-{NETWORK}, v*.*.*, v*.*.*-{NETWORK}    cardano-node-ogmios (easiest) Running Assuming you\u0026rsquo;ve pulled or build the image (otherwise, see below), you can start a cardano-node with an ogmios server in one single command:\n$ docker run -it \\ --name cardano-node-ogmios \\ -p 1337:1337 \\ -v cardano-node-ogmios-db:/db \\ cardanosolutions/cardano-node-ogmios:latest Let\u0026rsquo;s explore a bit the various options:\n  -it is a shorthand for two options -i \u0026amp; -t to enable some interactive support with the container. This is necessary to pass OS signals (e.g. SIGINT from CTRL-C) from the host to the container.\n  --name gives a name to the container, to easily identify it later in commands such as docker container ps.\n  -p instruments docker to bind ports of the container to host. The image exposes 4 ports that can be bound to any (available) port of the host system. Here\u0026rsquo;s the complete list of TCP ports exposed by the image:\n   Port Number Description     1337 Ogmios port, for both the WebSocket and the HTTP server.   3000 cardano-node\u0026rsquo;s relay port   12788 cardano-node\u0026rsquo;s EKG port   12798 cardano-node\u0026rsquo;s Prometheus port      -v mounts a shared volume with the container on your host machine, either via bind mounts or named volumes.\n   Mount Point Description     db/{NETWORK_NAME} Persist the cardano-node\u0026rsquo;s database to avoid re-syncing the chain whenever a new container is run. This is done on every version upgrade and is recommended for most use-cases.   ipc Bind /ipc to get access to the cardano-node\u0026rsquo;s local socket if you use the image in a multi-container stack with an external Haskell client.      Find more about run options in the docker user documentation.\nBuilding To build the image yourself, we encourage you to leverage the existing build-cache layers from the registry. Building the entire image from scratch can take up to an hour! You can\n$ DOCKER_BUILDKIT=1 docker build \\ --cache-from cardanosolutions/cardano-node-ogmios:latest \\ --tag cardanosolutions/cardano-node-ogmios:latest \\ https://github.com/cardanosolutions/ogmios.git Optionally specify a network name, other than mainnet, using a build argument:\n--build-arg NETWORK=testnet  Note that you can explicitly specify the target build when building the multi-stage docker image using --target cardano-node-ogmios. This is the default behaviour.\n Ogmios standalone (more advanced) Running Docker\u0026rsquo;s compose is a handy tool to orchestrate multiple services packaged as containers. The tool works from a compose file which is available in the Ogmios repository, get it via:\n$ git clone --depth 1 git@github.com:cardanosolutions/ogmios.git $ cd cardano-ogmios Then, starts the components stack using:\n$ docker-compose up ğŸ‘†This will run and connect:\n A Cardano node, connected to mainnet. An Ogmios server using the latest Dockerhub build, listening to localhost on port: 1337.  Once finish, tear the stack down using:\n$ docker-compose down Configuration The compose file allows for minimal (albeit useful) configuration parameters via environment variables:\n   Variable Description Values Default     NETWORK Which Cardano network to connect to. This impacts both Ogmios and the underlying Cardano node. mainnet, testnet mainnet   OGMIOS_PORT Which ports to listen to (both for WebSockets and health endpoints) Any valid port number. 1337    Ogmios doesn\u0026rsquo;t use any form of persistent storage, but cardano-node does. The mainnet and testnet databases are not compatible, so it is recommended to instrument docker-compose to use different namespaces for different networks (so that you can switch from one another without risking any database conflicts). Compose can do this easily by passing an extra flag: --project-name.\n For example, for running cardano-node + ogmios on the testnet, listening to tcp/1338, do:\n$ NETWORK=testnet OGMIOS_PORT=1338 docker-compose --project-name cardano-ogmios-testnet up Building To build the Ogmios image from sources, pass the --build flag to compose. This is useful if you need a different version than the latest one available on Dockerhub. Alternatively, you can resort to building the image directly from the Dockerfile. Note that the same Dockerfile is used to produced both the ogmios image and the cardano-node-ogmios image using multi-stage docker builds. To build only the ogmios image, you\u0026rsquo;ll have to explicitly specify the build target using the --target ogmios option. So in brief:\n$ DOCKER_BUILDKIT=1 docker build \\ --cache-from cardanosolutions/ogmios:latest \\ --tag cardanosolutions/ogmios:latest \\ --target ogmios \\ https://github.com/cardanosolutions/ogmios.git "},{"uri":"https://ogmios.dev/mini-protocols/local-chain-sync/","title":"Local Chain Sync","tags":[],"description":"","content":" â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ Intersect â”‚â—€â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•— â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜ FindIntersect â•‘ â”‚ â•‘ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ Intersect.{Found,NotFound} â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚ â”‚ â”‚ Idle â”‚ â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â”‚ â”‚ â•‘ RequestNext â”‚ â”‚â‡¦ START â•‘ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â–¼ â–² â”Œâ”€â”€â”€â”€â”€â”€â” Roll.{Backward,Forward} â”‚ â”‚ Next â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”˜   Overview Clients that wish to synchronise blocks from the Cardano chain can use the Local Chain Sync protocol.\nThe protocol is stateful, which means that each connection between clients and Ogmios has a state: a cursor locating a point on the chain. Typically, a client will start by looking for an intersection between its own local chain and the one from the node / Ogmios. Then, it\u0026rsquo;ll simply request the next action to take: either rolling forward and adding new blocks, or rolling backward.\nHow To Use When a connection is opened with Ogmios, it automatically starts a local chain-sync session with the underlying cardano-node. There\u0026rsquo;s an implicit state maintained by the node which one can imagine as a cursor, pointing to a point on the Cardano chain. Initially, this cursor starts at a special point called: origin (as in, the origin of the chain). After each request, the node will move the cursor either forward or backward and remembers its location for the next request. To move the cursor, the protocols gives two mechanisms: RequestNext and FindIntersect.\n ____ ____ ____ ____ ____ ____ / /\\ / /\\ / /\\ / /\\ / /\\ / /\\ o === /____/ \\ === /____/ \\ === /____/ \\ === /____/ \\ === /____/ \\ === /____/ \\ == ... \\ \\ / \\ \\ / \\ \\ / \\ \\ / \\ \\ / \\ \\ / \\____\\/ \\____\\/ \\____\\/ \\____\\/ \\____\\/ \\____\\/ ^ | | origin \n RequestNext Clients may ask for the next block where \u0026lsquo;next\u0026rsquo; refers directly to that implicit cursor. This translates to a message with RequestNext as a method name. This request does not accept any arguments.\n{ \u0026#34;type\u0026#34;: \u0026#34;jsonwsp/request\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0\u0026#34;, \u0026#34;servicename\u0026#34;: \u0026#34;ogmios\u0026#34;, \u0026#34;methodname\u0026#34;: \u0026#34;RequestNext\u0026#34;, \u0026#34;args\u0026#34;: {} } As a response, Ogmios will send back a response which can be either RollForward or RollBackward. Rolling forward is pretty straightforward and is the main type of response one can expect; such response will include the next block, which itself includes a header, transactions, certificates, metadata and all sort of information.\nRolling backward however may occur when, since the last request, the underlying node decided to switch to a different fork of the chain to the extent that the previous cursor is no longer pointing to a block that exists on the chain. The node therefore asks (kindly) to roll backward to a previously known point that is the earliest ancestor that is common between the client\u0026rsquo;s own chain locally and the one that was just adopted by the node.\n ____ ____ / /\\ / /\\ /____/ \\ === /____/ \\ (node's chain) \\ \\ / \\ \\ / / \\____\\/ \\____\\/ / ____ ____ / ____ ____ / /\\ / /\\ / / /\\ / /\\ === /____/ \\ === /____/ \\ =.= /____/ \\ === /____/ \\ (local chain) \\ \\ / \\ \\ / ^ \\ \\ / \\ \\ / \\____\\/ \\____\\/ | \\____\\/ \\____\\/ |  | common chain prefix | | point of rollback   When rolling backward, the node will not provide a block but instead, a point which is made of a block header hash and a slot.\nAs a client, it is therefore crucial to be able to rollback to a previous point of the chain. In practice, Ouroboros guarantees that forks cannot be longer than a certain length. This maximum length is called k in the Ouroboros protocol, and also known as the security parameter.\n Pipelining Ogmios will do its best to pipeline requests to the Cardano node. Yet unlike WebSocket, the local chain-sync protocol only allows for finite pipelining. Said differently, Ogmios cannot pipeline an arbitrary and potentially infinite number of requests and will actually starts collecting responses if too many requests are pipelined. Pipelining with WebSocket is however straightforward for most clients permit sending many requests at once and handle responses using callbacks on event handlers.\nA good rule of thumb with Ogmios is to pipeline some requests when starting a long-run chain-sync, and then simply put back a new request in the queue every time you receive a response back. In that way, there are always some requests in flight and Ogmios can make a good use of the available bandwith. How many requests to pipeline depends on various factors including the network latency and machine resources. In a local setup where Ogmios and its client are located on the same machine, pipelining a few requests (up to 1000) can be quite effective and drastically speed up the chain-sync.\nFor example, here below is a comparison of the effect of pipelining on a full synchronization of the Mary era:\n   Num pipelined / in-flight requests Time     1 (i.e. no pipelining) 6min 22s   10 4min 51s   25 3min 44s   50 2min 40s   100 2min 37s   1000 2min 38s    Exact numbers depends on your application and machine resources. But this charts give an order of magnitude. If you\u0026rsquo;re pipelining many requests in a client application, make sure to also take times to collect some responses because there will be no extra benefits coming from too much pipelining.\n FindIntersect On the first connection with the node, clients will likely synchronize from the origin. Yet, on subsequent connections one may want to resume syncing to a point that is much more recent than the origin. Ideally, one would like to carry on exactly at the point where the chain was left yet as we just saw, this is not always possible. The local chain-sync protocol gives however clients a way to find a common intersection between a client\u0026rsquo;s current version of the chain and whatever version the node has. This is via the FindIntersect message. This message accepts one argument which is a list of header hashes (or the special keyword \u0026quot;origin\u0026quot;).\n{ \u0026#34;type\u0026#34;: \u0026#34;jsonwsp/request\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0\u0026#34;, \u0026#34;servicename\u0026#34;: \u0026#34;ogmios\u0026#34;, \u0026#34;methodname\u0026#34;: \u0026#34;FindIntersect\u0026#34;, \u0026#34;args\u0026#34;: { \u0026#34;points\u0026#34;: [ \u0026#34;9e871633f7aa356ef11cdcabb6fdd6d8f4b00bc919c57aed71a91af8f86df590\u0026#34;, \u0026#34;d184f428159290bf3558b4d1d139e6a07ec6589738c28a0925a7ab776bde4d62\u0026#34;, \u0026#34;origin\u0026#34; ] }, } If an intersection is found, great, the node will set the cursor to that point and let you know. If not, the cursor will remain where it was and the failure will also be broadcast. As we\u0026rsquo;ve seen in the previous section, a node may switch to longer forks based quite arbitrarily. Hence, a good list of intersections candidates is preferably dense near the tip of the chain, and goes far back in the past (k is typically not enough).\nFor example, imagine the following scenario:\n Local chain: [P01,P02,P03,..,P98,P99A,P100A] Node\u0026rsquo;s chain: [P01,P02,P03,..,P98,P99B,P100B]  As a client, providing any point before or at P98 will result in finding an intersection. Yet, if one only provides [P99A, P100A], the node will not be able to figure out where to continue the protocol and will remain at the origin.\nThe order of the list matters! The node will intersect with the best match, considering that the preferred points are first in the list. If one provides origin as a first point, an intersection is guaranteed to always find a match, and always at origin (and that is quite useless!).\n Points of interest For several applications, it may be quite useful to know the last point of each era; This allows to start syncing blocks from the beginning of a particular era. For instance, after seeking an intersection with the last point of the Shelley, RequestNext would yield the first block of the Allegra era. Handy!\nMainnet    Era Bound SlotNo Hash     Last Byron Block 4492799 f8084c61b6a238acec985b59310b6ecec49c0ab8352249afd7268da5cff2a457   Last Shelley Block 16588737 4e9bbbb67e3ae262133d94c3da5bffce7b1127fc436e7433b87668dba34c354a   Last Allegra Block 23068793 69c44ac1dda2ec74646e4223bc804d9126f719b1c245dadc2ad65e8de1b276d7   Last Mary Block 39916796 e72579ff89dc9ed325b723a33624b596c08141c7bd573ecfff56a1f7229e4d09   Last Alonzo Block N/A N/A    Remember also that \u0026quot;origin\u0026quot; is a special point that can be queried and will always yield a success.\nFull Example Let\u0026rsquo;s see a full example that is synchronizing the first 14 blocks of the Shelley chain and printing them to the console.\nconst WebSocket = require(\u0026#39;ws\u0026#39;); const client = new WebSocket(\u0026#34;ws://localhost:1337\u0026#34;); function wsp(methodname, args, mirror) { client.send(JSON.stringify({ type: \u0026#34;jsonwsp/request\u0026#34;, version: \u0026#34;1.0\u0026#34;, servicename: \u0026#34;ogmios\u0026#34;, methodname, args, mirror })); } client.once(\u0026#39;open\u0026#39;, () =\u0026gt; { const lastByronBlock = { slot: 4492799, hash: \u0026#34;f8084c61b6a238acec985b59310b6ecec49c0ab8352249afd7268da5cff2a457\u0026#34; }; wsp(\u0026#34;FindIntersect\u0026#34;, { points: [lastByronBlock] }); }); client.on(\u0026#39;message\u0026#39;, function(msg) { const response = JSON.parse(msg); switch (response.methodname) { case \u0026#34;FindIntersect\u0026#34;: if (!response.result.IntersectionFound) { throw \u0026#34;Whoops? Last Byron block disappeared?\u0026#34; } wsp(\u0026#34;RequestNext\u0026#34;, {}, { n: 14 }); break; case \u0026#34;RequestNext\u0026#34;: if (response.result.RollForward) { console.log(response.result); } if (response.reflection.n \u0026gt; 0) { wsp(\u0026#34;RequestNext\u0026#34;, {}, { n: response.reflection.n - 1 }); } else { client.close(); } break; } }); A few important takes from this excerpt:\n  The node streams blocks that are after the intersection point. Thus to get the first 14 Shelley blocks, one needs to set the intersection at the last Byron block!\n  After successfully finding an intersection, the node will always ask to roll backward to that intersection point. This is because it is possible to provide many points when looking for an intersection and the protocol makes sure that both the node and the client are in sync. This allows clients applications to be somewhat \u0026ldquo;dumb\u0026rdquo; and blindly follow instructions from the node.\n  In this schema, we are sending each request one-by-one, using the mirror field as counter. An alternative could have been:\ncase \u0026#34;FindIntersect\u0026#34;: if (!response.result.IntersectionFound) { throw \u0026#34;Whoops? First Shelley block disappeared?\u0026#34; } for (let i = 14; i \u0026gt; 0; i += 1) { wsp(\u0026#34;RequestNext\u0026#34;, {}); } break; We need not to wait for replies to send requests and can collect all responses at a later stage!\n  Compact Serialization Since version v3.2.0, Ogmios supports a WebSocket sub-protocol which has an influence on the representation of some data objects. When set, this so-called compact mode will omit proofs, signatures and other voluminous pieces of information from responses that are somewhat superfluous in a trustworthy setup (where for instance, your application fully trusts its node / Ogmios). As a consequence, responses are twice smaller, less bloated and the overall chain-sync synchronization is sped up by about 20%. To enable the compact serialization, use:\nogmios.v1:compact as a sub-protocol when establishing the WebSocket connection. Omitted fields are documented in the API reference using the $omitted-if-compact field of relevant objects.\n"},{"uri":"https://ogmios.dev/typescript-client/overview/","title":"Overview","tags":[],"description":"","content":"Overview The TypeScript client for Ogmios is available on npm:\n$ yarn add @cardano-ogmios/client It provides a fully typed interface for interacting with Ogmios as well as many convenient functions to manage WebSocket connections and drive the Ouroboros mini-protocols.\nThe package is divided into a few modules: one per Ouroboros mini-protocols and some for managing WebSocket connections or utils. Let\u0026rsquo;s start with the Connection module which is a necessary step regardless of which protocol you\u0026rsquo;ll then use.\nInteractionContext This module allows you to define an InteractionContext which tells the client how to create and manage WebSocket connections. The creation of an InteractionContext returns a Promise which is rejected if the server isn\u0026rsquo;t reachable yet. That can happen when you first start your service stack; Ogmios is only ready when the underlying cardano-node is itself ready. Cardano-node runs a serie of integrity checks on its database on start, which can often takes a few seconds if not minutes. While doing so, the node does not allow any connections. Using the interaction context, you can implement retry mechanism on failures until it finally resolves.\nTo create an InteractionContext, you need to provide three elements:\n The connection configuration (port, host, protocol) An error handler A close handler  For example:\nimport { createInteractionContext, InteractionContext } from \u0026#39;@cardano-ogmios/client\u0026#39; const context : InteractionContext = await createInteractionContext( err =\u0026gt; console.error(err), () =\u0026gt; console.log(\u0026#34;Connection closed.\u0026#34;), { connection: { port: 1337 } } ) Note that the last connection argument is optional and will use default values when omitted.\nAn InteractionContext is a tiny abstraction on top of a WebSocket connection. Sharing InteractionContext between multiple clients isn\u0026rsquo;t recommend and may lead to confusing behavior as some clients will close the underlying connections after certain queries.\n Once you\u0026rsquo;ve got your hands on an InteractionContext, you can use it to create any of the 3 clients (each of one corresponding to one of the Ouroboros mini-protocols):\n ChainSyncClient StateQueryClient TxSubmissionClient  "},{"uri":"https://ogmios.dev/getting-started/building/","title":"Building","tags":[],"description":"","content":" You may skip this section if you\u0026rsquo;re using Docker ğŸ³.\n Pre-requisites (Server) Ogmios is built using the great Haskell build tool stack. You\u0026rsquo;ll also need git to clone the source code, that is:\n git 2.11.* stack 2.*.*  Ogmios in itself is a rather small project, yet it\u0026rsquo;s using library directly from the ouroboros-network, cardano-ledger-specs and cardano-node projects. This is handy for re-using existing logic, but comes at the cost of several system dependencies that are required for building everything. Some may already be installed on your system, but the complete list is:\n libsodium-dev 1.0.* libgmp-dev 6.1.* libssl-dev 1.1.* libpcre3-dev 2.8.* libsystemd-dev zlib1g-dev 1.2.*  ğŸ”¨ Server Clone the git repository from Github:\n$ git clone --depth 1 --recursive --shallow-submodules git@github.com:cardanosolutions/ogmios.git $ cd cardano-ogmios/server Then, use Stack to compile the project source code from the server directory:\n$ stack build ogmios The first time, this may take a while as Stack needs to setup a compilation environment and to download a lot of dependencies. Subsequent executions are much faster.\nFrom there, you can run Ogmios via stack using the exec command:\n$ stack exec -- ogmios --help Alternatively, you can instrument Stack to copy the compiled executable elsewhere so that you can run Ogmios all by itself:\n$ stack install ogmios $ ogmios --help ğŸ”¨ TypeScript Client Clone the git repository from Github:\n$ git clone --depth 1 --recursive --shallow-submodules git@github.com:cardanosolutions/ogmios.git $ cd cardano-ogmios/clients/TypeScript Then, use Yarn to install dependencies and compile the project source code from the client/TypeScript directory:\n$ yarn install \\ \u0026amp;\u0026amp; yarn build ğŸ“š Documentation The documentation can be generated from the TypeScript client workbench. Follow the instruction in the README to setup the TypeScript workspace, and then run:\n$ yarn docs This will generate documentation for the API and the TypeScript clients in /docs/static to be served by the static website generator Hugo.\nAlternatively, you can also look at our User-Guide Github Workflow to see how its done.\n"},{"uri":"https://ogmios.dev/typescript-client/chain-sync/","title":"ChainSync Client","tags":[],"description":"","content":"The ChainSync client streams block from the network, one-by-one in the form of events. Creating such a client requires your application to register two callbacks:\n on rollForward, to process new blocks coming in and advancing your local chain. on rollBackward, to process rollback requests to a previous point of your local chain.  These callbacks are captured via the ChainSyncMessageHandlers interface.\n For example, you can store blocks into a database (assuming some high-level db interface) as follows:\nimport { createChainSyncClient } from \u0026#39;@cardano-ogmios/client\u0026#39; const rollForward = async ({ block }, requestNext) =\u0026gt; { await db.insert(block) requestNext() } const rollBackward = async ({ point }, requestNext) =\u0026gt; { await db.rollback(point) requestNext() } const client = await createChainSyncClient(context, { rollForward, rollBackward }) await client.startSync() // ...  await client.shutdown() Notice how the callback also includes a continuation requestNext which commands the server to send the next block. For more details about the chain-sync mini-protocol, have a look at the protocol documentation itself.\nOnce created, the client offers two methods startSync and shutdown. As a matter of fact, the client does not start syncing automatically. This allows you to specify a starting point if necessary (in case your application is resuming from a previous state). This is optional and by default the client will synchronize from the node\u0026rsquo;s tip and onward.\nConcurrent vs sequential By default, the client will send requests and process requests sequentially for it is more intuitive. However, some applications may not necessarily bother about sequentiality and may process messages in any order. This behavior can hence by changed by providing an extra option to createChainSyncClient:\nconst client = await createChainSyncClient(context, callbacks, { sequential: false }) When sequential is set to false, the order in which message callbacks are resolved depends on the JavaScript runtime and whether or not your are making concurrent requests.\n"},{"uri":"https://ogmios.dev/mini-protocols/local-state-query/","title":"Local State Query","tags":[],"description":"","content":" â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â–¶â”‚ Idle â”‚â‡¦ START â”‚ â””â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚ â–² â”‚ Acquire â”‚ â”‚ Failure â”‚ â–¼ â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â” Release â”‚ â”‚ Acquiring â”‚â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â””â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚ â”‚ â–² â”‚ Result â”‚ Acquired â”‚ â”‚ ReAcquire â”‚ â”‚ â–¼ â”‚ â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â” â””â”€â”€â”€â”€â”€â”€â”€â”¤ Acquired â”‚â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚ Querying â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ Query â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   Overview The state query protocol is likely the most versatile of the three Ouroboros mini-protocols. As a matter of fact, it allows for querying various types of information directly from the ledger. In essence, it is like a very simpler request/response pattern where the types of questions one can ask are specified by the protocols. Those questions include: information about the chain tip, information about stake pools but also the balance of a particular address.\nIn order to run a question by the ledger, one must first acquire a particular position on the chain, so that the node can reliably answer a few questions on a chosen, frozen state while continuing maintaining more recent version of the ledger on the side. It is important to note that:\n  The node cannot acquire any arbitrary state. One can only rewind up to a certain point.\n  Should a client keep a state acquired for too long, it is likely to become unreachable at some point, forcing clients to re-acquire.\n  How To Use Ogmios uses a simplified version of the above state-machine. Or more exactly, it exposes a simplified version and handles some of the complexity behind the scene for you. As clients, Ogmios will give you 3 possible requests: Acquire, Query, Release. A typical sequence would be to start by Acquiring a state on a given point and then make a few queries, and then release. The release step is optional although it is a bit more polite to say goodbye at the end of a conversation.\nIt is also possible to submit queries directly without acquiring. As a consequence, Ogmios will acquire the tip of the chain, run the query and release it for you. This is the easiest way to send queries if you don\u0026rsquo;t care about capturing a particular state. Note however that this may create race conditions if you send multiple queries via this method. Indeed, the tip is changing quite often on the network, and two subsequent queries may actually run on two different points of the chain. While this is generally safe for most queries, it may also put your application in an unexpected state when crossing epoch boundaries or hard-forks.\nAcquire The Acquire request expect one argument named point. The point has the same format as points in the local-chain-sync protocol. That is, they can be block header hashes or the special keyword \u0026quot;origin\u0026quot; (though there\u0026rsquo;s very little chance that one will be able to acquire the origin!).\n{ \u0026#34;type\u0026#34;: \u0026#34;jsonwsp/request\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0\u0026#34;, \u0026#34;servicename\u0026#34;: \u0026#34;ogmios\u0026#34;, \u0026#34;methodname\u0026#34;: \u0026#34;Acquire\u0026#34;, \u0026#34;args\u0026#34;: { \u0026#34;point\u0026#34;: \u0026#34;9e871633f7aa356ef11cdcabb6fdd6d8f4b00bc919c57aed71a91af8f86df590\u0026#34; } } One thing that doesn\u0026rsquo;t strike as obvious is that, as clients, you need points to query any information. There are many ways to get those hashes but in the context of Ogmios, the most logical way is via the local-chain-sync protocol.\nYou can acquire multiple times, the last one will prevail. If you need to re-acquire, simply send another Acquire request.\n Query There are many queries that can be sent to the ledger, and the list is growing days after days as the Cardano team implements new ones. With Ogmios, all queries follow the same pattern and use the method name Query. All of them also take one argument named query which specifies the query to run and, optionally some extra argument given to the query. For example:\n{ \u0026quot;type\u0026quot;: \u0026quot;jsonwsp/request\u0026quot;, \u0026quot;version\u0026quot;: \u0026quot;1.0\u0026quot;, \u0026quot;servicename\u0026quot;: \u0026quot;ogmios\u0026quot;, \u0026quot;methodname\u0026quot;: \u0026quot;Query\u0026quot;, \u0026quot;args\u0026quot;: { \u0026quot;query\u0026quot;: \u0026quot;ledgerTip\u0026quot; } } At the moment of writing this guide, the following queries are available:\n   Query Result     blockHeight The chain\u0026rsquo;s highest block number.   chainTip The chain\u0026rsquo;s current tip.   currentEpoch The current epoch of the ledger.   currentProtocolParameters The current protocol parameters.   delegationsAndRewards Current delegation settings and rewards of given reward accounts.   eraStart The information regarding the beginning of the current era.   eraSummaries Era bounds and slotting parameters details, required for proper slot arithmetic.   genesisConfig Get a compact version of the era\u0026rsquo;s genesis configuration.   ledgerTip The most recent block tip known of the ledger.   nonMyopicMemberRewards Non-myopic member rewards for each pool. Used in ranking.   poolIds The list of all pool identifiers currently registered and active.   poolParameters Stake pool parameters submitted with registration certificates.   poolsRanking Retrieve stake pools ranking (a.k.a desirabilities).   proposedProtocolParameters The last update proposal w.r.t. protocol parameters, if any.   rewardsProvenance' Get details about rewards calculation for the ongoing epoch.   stakeDistribution Distribution of the stake across all known stake pools.   systemStart The chain\u0026rsquo;s start time (UTC).   utxo Current UTXO, possibly filtered by output reference.    Deprecated queries. Queries or functionalities listed below will be removed in the next major release of Ogmios.\n   Query Notice Deprecated Since     rewardsProvenance Supports for this query is not longer guaranteed. The pools field in the result is no longer populated. Use rewardsProvenance' instead cardano-node@1.33.0   utxo Filtering UTXO by address is no longer recommended with the introduction of on-disk ledger state storage. Filtering by output reference is preferred. cardano-node@1.33.0     To know more about arguments and results of each query, have a look at the API reference.\nSimplified Example In this example, we\u0026rsquo;ll consider a simple direct query on the network tip to fetch the latest protocol parameters. The next section gives a more elaborate example which shows how to acquire a specific point on chain.\nconst WebSocket = require(\u0026#39;ws\u0026#39;); const client = new WebSocket(\u0026#34;ws://localhost:1337\u0026#34;); function wsp(methodname, args) { client.send(JSON.stringify({ type: \u0026#34;jsonwsp/request\u0026#34;, version: \u0026#34;1.0\u0026#34;, servicename: \u0026#34;ogmios\u0026#34;, methodname, args })); } client.once(\u0026#39;open\u0026#39;, () =\u0026gt; { wsp(\u0026#34;Query\u0026#34;, { query: \u0026#34;currentProtocolParameters\u0026#34; } ); }); client.on(\u0026#39;message\u0026#39;, function(msg) { const response = JSON.parse(msg); console.log(JSON.stringify(response.result, null, 4)); client.close(); }); This little excerpt outputs the most recent protocol parameters in a nice JSON:\n{ \u0026#34;poolDeposit\u0026#34;: 500000000, \u0026#34;protocolVersion\u0026#34;: { \u0026#34;minor\u0026#34;: 0, \u0026#34;major\u0026#34;: 3 }, \u0026#34;minUtxoValue\u0026#34;: 1000000, \u0026#34;minFeeConstant\u0026#34;: 155381, \u0026#34;maxTxSize\u0026#34;: 16384, \u0026#34;minPoolCost\u0026#34;: 340000000, \u0026#34;maxBlockBodySize\u0026#34;: 65536, \u0026#34;extraEntropy\u0026#34;: \u0026#34;neutral\u0026#34;, \u0026#34;minFeeCoefficient\u0026#34;: 44, \u0026#34;poolInfluence\u0026#34;: \u0026#34;3/10\u0026#34;, \u0026#34;maxBlockHeaderSize\u0026#34;: 1100, \u0026#34;stakeKeyDeposit\u0026#34;: 2000000, \u0026#34;decentralizationParameter\u0026#34;: \u0026#34;1/5\u0026#34;, \u0026#34;desiredNumberOfPools\u0026#34;: 500, \u0026#34;poolRetirementEpochBound\u0026#34;: 18, \u0026#34;monetaryExpansion\u0026#34;: \u0026#34;3/1000\u0026#34;, \u0026#34;treasuryExpansion\u0026#34;: \u0026#34;1/5\u0026#34; } Full Example Let\u0026rsquo;s see a full example getting the stake distribution of all stake pools of the Cardano mainnet. In the example, we\u0026rsquo;ll also use the FindIntersect method from the local-chain-sync protocol to get an easy point to acquire.\nconst WebSocket = require(\u0026#39;ws\u0026#39;); const client = new WebSocket(\u0026#34;ws://localhost:1337\u0026#34;); function wsp(methodname, args) { client.send(JSON.stringify({ type: \u0026#34;jsonwsp/request\u0026#34;, version: \u0026#34;1.0\u0026#34;, servicename: \u0026#34;ogmios\u0026#34;, methodname, args })); } client.once(\u0026#39;open\u0026#39;, () =\u0026gt; { wsp(\u0026#34;FindIntersect\u0026#34;, { points: [\u0026#34;origin\u0026#34;] }); }); client.on(\u0026#39;message\u0026#39;, function(msg) { const response = JSON.parse(msg); switch (response.methodname) { case \u0026#34;FindIntersect\u0026#34;: const point = response.result.IntersectionFound.tip; wsp(\u0026#34;Acquire\u0026#34;, { point }); break; case \u0026#34;Acquire\u0026#34;: wsp(\u0026#34;Query\u0026#34;, { query: \u0026#34;stakeDistribution\u0026#34; }); break; case \u0026#34;Query\u0026#34;: console.log(response.result); client.close(); break; } }); Here\u0026rsquo;s a walk-though describing what happens when running the above script:\n  An initial request ask to FindIntersect that is guaranteed to succeed is sent. This is a little trick in order to access the ledger tip easily. As a response, Ogmios replies with:\n  IntersectionFound   { \u0026#34;version\u0026#34;: \u0026#34;1.0\u0026#34;, \u0026#34;servicename\u0026#34;: \u0026#34;ogmios\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;jsonwsp/response\u0026#34;, \u0026#34;methodname\u0026#34;: \u0026#34;FindIntersect\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;IntersectionFound\u0026#34;: { \u0026#34;point\u0026#34;: \u0026#34;origin\u0026#34;, \u0026#34;tip\u0026#34;: { \u0026#34;hash\u0026#34;: \u0026#34;dbafebb0146b2ec45186dfba6c287ad69c83d3fd9a186b39d99ab955631539e0\u0026#34;, \u0026#34;blockNo\u0026#34;: 4887546, \u0026#34;slot\u0026#34;: 12526684 } } }, \u0026#34;reflection\u0026#34;: null }      Using the tip from the previous response, we can now safely Acquire a state on that particular tip which we know exists and is not too old. Ogmios replies successfully with:\n  AcquireSuccess   { \u0026#34;version\u0026#34;: \u0026#34;1.0\u0026#34;, \u0026#34;servicename\u0026#34;: \u0026#34;ogmios\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;jsonwsp/response\u0026#34;, \u0026#34;methodname\u0026#34;: \u0026#34;Acquire\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;AcquireSuccess\u0026#34;: { \u0026#34;acquired\u0026#34;: { \u0026#34;hash\u0026#34;: \u0026#34;dbafebb0146b2ec45186dfba6c287ad69c83d3fd9a186b39d99ab955631539e0\u0026#34;, \u0026#34;slot\u0026#34;: 12526684 } } }, \u0026#34;reflection\u0026#34;: null }      Now in a position to make an actual Query, we do it and ask for the stake distribution across all stake pools. The (truncated) response from the server looks like:\n  QueryResponse   { \u0026#34;version\u0026#34;: \u0026#34;1.0\u0026#34;, \u0026#34;servicename\u0026#34;: \u0026#34;ogmios\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;jsonwsp/response\u0026#34;, \u0026#34;methodname\u0026#34;: \u0026#34;Query\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;pool1w3s6gk83y2g3670emy3yfjw9myz3u4whph7peah653rmsfegyj3\u0026#34;: { \u0026#34;stake\u0026#34;: 0, \u0026#34;vrf\u0026#34;: \u0026#34;29c1a293c550beea756bc0c01416bacd7030ae8992e13ca242d4d6c2aebaac0d\u0026#34; }, \u0026#34;pool1n5shd9xdt4s2gm27fxcnuejaqhhmpepn6chw2c82kqnuzdtpsem\u0026#34;: { \u0026#34;stake\u0026#34;: 0.00003058882418046271, \u0026#34;vrf\u0026#34;: \u0026#34;7e363eb8bfd8fef018da4c397d6a6ec25998363434e92276e40ee6c706da3ae5\u0026#34; }, \u0026#34;...\u0026#34; }, \u0026#34;reflection\u0026#34;: null }      Be aware that it is possible for an Acquire request to fail even if (and in particular if) made immediately after finding the ledger tip. In Ouroboros Praos frequent small rollbacks of the chain are not rare and the few last blocks of the chain can be a bit volatile. A real application may require more elaborate error handling than the toy example above.\n Example Queries currentEpoch { \u0026#34;query\u0026#34;: \u0026#34;currentEpoch\u0026#34; } currentProtocolParameters { \u0026#34;query\u0026#34;: \u0026#34;currentProtocolParameters\u0026#34; } delegationsAndRewards { \u0026#34;query\u0026#34;: { \u0026#34;delegationAndRewards\u0026#34;: [ \u0026#34;7c16240714ea0e12b41a914f2945784ac494bb19573f0ca61a08afa8\u0026#34; ] } } eraStart { \u0026#34;query\u0026#34;: \u0026#34;eraStart\u0026#34; } eraSummaries { \u0026#34;query\u0026#34;: \u0026#34;eraSummaries\u0026#34; } genesisConfig { \u0026#34;query\u0026#34;: \u0026#34;genesisConfig\u0026#34; } ledgerTip { \u0026#34;query\u0026#34;: \u0026#34;ledgerTip\u0026#34; } nonMyopicMemberRewards (by credentials) { \u0026#34;query\u0026#34;: { \u0026#34;nonMyopicMemberRewards\u0026#34;: [ \u0026#34;7c16240714ea0e12b41a914f2945784ac494bb19573f0ca61a08afa8\u0026#34; ] } } nonMyopicMemberRewards (by amounts) { \u0026#34;query\u0026#34;: { \u0026#34;nonMyopicMemberRewards\u0026#34;: [ 42000000 ] } } poolIds { \u0026#34;query\u0026#34;: \u0026#34;poolIds\u0026#34; } poolParameters { \u0026#34;query\u0026#34;: { \u0026#34;poolParameters\u0026#34;: [ \u0026#34;pool1pk2wzarn9mu64eel89dtg3g8h75c84jsy0q349glpsewgd7sdls\u0026#34;, \u0026#34;4acf2773917c7b547c576a7ff110d2ba5733c1f1ca9cdc659aea3a56\u0026#34; ] } } poolsRanking { \u0026#34;query\u0026#34;: \u0026#34;poolsRanking\u0026#34; } proposedProtocolParameters { \u0026#34;query\u0026#34;: \u0026#34;proposedProtocolParameters\u0026#34; } rewardsProvenance { \u0026#34;query\u0026#34;: \u0026#34;rewardsProvenance\u0026#34; } rewardsProvenance' { \u0026#34;query\u0026#34;: \u0026#34;rewardsProvenance\u0026#39;\u0026#34; } stakeDistribution { \u0026#34;query\u0026#34;: \u0026#34;stakeDistribution\u0026#34; } utxo (by Address) { \u0026#34;query\u0026#34;: { \u0026#34;utxo\u0026#34;: [ \u0026#34;addr1wx66ue36465w2qq40005h2hadad6pnjht8mu6sgplsfj74qhpnf3s\u0026#34;, \u0026#34;addr1xyxefct5wvh0n2h88uu44dz9q7l6nq7k2q3uzx54ruxr9e93ddt0tmqxf0n2c09tvq67lt5xkdnvc0wy5r2hzcpawrjsjk6m63\u0026#34; ] } } utxo (by TxIn) { \u0026#34;query\u0026#34;: { \u0026#34;utxo\u0026#34;: [ { \u0026#34;txId\u0026#34;: \u0026#34;ee155ace9c40292074cb6aff8c9ccdd273c81648ff1149ef36bcea6ebb8a3e25\u0026#34;, \u0026#34;index\u0026#34;: 2 } ] } } "},{"uri":"https://ogmios.dev/mini-protocols/","title":"Ouroboros Mini-Protocols","tags":[],"description":"","content":"Ouroboros Mini-Protocols In this section, we\u0026rsquo;ll give practical insights about interacting with the Ouroboros mini-protocols. Each sub-section will focus on one particular protocol, give an overview and give examples in JavaScript using Ogmios.\n"},{"uri":"https://ogmios.dev/mini-protocols/local-tx-submission/","title":"Local Tx Submission","tags":[],"description":"","content":" â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ Busy â”‚â—€â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•— â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜ SubmitTx / EvaluateTx â•‘ â”‚ â•‘ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ SubmitTxResponse / EvaluateTxResponse â”‚ Idle â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚ â”‚ â”‚ â”‚â‡¦ START â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   Overview Transaction submission is pretty simple \u0026amp; works by submitting an already serialized and signed transaction as one single message.\nIn case of success, Ogmios / the node returns an empty response. Otherwise, it returns an error with some details about what went wrong. Clients must thereby know how to construct valid transactions.\nDisclaimer The local tx-submission protocol is the simplest one in appearance. It nevertheless a quite extensive knowledge of the on-chain data-types used by Cardano. Indeed, the protocol in itself is straightforward so long as you already know how to produce and sign a transaction.\nThis guide doesn\u0026rsquo;t cover the creation and serialization of Cardano transactions. This is a rather vast topic and there is a handful of tools out there to help on the matter already, in particular:\n  cardano-serialization-lib which gives JavaScript and WASM bindings for every Cardano on-chain types.\n  cardano-transactions which offers a Haskell library and a command-line interface for constructing and signing transactions.\n  cardano-cli which offers another command-line interface for constructing and signing transactions.\n  In any case, one can always refer to the source CDDL specifications to know how to construct and serialize Cardano transactions.\nProviding a more user-friendly interface with regards to transactions in Ogmios is still under consideration. Yet, since in order to handle and sign transactions, one needs some knowledge about the on-chain binary format anyway, I\u0026rsquo;ve made the (effortless) choice to only treat with already serialized blobs in Ogmios. I am open to suggestions about how this could be made better, drop me a message on Github if you have ideas!\n SubmitTx Sending a transaction through the Cardano network requires one message using the method SubmitTx, and with a single mandatory arguments with bytes, representing a serialized signed transactions with its full witness.\nNote that JSON does not support embedding raw bytes in objects. Bytes needs therefore to be encoded in either Base16 or Base64; Ogmios will try both encoding.\n{ \u0026#34;type\u0026#34;: \u0026#34;jsonwsp/request\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0\u0026#34;, \u0026#34;servicename\u0026#34;: \u0026#34;ogmios\u0026#34;, \u0026#34;methodname\u0026#34;: \u0026#34;SubmitTx\u0026#34;, \u0026#34;args\u0026#34;: { \u0026#34;submit\u0026#34;: \u0026#34;\u0026lt;base16 or base64\u0026gt;\u0026#34; } } The response will indicate either a SubmitSuccess or SubmitFail. In case of failure, Ogmios will return a list of failures reported by the underlying node. Note that, if the transaction fails to parse, Ogmios will reply with a generic error.\nTransactions in Shelley are rather complicated and there is a lot of possible validation errors that can be returned. Be sure to have a look at the API reference for an exhaustive list.\nEvaluateTx Starting from 5.2.0, Ogmios supports a modified version of the local-tx-submission protocol that allows to evaluate the execution units of scripts present in a given transaction, without actually submitting the transaction. This is useful for DApp developers who wants a quick-and-easy way to measure script execution costs.\nThe API is purposely similar to the SubmitTx command, with a few semantic changes:\n The transaction needs not to be fully authenticated. Key witnesses may be omitted unless they are relevant to the evaluation of scripts themselves! The transaction needs not to be balanced; indeed, the evaluation does not perform a full execution of all the ledger rules. So while the transaction must be well-formed, it may be invalid with regards to phase-1 validations. Execution budgets assigned to redeemers are expected to be set to zero since the goal of this endpoint is to figure out these very execution budgets.  From there, the endpoint works similarly to SubmitTx, but with different method and argument names:\n{ \u0026#34;type\u0026#34;: \u0026#34;jsonwsp/request\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0\u0026#34;, \u0026#34;servicename\u0026#34;: \u0026#34;ogmios\u0026#34;, \u0026#34;methodname\u0026#34;: \u0026#34;EvaluateTx\u0026#34;, \u0026#34;args\u0026#34;: { \u0026#34;evaluate\u0026#34;: \u0026#34;\u0026lt;base16 or base64\u0026gt;\u0026#34; } } Successful responses include a map of redeemer pointers with the corresponding execution units. A redeemer pointer is a key composed of two parts: a redeemer entity tag and a 0-based index related to that entity. There exists 4 kinds of redeemer entities: spend (for transaction inputs), certificate (for transaction certificates), mint (for transaction monetary policies) and withdrawal (for transaction\u0026rsquo;s rewards withdrawals). The index therefore refers to the position of the script-locked entity within the set of entities in the transaction.\nFor example spend:0 points to the first transaction input; mint:2 would point to the 3rd policy referenced in the minting map\u0026hellip; and so forth. Here below is a JSON example of an evaluation result:\n{ \u0026#34;type\u0026#34;: \u0026#34;jsonwsp/response\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0\u0026#34;, \u0026#34;servicename\u0026#34;: \u0026#34;ogmios\u0026#34;, \u0026#34;methodname\u0026#34;: \u0026#34;EvaluateTx\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;EvaluationResult\u0026#34;: { \u0026#34;spend:0\u0026#34;: { \u0026#34;memory\u0026#34;: 1700, \u0026#34;steps\u0026#34;: 476468 } } }, \u0026#34;reflection\u0026#34;: null } See the full API reference for details about possible errors returned from this endpoint.\nIf you\u0026rsquo;re using typed Plutus validators (if you don\u0026rsquo;t know what that is, then it is most likely what you\u0026rsquo;re using), keep in mind that adding or removing elements to and off your transaction will change its execution cost. Indeed, the creation of the script context passed down to on-chain validators is done as part of the on-chain validator execution. Thus, larger contexts require more execution units!  This is the case for instance when you add a change output to a transaction or, a script integrity hash. A generally good way to approach this problem is to either: 1. make sure that the transaction you evaluate is as close as possible to the final transaction; that is, create dummy change outputs and script integrity hash before evaluating and fill-in their actual value once evaluated;2. keep some safe margin from the evaluated execution units; Execution units are relatively cheap on Cardano so, an extra 5 or 10% isn\u0026rsquo;t much and saves you in most cases a lot of hassle to cope with small differences.\n Additional UTXO Set In order to construct the validator script context, Ogmios needs to resolve transaction inputs from the Cardano blockchain. In case where a submitted transaction refers to non-existing inputs, the evaluation will fail with an UnknownInputs error. This can be an impediment during development or, in scenarios where transactions are being prepared ahead of UTXO.\nIn such scenarios, Ogmios gives way to provide an additional UTXO set to be used during evaluation. Note that it will still try to resolve inputs that are known, but will use the provided UTXO set as a complement for those that are unknown or yet-to-know.\nThe structure of the additional UTXO set is the same as UTXO sets returned in other part of the Ogmios' API; that is, an array of [TxIn, TxOut] tuples.\n For example:\n{ \u0026#34;type\u0026#34;: \u0026#34;jsonwsp/request\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0\u0026#34;, \u0026#34;servicename\u0026#34;: \u0026#34;ogmios\u0026#34;, \u0026#34;methodname\u0026#34;: \u0026#34;EvaluateTx\u0026#34;, \u0026#34;args\u0026#34;: { \u0026#34;evaluate\u0026#34;: \u0026#34;\u0026lt;base16 or base64\u0026gt;\u0026#34;, \u0026#34;additionalUtxoSet\u0026#34;: [ [ { \u0026#34;txId\u0026#34;:\u0026#34;97b2af6dfc6a4825e934146f424cdd6ede43ff98c355d2ae3aa95b0f70b63949\u0026#34; , \u0026#34;index\u0026#34;: 3 }, { \u0026#34;address\u0026#34;: \u0026#34;addr_test1qp9zjnc775anpndl0jh3w7vyy25syfezf70m7qmleaky0fdu9mqe2tg33xyxlcqcy98w630c82cyzuwyrumn65cv57nqwxm2yd\u0026#34; , \u0026#34;value\u0026#34;: { \u0026#34;coins\u0026#34;: 10000000 } } ] ] } } Full Example For what it\u0026rsquo;s worth, here\u0026rsquo;s an example of a transaction submission to the Cardano mainnet via Ogmios. This transaction is using dummy data and will obviously fail. It is however structurally valid, so useful to test if an integration works correctly.\nconst WebSocket = require(\u0026#39;ws\u0026#39;); const client = new WebSocket(\u0026#34;ws://localhost:1337\u0026#34;); function wsp(methodname, args) { client.send(JSON.stringify({ type: \u0026#34;jsonwsp/request\u0026#34;, version: \u0026#34;1.0\u0026#34;, servicename: \u0026#34;ogmios\u0026#34;, methodname, args })); } client.once(\u0026#39;open\u0026#39;, () =\u0026gt; { const submit = \u0026#34;g6QAgYJYIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGCglg5AQEBAQEBAQEB\u0026#34;+ \u0026#34;AQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBGgAehICC\u0026#34;+ \u0026#34;WDkBAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC\u0026#34;+ \u0026#34;AgICAgIaAHgXXAIaAAH6pAMZHkahAIGCWCABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\u0026#34;+ \u0026#34;AAAAAFhA169grjPSrzUUEcFEXHlZBSaZC/pzy7NzK1TvMi2qFC5ohAI0EPi+PBbpvVIHbyuz\u0026#34;+ \u0026#34;a/ON/gNKnwRljp9WGXq4D/Y=\u0026#34;; wsp(\u0026#34;SubmitTx\u0026#34;, { submit }); }); client.on(\u0026#39;message\u0026#39;, function(msg) { const response = JSON.parse(msg); console.log(response); client.close(); }); Ogmios replies negatively to the request, returning 4 errors reported by the ledger. Yet, this was indeed reported by the ledger itself, amazing isn\u0026rsquo;t it?\n  SubmitFail   { \u0026#34;version\u0026#34;: \u0026#34;1.0\u0026#34;, \u0026#34;servicename\u0026#34;: \u0026#34;ogmios\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;jsonwsp/response\u0026#34;, \u0026#34;methodname\u0026#34;: \u0026#34;SubmitTx\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;SubmitTxResponse\u0026#34;: { \u0026#34;error\u0026#34;: { \u0026#34;SubmitFail\u0026#34;: [ { \u0026#34;expiredUtxo\u0026#34;: { \u0026#34;transactionTimeToLive\u0026#34;: 7750, \u0026#34;currentSlot\u0026#34;: 12588967 } }, { \u0026#34;feeTooSmall\u0026#34;: { \u0026#34;requiredFee\u0026#34;: 168009, \u0026#34;actualFee\u0026#34;: 129700 } }, { \u0026#34;badInputs\u0026#34;: [ { \u0026#34;index\u0026#34;: 0, \u0026#34;txId\u0026#34;: \u0026#34;0000000000000000000000000000000000000000000000000000000000000000\u0026#34; } ] }, { \u0026#34;valueNotConserved\u0026#34;: { \u0026#34;consumed\u0026#34;: 0, \u0026#34;produced\u0026#34;: 10000000 } } ] } } }, \u0026#34;reflection\u0026#34;: null }    "},{"uri":"https://ogmios.dev/typescript-client/state-query/","title":"StateQuery Client","tags":[],"description":"","content":"The StateQuery client allows you to play with the Local State Query mini protocol; that is, a protocol for querying parts of the ledger state. The complete set of queries is described in the documentation. To use it, create a client from a context and start querying!\nimport { createStateQueryClient } from \u0026#39;@cardano-ogmios/client\u0026#39; const client = await createStateQueryClient(context) console.log(`ledgerTip: ${(await client.ledgerTip()).tip}`) // ledgerTip: {\u0026#34;slot\u0026#34;:33055551,\u0026#34;hash\u0026#34;:\u0026#34;050b05030645fdc4ee10e81f131030049c08f7763355873564540fe5a0533f43\u0026#34;}  console.log(`currentEpoch: ${await client.currentEpoch()}`) // currentEpoch: 146  await client.shutdown() // Close the connection when done. Acquire a specific point By default, the client will acquire the current tip of the blockchain and run all subsequent queries from that point. This makes it possible to get somewhat consistent data when running multiple queries. You can specify which point you want to acquire by providing an extra argument when constructing the client.\nFor example (notice how the ledgerTip remains unchanged, and equal to the acquired point!):\nimport delay from 'delay' import { createStateQueryClient } from '@cardano-ogmios/client' const point = { slot: 33055551, hash: '050b05030645fdc4ee10e81f131030049c08f7763355873564540fe5a0533f43' } const client = await createStateQueryClient(context, { point }) console.log(`ledgerTip: ${await client.ledgerTip().tip}`) // ledgerTip: {\u0026quot;slot\u0026quot;:33055551,\u0026quot;hash\u0026quot;:\u0026quot;050b05030645fdc4ee10e81f131030049c08f7763355873564540fe5a0533f43\u0026quot;} delay(5000) console.log(`ledgerTip: ${await client.ledgerTip().tip}`) // ledgerTip: {\u0026quot;slot\u0026quot;:33055551,\u0026quot;hash\u0026quot;:\u0026quot;050b05030645fdc4ee10e81f131030049c08f7763355873564540fe5a0533f43\u0026quot;}  You cannot acquire points that are too old on the blockchain. Too old may be a bit tricky to define but a good rule of thumb is: anything older than 64800 slots is too old (i.e. 3k/f).\n "},{"uri":"https://ogmios.dev/getting-started/testing/","title":"Testing","tags":[],"description":"","content":" You may skip this section if you\u0026rsquo;re not interested in contributing to Ogmios.\n ğŸ”§ Unit Tests First, make sure to pull and update git submodules:\n$ git submodule update --init Then, simply use stack as follows:\n$ stack test ogmios:unit ğŸ’¨ Smoke Tests Run the whole components stack using docker-compose as follows:\n$ docker-compose up Assuming the default configuration, Ogmios should be listening on :1337. Make sure that cardano-node is up-and-running and has finished its bootstraping phase (Ogmios should no longer print any warnings about HealthFailedToConnect). Then, open your favorite browser and visit http://localhost:1337/tests.html.\nTo tear down, press CTRL+C and then run:\n$ docker-compose down "},{"uri":"https://ogmios.dev/deployment/","title":"Deployment","tags":[],"description":"","content":"Deployment Find in this section information about deployment Ogmios with various service providers.\n"},{"uri":"https://ogmios.dev/mini-protocols/local-tx-monitor/","title":"Local Tx Monitor","tags":[],"description":"","content":" START â‡“ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â–¶ â”‚ Idle â”‚â‡’ DONE â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚ â”‚ AwaitAcquire â”‚ â”‚ â”‚ â”‚ â–¼ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” ReleaseMempool â”‚ â”‚ Acquiring â”‚ â”‚ â””â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚ â–² â”‚ Acquired â”‚ â”‚ â”‚ â”‚ â”‚ AwaitAcquire â”‚ â–¼ â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â” â””â”€â”€â”€â”€â”€â”€â”€â”€â”¤ Acquired â”‚ â””â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â–² HasTx|NextTx|SizeAndCapacity â”‚ â”‚ Reply (HasTx|NextTx|SizeAndCapacity) â–¼ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â” â”‚ Busy â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   Overview To inspect the node\u0026rsquo;s local mempool, one may rely on the local-tx-monitor mini-protocol. This protocol provides way to list all transactions sitting in the mempool, but also, to query the size of the mempool, the number of transactions currently in the mempool as well as the current capacity (based on network parameters).\nAs for the other mini-protocols, the local-tx-monitor is a stateful protocol with explicit state acquisition driven by the client. That is, clients must first acquire a mempool snapshot for running queries over it. Once acquired, queries are guaranteed to be consistent. In particular, NextTx will never yield twice the same transaction for the same snapshot and SizeAndCapacity will remain constant.\nAwaitAcquire is a blocking call. The server will only reply with Acquired once a \u0026ldquo;new\u0026rdquo; snapshot is available when \u0026ldquo;new\u0026rdquo; means different from the currently acquired snapshot. Seemingly, the first AwaitAcquire is instantaneous. This allows for clients to passively wait for changes without active polling. A typical pattern of usage would be to acquire a snapshot, list all transactions from the mempool via NextTx and then, block on AwaitAcquire for a change; then repeat.\nHow To Use First, client must always acquire a snapshot and hold onto it for subsequent queries. To list all queries, one must call NextTx repeatedly until it yields null. So for instance, if the mempool currently contains three transactions t0, t1 and t2, one can list all transactions from the mempool via the following sequence (schematically):\n 1. AwaitAcquire â†’ Acquired 2. NextTx â†’ NextTxResponse t0 3. NextTx â†’ NextTxResponse t1 4. NextTx â†’ NextTxResponse t2 5. NextTx â†’ NextTxResponse null  Another option is simply to query for a specific transaction via HasTx, which yields True or False depending on whether the transaction is currently in the mempool or not.\n 1. AwaitAcquire â†’ Acquired 2. HasTx t0 â†’ HasTxResponse True 3. HasTx t1 â†’ HasTxResponse True 4. HasTx t5 â†’ HasTxResponse False  At any moment, it is also possible to interleave a SizeAndCapacity query to get the acquired snapshot\u0026rsquo;s size (in bytes), number of transactions and capacity (in bytes).\nThe capacity refers to the maximum size of the mempool. It is currently defined as twice the network block size and can be adjusted via protocol updates.\n Important Notes Some important notes to keep in mind regarding the management of the mempool:\nAbout Transaction Locality This protocol gives access to transactions that are submitted locally, by the connected client via the local-tx-submission protocol. It does not provide access to transactions broadcast from peers. It is entire local.\nAbout Transaction Observability The protocol does not guarantee observability of all transactions passing through the mempool. There\u0026rsquo;s an inherent race condition between the client acquiring snapshots and the node managing it internally. Thus, while a client is holding a snapshot, it may still submit transactions through the local-tx-submission protocol, which may be accepted, processed and included in the ledger before the client next\u0026rsquo;s AwaitAcquire. So, it is possible for clients to miss transactions passing through the mempool should they be concurrently submitting them.\nAbout Transaction Status Furthermore, while the presence of a transaction in the mempool qualifies it as pending, the absence of transactions in the mempool does not guarantee their inclusion in the ledger (transaction may be discarded from the mempool for various reasons). In particular, a valid transaction may leave the mempool to be included in a block which later result in a lost fork (e.g. because of a lost slot battle) and may never end up in the ledger. The node does not automatically re-insert transactions into the mempool.\nFull Example const WebSocket = require(\u0026#39;ws\u0026#39;); const client = new WebSocket(\u0026#34;ws://localhost:1337\u0026#34;); // Helper function function wsp(methodname, args) { client.send(JSON.stringify({ type: \u0026#34;jsonwsp/request\u0026#34;, version: \u0026#34;1.0\u0026#34;, servicename: \u0026#34;ogmios\u0026#34;, methodname, args })); } client.on(\u0026#39;message\u0026#39;, e =\u0026gt; { const next = JSON.parse(e).result; if (next === null) { client.close(); } else { console.log(next); wsp(\u0026#34;NextTx\u0026#34;); } }); client.once(\u0026#39;open\u0026#39;, () =\u0026gt; { wsp(\u0026#34;AwaitAcquire\u0026#34;); }); API Reference The API reference will be available soon with the TypeScript client support.\nTest vectors for requests and responses are available on the repository for testing, debugging and to serve as examples.\n"},{"uri":"https://ogmios.dev/getting-started/monitoring/","title":"Monitoring","tags":[],"description":"","content":"Dashboard Ogmios offers a simple dashboard through HTTP with a real-time visualization of some of the server runtime metrics. If you\u0026rsquo;ve Ogmios up-and-running on the default port, visit http://localhost:1337 to view Ogmios' dashboard.\nHealth / Metrics Behind the scene, the dashboard is powered by metrics served over HTTP as JSON by the server. Reach /health (e.g. http://localhost:1337/health to get real-time information about your running server, including runtime metrics.\n$ curl -H 'Accept: application/json' http://localhost:1337/health { \u0026#34;metrics\u0026#34;: { \u0026#34;totalUnrouted\u0026#34;: 1, \u0026#34;totalMessages\u0026#34;: 30029, \u0026#34;runtimeStats\u0026#34;: { \u0026#34;gcCpuTime\u0026#34;: 1233009354, \u0026#34;cpuTime\u0026#34;: 81064672549, \u0026#34;maxHeapSize\u0026#34;: 41630, \u0026#34;currentHeapSize\u0026#34;: 1014 }, \u0026#34;totalConnections\u0026#34;: 10, \u0026#34;sessionDurations\u0026#34;: { \u0026#34;max\u0026#34;: 57385, \u0026#34;mean\u0026#34;: 7057, \u0026#34;min\u0026#34;: 0 }, \u0026#34;activeConnections\u0026#34;: 0 }, \u0026#34;startTime\u0026#34;: \u0026#34;2021-03-15T16:16:41.470782977Z\u0026#34;, \u0026#34;lastTipUpdate\u0026#34;: \u0026#34;2021-03-15T16:28:36.853115034Z\u0026#34;, \u0026#34;lastKnownTip\u0026#34;: { \u0026#34;hash\u0026#34;: \u0026#34;c29428f386c701c1d1ba1fd259d4be78921ee9ee6c174eac898245ceb55e8061\u0026#34;, \u0026#34;blockNo\u0026#34;: 5034297, \u0026#34;slot\u0026#34;: 15520688 }, \u0026#34;networkSynchronization\u0026#34;: 0.99, \u0026#34;currentEra\u0026#34;: \u0026#34;Mary\u0026#34;, \u0026#34;connectionStatus\u0026#34;: \u0026#34;disconnected\u0026#34;, \u0026#34;currentEpoch\u0026#34;: 164, \u0026#34;slotInEpoch\u0026#34;: 324543 } All information are computed at runtime and not preserved between restarts (at least not yet). The health response includes:\n   field description     connectionStatus A string \u0026quot;connected\u0026quot; or \u0026quot;disconnected\u0026quot; indicating whether Ogmios' server is correctly communicating with its underlying node.   startTime UTC timestamp at which the server was started.   lastTipUpdate UTC timestamp when lastKnownTip was last updated (can be null)   lastKnownTip Last known chain tip received from the node (can be null)   networkSynchronization A (nullable) percentage indicator of how far the server/node is from the network tip. 1 means it is synchronized.   currentEra The (nullable) current Cardano era of the underlying node. Useful for state-queries and debugging.   currentEpoch The (nullable) current epoch number known of the underlying node.   slotInEpoch The (nullable) relative slot number within the current epoch.   metrics.activeConnections Number of WebSocket connections currently established with the server.   metrics.totalConnections Total number of WebSocket connections established with the server since it\u0026rsquo;s started.   metrics.sessionDurations Some time measures (min, max, mean) of the duration of each sessions, in milliseconds.   metrics.totalMessages Total number of messages received from all / any WebSocket connections.   metrics.totalUnrouted Total number of invalid messages not routed to one of the mini-protocols, received from all / any WebSocket connections.   metrics.runtimeStats.gcCpuTime Time spent by the garbage collector cleaning up previously allocated data objects, in nano-seconds.   metrics.runtimeStats.cpuTime Time spent by the CPU doing work (at the last GC), in nano-seconds.   metrics.runtimeStats.maxHeapSize Maximum live data allocated in the heap, in kilo-bytes.   metrics.runtimeStats.currentHeapSize Current live data allocated in the heap, in kilo-bytes.    All dates / timestamps are given as ISO-8601 date-time strings.\n Runtime metrics (i.e. runtimeStats) are only available when the server is started with the +T runtime flag. This is the case by default, but can be manually turned on and off using the +RTS / -RTS options. For example ogmios --node-socket /path/to/socket +RTS -T -RTS will run Ogmios with runtime stats activated.\n "},{"uri":"https://ogmios.dev/typescript-client/tx-submission/","title":"TxSubmission Client","tags":[],"description":"","content":"Similarly to the other two clients, a TxSubmissionClient can be created from an InteractionContext (see the Overview section for more details).\nOnce created, it allows for submitting already serialized transactions to the network. The format it accepts is a CBOR-serialized Cardano transaction, as obtained from the cardano-cli or the cardano-serialization-lib, in either base16 or base64.\nIn case of success, the transaction is submitted to the network and should eventually be inserted in the ledger. Submitting transactions through Ogmios does indeed give you strong guarantees since behind the scene, the transaction gets fully validated by a Cardano node which has its own ledger. In case of error, the transaction is rejected with one of the many error causes in Cardano. You can find all the possible errors in the API reference.\nErrors are also conveniently exported from the client so that it is easy to assert the type of an error response. For example:\nimport { createTxSubmissionClient, TxSubmission } from \u0026#39;@cardano-ogmios/client\u0026#39; const client = await createTxSubmissionClient(context) try { await client.submitTx(toCBOR(tx)) } catch (error) { await expect(error[0]).toBeInstanceOf(TxSubmission.errors.BadInputs.Error) await expect(error[1]).toBeInstanceOf(TxSubmission.errors.ValueNotConserved.Error) } "},{"uri":"https://ogmios.dev/typescript-client/","title":"TypeScript Client","tags":[],"description":"","content":"TypeScript Client This section covers usage of the Ogmios TypeScript client library and goes over a few common use-cases. It\u0026rsquo;s best to have first some (at least basic) understanding of the Ouroboros mini-protocols from the previous section before diving in.\n"},{"uri":"https://ogmios.dev/api-reference/","title":"API Reference","tags":[],"description":"","content":"Ogmios as a JSON-WSP service is entirely described using JSON Schema - Draft 7. This can be fed into various tools to generate code, data-types or definitions in many languages. In particular, the server schema can be visualized here.\nThe schema is large (200+ type definitions!) for it covers everything there\u0026rsquo;s to cover in Cardano. If you get lost, look for the Ogmios object in the search bar to get back to the root of the schema!\n If you\u0026rsquo;re using TypeScript, take a look at the API reference for the TypeScript client or more specifically, documentation for one of the Ouroboros mini-protocols clients:\n ChainSync StateQuery TxSubmission  Ogmios is tested against this JSON schema to make sure that it remains up-to-date as new features are added.\n  Download JSON Schema  "},{"uri":"https://ogmios.dev/getting-started/basics/","title":"Basics","tags":[],"description":"","content":"JSON-WSP Ogmios' interface is built on top of JSON-WSP which is a tiny standard to give some structure to the various messages that can be exchanged with Ogmios. The standard specifies a top-level JSON envelope by which messages must abide, as well as a semantic for some of the fields. In particular, there are 4 types of messages possible in JSON-WSP:\n descriptions requests responses faults (which are a special kind of responses).  We won\u0026rsquo;t be covering the JSON-WSP standard in this guide but gives a few extra insights about how it relates to Ogmios and some good takes from it. Each request in Ogmios yields exactly one response, might it be a normal response or a fault. Furthermore, requests which relate to a particular protocol are guaranteed to yield responses in the same order.\nRequests Requests messages are sent by client applications (you) to Ogmios. Requests have 3 fields of interest: methodname, args and mirror. The methodname identifies the request itself and translates to a corresponding message of one of the 3 Ouroboros mini-protocols. Possible values for the methodname are described in section 3 - Ouroboros mini-protocols and the complete reference is available in section 4 - API Reference.\nHere is an example of valid request message:\n{ \u0026#34;type\u0026#34;: \u0026#34;jsonwsp/request\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0\u0026#34;, \u0026#34;servicename\u0026#34;: \u0026#34;ogmios\u0026#34;, \u0026#34;methodname\u0026#34;: \u0026#34;FindIntersect\u0026#34;, \u0026#34;args\u0026#34;: { \u0026#34;points\u0026#34;: [ \u0026#34;origin\u0026#34; ] }, \u0026#34;mirror\u0026#34;: { \u0026#34;step\u0026#34;: \u0026#34;INIT\u0026#34; } } As you can see, the methodname specifies the method FindIntersect which relates to the local chain-sync Ouroboros mini-protocol. This particular request expects one argument named points, which contains a list of points we want to intersect with (don\u0026rsquo;t panic, this is explained in further details in the next section!). Another interesting, albeit optional, field is the mirror field. This is completely free-form and will be spit back identically by Ogmios in the response. This can be useful to keep track of states on the client application or pass in extra context to each request/response. Be careful though that anything you send for a request will come back in the response; send something big, get something big.\nResponses Let\u0026rsquo;s start with a possible response to the request above:\n{ \u0026quot;type\u0026quot;: \u0026quot;jsonwsp/response\u0026quot;, \u0026quot;version\u0026quot;: \u0026quot;1.0\u0026quot;, \u0026quot;servicename\u0026quot;: \u0026quot;ogmios\u0026quot;, \u0026quot;methodname\u0026quot;: \u0026quot;FindIntersect\u0026quot;, \u0026quot;result\u0026quot;: { \u0026quot;IntersectionFound\u0026quot;: { \u0026quot;point\u0026quot;: \u0026quot;origin\u0026quot;, \u0026quot;tip\u0026quot;: { \u0026quot;hash\u0026quot;: \u0026quot;d184f428159290bf3558b4d1d139e6a07ec6589738c28a0925a7ab776bde4d62\u0026quot;, \u0026quot;blockNo\u0026quot;: 4870185, \u0026quot;slot\u0026quot;: 12176171 } } }, \u0026quot;reflection\u0026quot;: { \u0026quot;step\u0026quot;: \u0026quot;INIT\u0026quot; } } The response kindly indicates which requests it corresponds to and has the same methodname as the matching request. It also gives a result under a specific field. Responses can have various results which are fully specified in section 4. - API Reference. Also, notice the reflection field which reflects exactly the mirror field that was set for the request.\nOgmios' responses may correspond to possible errors that are part of the Ouroboros mini-protocols. For example, if you submit an invalid transaction, you\u0026rsquo;ll get back a message of type jsonwsp/response because it is a valid message in the context of the mini-protocols. Yet, Ogmios will yield a message of type jsonwsp/fault if you submit an invalid Ogmios message (for instance, an unknown request constructor, or something that is not a valid JSON-WSP message).\n WebSocket Ogmios uses WebSocket as a communication protocol. The WebSocket protocol is full-duplex, which means that Ogmios and clients can send messages to each other all at the same time. That is very convenient for clients who can pipeline many requests at once and process responses later on as they arrive.\nTherefore, to send a message to ogmios, you only need a WebSocket client! For example, using the well-established ws Node.js package and assuming a local instance of Ogmios started through Docker, you can interact with Ogmios as simply as:\nconst WebSocket = require(\u0026#39;ws\u0026#39;); const client = new WebSocket(\u0026#34;ws://localhost:1337\u0026#34;); client.once(\u0026#39;open\u0026#39;, () =\u0026gt; { const request = { \u0026#34;type\u0026#34;: \u0026#34;jsonwsp/request\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0\u0026#34;, \u0026#34;servicename\u0026#34;: \u0026#34;ogmios\u0026#34;, \u0026#34;methodname\u0026#34;: \u0026#34;FindIntersect\u0026#34;, \u0026#34;args\u0026#34;: { \u0026#34;points\u0026#34;: [ \u0026#34;origin\u0026#34; ] } }; client.send(JSON.stringify(request)); }); client.on(\u0026#39;message\u0026#39;, function(msg) { const response = JSON.parse(msg); // do something with \u0026#39;response\u0026#39; }); That\u0026rsquo;s all for the basics. The rest isn\u0026rsquo;t really specific to Ogmios, but is about the Ouroboros mini-protocols themselves. See the next sections for a deep dive!\n"},{"uri":"https://ogmios.dev/changelog/","title":"Changelog","tags":[],"description":"","content":"[5.2.0] - 2022-02-15 Added  ğŸ¢ Server   Extended the local-tx-submission protocol with a new EvaluateTx query which evaluates execution units of scripts present in a transaction. This effectively piggybacks on the Alonzo\u0026rsquo;s tools from the cardano-ledger while providing a more user-friendly interface regarding network parameters. The API offers well-detailed errors and an interface similar to the SubmitTx. See discussion on #172.\n  New rewardsProvenance' query coming as a replacement for the now-deprecated rewardsProvenance query. See discussion on #171.\n  ğŸš— TypeScript Client  Support for the new evaluateTx query in the TxSubmissionClient \u0026amp; repl. Support for the new rewardsProvenance' query as rewardsProvenanceNew in the StateQueryClient \u0026amp; repl.   Changed  ğŸ¢ Server   Added transaction id as part of the successful response to a SubmitTx. While this is technically a breaking-change, it was introduced in a backward-compatible way. Existing applications using the existing SubmitTx query will see no change and will keep receiving successes as \u0026quot;SubmitSuccessful\u0026quot; text responses. However, queries which pass transactions using the submit field (instead of the currently expected bytes field) will receive, on success, an augmented response which contains a transaction id \u0026quot;SubmitSuccessful\u0026quot;: { \u0026quot;txId\u0026quot;: \u0026quot;...\u0026quot; }. See discussion on #174.\n  Improved error reporting for the SubmitTx protocol which should gives a little clearer errors for ill-formed transactions.\n  ğŸš— TypeScript Client  :warning: Renamed client\u0026rsquo;s TxSubmission/errors.ts into TxSubmission/submissionErrors.ts. Similarly, the submission are also now nested under a submissionErrors field in the TxSubmission top-level object.   Removed  N/A\n [5.1.0] - 2022-01-24 Added  ğŸ¢ Server   New LocalTxMonitor support in Ogmios. See The user guide for more details.\nâš ï¸ This new protocol is NOT enabled in cardano-node@1.33.*. Until its inclusion in a next release, a custom build of cardano-node is required to include a more recent version of ouroboros-network which adds support for that protocol to the Ouroboros' mini-protocols; namely: 32af9168.\nA version of cardano-node@1.33.0 patched with the necessary commits can be found at CardanoSolutions/cardano-node@1.33.0+local-tx-monitor.\n  New fields in the health object:\n connectionStatus â†’ \u0026quot;connected\u0026quot; or \u0026quot;disconnected\u0026quot;, to reflect status with the node. #154 currentEpoch â†’ which returns the current known epoch of the linked node #164 slotInEpoch â†’ which returns the relative number of slots elapsed in the current epoch #164    New ogmios health-check command, useful to perform simple health check on a running server. For example, to monitor a container via Docker health check mechanism:\nHEALTHCHECK --interval=10s --timeout=5s --retries=1 CMD /bin/ogmios health-check  Bumped internal dependencies to Cardano\u0026rsquo;s 1.33.* eco-system.\n   Changed  ğŸ¢ Server  networkSynchronization and currentEra can be null when the server isn\u0026rsquo;t connected to a node. #154 The Metrics trace is now correctly tagged with MetricsRuntimeStatsDisabled. Fixed an issue with the Docker monitoring scripts of cardano-node-ogmios, causing issues on restart. #159  ğŸš— TypeScript Client  Relax upper-bound constraint on required node.js engine. This should make it possible to install the TypeScript packages on more recent versions on node.js than the one specified on the repository.   Removed  N/A\n [5.0.0] - 2021-12-20 Added  ğŸ¢ Server   New state-query systemStart to access the blockchain start time (UTC).\n  New state-query chainTip to access the blockchain current tip (may slightly differ from the ledgerTip which may be behind catching up).\n  New state-query blockHeight to access the blockchain current highest block number (or \u0026quot;origin\u0026quot; if the chain is just starting).\n  New state-query eraSummaries to access all era bounds and slotting parameters details, required for proper slot arithmetic.\n  Log-levels can now be configured per-component. For example, one can decrease the min severity for the health component while keeping the state-query logs at another.\n  Logs can now be shutdown completely via the special keyword off.\n  Static binaries for Linux are now produced by the Nix build and uploaded as build artifacts for the corresponding Github workflow (i.e. Nix).\n  ğŸš— TypeScript Client  Add support for systemStart, chainTip, blockHeight \u0026amp; eraSummaries in the client and repl.   Changed  ğŸ¢ Server   âš ï¸ RelativeTime is no-longer serialised as a string (with s as suffix) but, as an integer representing the number of seconds.\n  âš ï¸ Serialised Plutus scripts are now labelled either plutus:v1 or plutus:v2 (instead of plutus).\n  âš ï¸ Some breaking changes in the SubmitTx errors returned by the server for the sake of consistency. All submission errors are now returned as singleton objects within an array. The key of each object indicates the type of error and the value gives additional details about the errors. This is also true for era-mismatch errors. Some errors used to be returned as plain strings, they are now wrapped as singleton object with null as a value; this is the case for:\n invalidMetadata mirNegativeTransferNotCurrentlyAllowed mirProducesNegativeUpdate mirTransferNotCurrentlyAllowed missingAtLeastOneInputUtxo missingCollateralInputs triesToForgeAda validationTagMismatch wrongCertificateType    Upgraded internal dependencies to Cardano eco-system 1.31.0\n  ğŸš— TypeScript Client   âš ï¸ Lovelace is now a native BigInt.\n  âš ï¸ getServerHealth\u0026rsquo;s connection argument is now wrapped into an object, mapped to the field connection. (see #135)\n  âš ï¸ Replaced schema definitions for Hash16 and Hash64 with more precise type definitions. For hashes, definitions now follows a convention Digest[ALGORITHM]::PRE-IMAGE where ALGORITHM and PRE-IMAGE points to the corresponding has algorithm used to hash the PRE-IMAGE. The length of the digest is given by minLength and maxLength JSON-schema constraints. Consequently, TypeScript types / interfaces generated from the JSON-schema definitions have been altered.\n   Removed  ğŸ¢ Server  âš ï¸ Log level severities critical, alert and emergency have been removed. error is now the highest severity.     âš ï¸ The Nix setup has been highly simplified, resulting in removal of the NixOS services configuration and probably some other stuff.   [4.2.1] - 2021-11-16 Added  N / A\n Changed  ğŸ¢ Server  Fixed configuration parsing which would wrongly use Shelley\u0026rsquo;s slots per epoch instead of Byron\u0026rsquo;s. This had an impact on the reported slot number in the chain-sync protocol, where slot numbers would be wrongly offset by 432000 per epoch after the first epoch.   Removed  N/A\n [4.2.0] - 2021-11-05 Added  ğŸ¢ Server   Enabled Alonzo transaction in the submission protocol (oversight from previous releases). Doing so, explicit compiler warnings have been added to the relevant code to avoid overseeing this in the next upgrade.\n  Added query response and requests to logs trace, large responses are truncated (e.g. querying the entire UTXO or, informations about all stake pools).\n  Gracefully handled shutdown and process cleanup on SIGTERM.\n  Documented Mary last point to the points of interests for the chain-sync protocol.\n  Bumped cardano-node\u0026rsquo;s integration to 1.31.0\n  ğŸš— TypeScript Client  The State-Query client can now release acquired points to perform queries against the most recent tip (which was also the default when creating a client with no point).   Changed  ğŸš— TypeScript Client  Some internal rework and cleanup; mostly chasing dangling promises by avoiding attaching even handlers when not needed.   Removed  N/A\n [4.1.0] - 2021-09-08 Added  ğŸ¢ Server   Generate and store test vectors for various JSON requests and responses. This should ease integration for many clients who seek for good coverage of the server inputs/outputs.\n  Documented example state queries in the user-guide.\n  ğŸš— TypeScript Client   The ConnectionConfig has an additional, optional, configuration parameter maxPayload to configure the maximum allowed message size in bytes. The default is chosen quite large as the utxo query can result in large payloads.\n  New helpers isByronEpochBoundaryBlock and isByronStandardBlock.\n   Changed  ğŸš— TypeScript Client  The StateQueryClient now wraps every query in a try/catch to cope with malformed queries leading to client fault results from the server. Type definitions for QueryResponse[poolIds] and QueryResponse[poolParameters] are no longer marked as \u0026ldquo;optional\u0026rdquo;. Fixed bug #125 where empty results of delegationAndRewards would cause the client to throw an exception. Handled some floating promises.   Removed N/A\n[4.0.0] - 2021-09-06 Added ğŸ¢ Server    Integrated with the Cardano eco-system corresponding to cardano-node@1.29.0 (Alonzo!) \u0026amp; latest testnet(s).\n  New alonzo block type, with various additions related to Alonzo.\n  New state-queries:\n   Query Description     poolIds The list of all pool identifiers currently registered and active.   poolParameters Stake pool parameters submitted with registration certificates.   poolsRanking Retrieve stake pools ranking (a.k.a desirabilities).   rewardsProvenance Get details about rewards calculation for the ongoing epoch.      Added missing properties in Byron\u0026rsquo;s protocol parameters update. Somehow, an additionalProperties: true had slipped through and caused the tests to pass with an incomplete schema.\n  Nested logs are now also structured, in particular those coming from the Handshake or TxSubmission protocols. Before, any message from these layers where actually plain strings with unintelligible gibberish. Now, the submitted transaction payload is shown encoded as hexadecimals and errors are also serialized to json using the same model / codec as the one used for websockets. The handshake is also more verbose now clearly showing what version is being requested and what the node replies / select. All in all, better logs.\n  The Dockerfile now includes a build definition for building cardano-node and ogmios into the same image, which is the default and suggested mode of operation. To build an image with only Ogmios, use the build --target ogmios. Docker Hub now hosts two image repositories: cardanosolutions/cardano-node-ogmios and cardanosolutions/ogmios.\n  Docker Hub images are now tagged with a network suffix (e.g. -mainnet). In the case of mainnet, the -mainnet suffix is optional, and points to the same build as the defaults.\n  A new repository for hosting Cardano configurations of various services was created and is now used in Ogmios. Configuration for cardano-node (and therefore Ogmios) or, network genesis can be found in input-output-hk/cardano-configurations. Configurations are updated automatically by a nightly job to be always up-to-date. They can be pulled into projects as git submodules.\n  New possible errors from the transaction submission (stemming from the Alonzo integration):\n collateralHasNonAdaAssets collateralIsScript collateralTooSmall collectErrors datumsMismatch executionUnitsTooLarge extraDataMismatch extraRedeemers mirNegativeTransferNotCurrentlyAllowed mirProducesNegativeUpdate mirTransferNotCurrentlyAllowed missingDatumHashesForInputs missingRequiredDatums missingRequiredRedeemers missingRequiredSignatures outsideForecast poolMetadataHashTooBig tooManyCollateralInputs unspendableDatums unspendableScriptInputs validationTagMismatch     ğŸš— TypeScript Client    Compatibility with aforementioned server additions.\n  The TypeScript ChainSyncClient now implements an in-memory queue to ensure requestNext responses are processed sequentially when there are async operations in the message handlers. This behaviour can be bypassed where sequential processsing is not required, by setting the new construction option sequential to false.\n  The TypeScript StateQueryClient can now re-acquire new points at will, useful for long-running clients for which previously acquired points may expire.\n  The TypeScript client is now fully documented!\n   Changed ğŸ¢ Server    âš ï¸ The utxo query can now accept a list TxIn as argument, and still supports list of Address. Note that lists can\u0026rsquo;t be heterogeneous and it\u0026rsquo;s not possible to mix TxIn and Address.\n  âš ï¸ Asset quantities and transaction metadata\u0026rsquo;s integers are now parsed as native BigInt.\n  The memory and steps JSON representations for prices are no longer coins, but ratio (represented as strings in the API).\n  The moveInstantaneousRewards certificates have a new optional field value and not only a rewards map as before. When value is present, it signifies that rewards are moved to the other pot.\n  Auxiliary data\u0026rsquo;s scriptPreImages in Allegra \u0026amp; Mary has been replaced with a field scripts which has one field native. The value of native corresponds to what used to be the value of scriptPreImages. In Alonzo, scripts may also have another field plutus with a serialized Plutus script.\n  Transactions witnesses' address has been renamed into signatures, and the structure of the object has been changed to be a map from public keys to signatures (instead of an object with two field key \u0026amp; signature).\n  Transactions witnesses' script has been renamed into scripts.\n  Transaction submission errors' networkMismatch now returns an invalidEntities list of object in the form of { \u0026quot;type\u0026quot;: ..., \u0026quot;entity\u0026quot;: } where type is a text tag designating the type of entity for which there is a network identifier mismatch. Values can be address, rewardAccount and since Alonzo transactionBody. The entity field contains some details specific to the type of entity. Before, it used to be two distinct fields invalidAddresses and invalidRewardAccounts.\n  Empty transaction metadata are no longer materialized by an object with two null fields ({ \u0026quot;hash\u0026quot;: null, \u0026quot;body\u0026quot;: null }). Empty transaction metadata are now equal to null.\n  map metadatum in transactions' metadata are no longer materialized as a list of list of singleton objects: [[{ \u0026quot;k\u0026quot;: ... }, { \u0026quot;v\u0026quot;: ... }], ...] but instead, as a list of object with two fields k and v: [{ \u0026quot;k\u0026quot;: ..., \u0026quot;v\u0026quot;: ...}, ...]. This was an oversight from the encoder which was never intended to end up that way but happened to slip in because the schema for metadatum was not specified / documented (and therefore, also escaped testing). This is now documented properly.\n  The TxOut (and thus Utxo) model definitions have been unified and harmonized across all eras. That is, pre-Mary eras now also wrap Ada values in an object with a field \u0026quot;coins\u0026quot;: .... This reduces the discrepancy between eras for there\u0026rsquo;s now a single TxOut representation valid across all eras. Some fields are however optional and only present in some eras (e.g. datum starting from Alonzo)\n   ğŸš— TypeScript Client    âš ï¸ State queries (resp. the StateQueryClient) now automatically runs queries against the last known tip if no explicit point is provided. It used to acquire a point on the first query which would eventually become too old. The behavior is now equivalent to acquiring a new point on every query!\n  âš ï¸ SubmitTx no-longer returns Byron errors. Consequently, submit errors are no longer scoped under errors.byron or errors.shelley but simply errors.\n  âš ï¸ Fixed proposedProtocolParameters query. All fields are actually required AND, more importantly, it can now return either Shelley protocol parameters or, Alonzo protocol parameters.\n  The ChainSyncClientMessageHandlers methods now must return a promise.\n  Various reworks and renaming of the TypeScript types\n AssetQuantity is now a native bigint Metadatum\u0026rsquo;s Int are now native bigint Type DelegationsAndRewards renamed into DelegationsAndRewardsByAccounts Type DelegationsAndRewards1 renamed into DelegationsAndRewards Type NonMyopicMemberRewards1 renamed into NonMyopicMemberRewards Type TxTooLarge1 renamed into TxTooLarge Type FeeTooSmall1 renamed into FeeTooSmall Type NetworkMismatch1 renamed into NetworkMismatch Type Proposal renamed into UpdateProposalShelley Types Utxo1, Utxo2, UtxoMary have been unified into a single Utxo type. Refer to server breaking changes for details. Type Tip \u0026amp; Point renamed into TipOrOrigin and PointOrOrigin. As a consequence, Tip1 and Point1 are now simply Tip and Point. Many types NullX merged into a single Null type Query types have been renamed from ledgerTip1 to GetLedgerTip and so forth for all queries.     Removed ğŸ¢ Server    datumsMismatch, a previously introduced error from the transaction submission has been removed / replaced.\n  SubmitTx can no longer return SubmitTxError[Byron]. All the child error types have been removed accordingly, namely:\n UtxoValidationError TxValidationError LovelaceError     ğŸš— TypeScript Client    ChainSyncClient no longer exposes a requestNext function. Instead you must invoke the callback provided as the second argument in each of rollBackward and rollForward handlers.\n  ChainSyncClient no longer exposes JSON-WSP reflection as there would be unexpected results given the first n messages would all share the same reflected value.\n   [3.2.0] - 2021-05-09 Added  New TypeScript client! The client comes in three packages:  An interactive REPL to play with Ogmios using the command-line. A generator to derive TypeScript type definitions from the JSON schema. The actual client library providing nice wrapper around the various protocol, in a typed way. The TypeScript client also includes a new battery of automated integration tests against the testnet.   Support for WebSocket sub-protocols, with currently one support sub-protocol: ogmios.compact.v1. When enabled, Ogmios will omit fields such as witnesses, proofs and signatures from responses to make responses smaller. Provide missing documentation / JSON-schema for:  JSON-WSP faults Allegra \u0026amp; Mary SubmitTx failures:   Allegra:\n expiredUtxo is replaced by outsideOfValidityInterval new error triesToForgeAda  Mary:\n valueNotConserved.consumed is now a Value (instead of a DeltaCoin) valueNotConserved.produced is now a Value (instead of a DeltaCoin) outputTooSmall items are now of type TxOut[Mary] new error tooManyAssetsInOutput       Continuous integration job checking for code style and lint on the server source code. The /health endpoint now returns two additional pieces of information:  A networkSynchronization percentage to indicate how far Ogmios / the node is from the network. A currentEra value to indicate the corresponding Cardano era Ogmios / the node is currently running in.   Nix support for building Ogmios (this also include a cabal.project to enable cabal support as well).  Changed  Rework Docker setup to not require an external snapshot image. Everything is now built in a single Dockerfile, but cache from DockerHub can be leveraged to reduce overall build time when building from scratch. Fixed typo in the JSON-schema w.r.t to the \u0026lsquo;Acquire\u0026rsquo; request (points â†’ point), and introduce more automated test to catch this kind of errors more easily.  Removed Ã¸\n[3.1.0] - 2021-04-04 Added  Extend the local-state query protocol with support for \u0026lsquo;GetCompactGenesis\u0026rsquo;. Extend the local-state query protocol with support for \u0026lsquo;GetFilteredDelegationsAndRewards\u0026rsquo;. Add missing mint field to transaction\u0026rsquo;s body (added since mary). The documentation is now hosted on https://ogmios.dev.  Changed  Use \u0026lsquo;contentEncoding\u0026rsquo; over \u0026lsquo;format\u0026rsquo; in appropriate part of the JSON schema. Fix various errors in the JSON-schema definition \u0026amp; extend test suite coverage in consequence. Implement a \u0026lsquo;fast-bech32\u0026rsquo; encoding library, to speed-up Ogmios serialization of blocks beyond the Shelley era. Use faster (and recommended) JSON encoding techniques to speed up overall JSON serialization. Improve generated documentation from JSON schema by:  Providing titles to \u0026lsquo;oneOf\u0026rsquo; items Adding descriptions to top-level definitions Adding examples to top-level definitions   Customized API reference\u0026rsquo;s stylesheet to enhance readability. Upgrade dependency and code to work with GHC-8.10.4 (from GHC 8.6.5) Handle more gracefully unknown exceptions (avoid infinite fast loop of retries on errors). Handle more gracefully network mismatches (e.g. connecting Ogmios in testnet mode to a mainnet network) Repository reorganization:  \u0026lsquo;ogmios-server\u0026rsquo; renamed into \u0026lsquo;server\u0026rsquo; move Haskell-specific dotfiles and configuration files under \u0026lsquo;server\u0026rsquo; move \u0026lsquo;modules\u0026rsquo; under \u0026lsquo;server\u0026rsquo; move \u0026lsquo;Dockerfile\u0026rsquo; and \u0026lsquo;snapshot.Dockerfile\u0026rsquo; under \u0026lsquo;server\u0026rsquo;    Removed  Support for GHC-8.6.5 The docker image no longer shows git revision / version on \u0026lsquo;\u0026ndash;version\u0026rsquo;  [3.0.0] \u0026ndash; 2021-02-26 Added  Support for the Allegra era on the chain-sync, tx submission and state query protocols. Support for the Mary era on the chain-sync, tx submission and state query protocols. Support for multi-era state queries, or said differently, Ogmios can survive a hard-fork without being restarted or re-compiled. Allow clients to also make state queries based on the node\u0026rsquo;s tip (instead of passing an explicit point to acquire). Interactive dashboard leveraging Ogmios health\u0026rsquo;s endpoint and local state query protocol to show metrics in real-time. Automated smoke sanity tests executed on a running instance, running queries and chain-syncs across all eras. Various internal optimization, in particular with rewards to the chain-sync protocol (~14.000 blocks/s in Byron, ~2500 block/s in Shelley and beyond). Additional metrics for monitoring: current heap size, total messages, total unrouted messages and start time. Configurable HTTP server timeout from the command-line, with sensible defaults.  Changed  Improve error responses to invalid clients' requests (instead of generic error messages). Fixed various typos and clumsy wording in the user manual. Reworked internal architecture as a Three-Layer Haskell Cake. Changed internal dependencies for base16 and base64 encoding for better performances. Upgraded internal dependencies to the Cardano eco-system working with cardano-node@1.25.1 Improved error handling of the Ogmios server, in particular in case of connections lost with the underlying node. The server now returns an explicit client error when interleaving \u0026lsquo;FindIntersect\u0026rsquo; messages in-between pipelined \u0026lsquo;RequestNext\u0026rsquo;. Revised default compilation flags .  Removed Ã¸\n[2.0.0-beta] \u0026ndash; 2020-10-31 Added  Support for the Shelley chain in the local-chain-sync protocol. Support for the local-state-query protocol. Health / Heartbeat endpoint for monitoring. Runtime and application metrics measured and served on endpoint (/health). Ogmios now includes an HTTP static server hosting both the WSP definition and, a /benchmark.html to run some quick benchmark / smoke test. Added additional configuration options via command-line or environment. Revised user manual with detailed step-by-step examples.  Changed  Several JSON fields renamed to increase consistency between Shelley and Byron. Improved logging, more messages and with more context. Improved error handling with regards to connection of websocket clients.  Removed Ã¸\nChanged [1.0.0-beta] \u0026ndash; 2020-04-04 Added   Initial release and support for:\n Chain Synchronization (no pipelining between cardano-node \u0026amp; ogmios) Local Transaction Submission    JSON-WSP version 1.0, full support with reflection.\n  Full docker stack via docker-compose.\n  Basic command-line and logging.\n  Changed Ã¸\nRemoved Ã¸\n"},{"uri":"https://ogmios.dev/faq/","title":"F.A.Q","tags":[],"description":"","content":"Can you explain Ogmios in one three sentences? Ogmios is a lightweight bridge interface for cardano-node. It offers a WebSockets API that enables local clients to speak Ouroboros' mini-protocols via JSON/RPC. Ogmios is a fast and lightweight solution that can be deployed alongside relays to create entry points on the Cardano network for various types of applications (e.g. wallets, explorers, chatbots, dashboardsâ€¦)\nCan you explain Ogmios to me like I\u0026rsquo;m five? To understand what Ogmios is, you must first understand where it fits in Cardano landscape. Cardano is a network of programs (a.k.a nodes) connected to each other and exchanging messages to run the Cardano blockchain. A Cardano node has an interface that allows for other programs to interact with it (very much like buttons on a remote to control the TV). However, that interface relies on novel communication methods, that were designed in-house by the networking team at IOG. To this day, the only tooling that can implement those unique communication methods is written in Haskell (as if all the buttons on the remote control were in Chinese, but you only speak French). So to interact with a Cardano node, one has no other choice than to write a Haskell program, which is a bummer for many application developers.\nThis is where Ogmios comes into play. Ogmios is written in Haskell, so it can speak with Cardano nodes just fine. But it also translates all the interfaces provided by the node using communication methods that are more common and accessible to the vast majority of developers (namely, WebSockets \u0026amp; JSON). Ogmios is a sort of translator; instead of speaking to a Cardano node directly, applications can speak to Ogmios using a language they know, and Ogmios translates it to the node and back to the applications.\nWhere does the name come from? Ogmios is a celtic deity of eloquence, language and learning. This relates to the way this project helps users communicate with Cardano. And while it doesnâ€™t translate languages, it translates protocols to protocols.\nWhy do I care? Well, it depends. In essence, Ogmios doesn\u0026rsquo;t do much more than what the node itself does. It\u0026rsquo;s pretty much as low-level as things can get with the Cardano network. For many applications, this is too low in the abstraction layer and they would be better off using higher-level services like cardano-graphql, Rosetta, or Blockfrost.\nHowever, building such services demands to be able to interact with the blockchain using a more direct interface. This interface can be Ogmios. Currently, the choices given to services like these are limited: talk directly to the node using the Haskell client library, or use cardano-db-sync which is a component that talks to the node and dumps blockchain data in a PostgreSQL database. For those who don\u0026rsquo;t write Haskell, the choice is even more limited; down to a single option. Plus, like any solution, it comes with trade-offs. Deploying a cardano-db-sync instance can be quite heavy, requires extra space, and already forces applications to operate in some specific ways. Ogmios gives a lightweight alternative that is also much closer to what the node offers. It would be possible for example to re-implement cardano-db-sync in a different programming language using Ogmios.\nSo in the end, if you\u0026rsquo;re writing a DApp or an application that needs to interact with the Cardano blockchain only at a high level using pre-defined abstractions, then you probably don\u0026rsquo;t care. However, if you\u0026rsquo;re doing some low-level work, and need to access every bit of the protocol or, if you\u0026rsquo;re building a service on top of Cardano for which the blockchain itself is the right level of abstraction, then Ogmios is most likely a good fit for you.\nCan I build X using Ogmios? The short answer is: if you can build X with a Cardano node, then yes. Ogmios is as capable as the client interface for Cardano nodes. Can I build a wallet with Ogmios? Yes. Can I build an explorer with Ogmios? Yes. Can I build a smart-contract application backend with Ogmios? Yes. Anything available on-chain is available through Ogmios which has so far also transitioned through the 4 eras of Cardano. Ogmios' first release was a bit before the Shelley hard-fork, and its development followed the on-chain upgrades and protocol updates.\nWhat\u0026rsquo;s the overhead from running Ogmios? Almost none. Ogmios runs within a handful of megabytes of memory and its CPU usage is very much driven by whatever application you\u0026rsquo;ll be connecting to it. That is if your application is syncing the entire blockchain and sending thousands of messages per second to the underlying node, then of course your CPU will get pretty busy; not from Ogmios itself, however, but mostly from the underlying node and your client. In between, Ogmios acts as a bridge and passes messages around. Once a message has been passed, Ogmios forgets about it. That makes the memory footprint of Ogmios quite low, and its resource usages tightly linked to whatever application consumes data from it.\nWe secretly keep a hope that someday, many operators will deploy Ogmios alongside their relays. Enabling many application developers to interact with the Cardano blockchain seamlessly by connecting to a relay close to them.\nIs there any client for Ogmios? As a matter of fact, there is. A TypeScript client library and REPL is available on the same repository. This is huge and comparable to what web3.js is for Ethereum. And this is only a beginning. We\u0026rsquo;ll keep working on this to grow the client into a more capable SDK for Cardano. In a future where Ogmios is deployed alongside relays, it could become dead simple to get started with web applications development for Cardano. Simply import the TypeScript client, connect to a relay nearby and start hacking.\nBesides, it goes without saying that as an open-source project Ogmios welcomes contributions; especially on the client library and/or around tools built on top.\nDoes Ogmios require the PAB (Plutus Application Backend) to work? No it does not. The PAB is an application framework which provides DApp developers with an extra interface for running smart-contracts on Cardano; Ogmios is not a DApp, nor does it require any DApp functionality. Ogmios does however require a full cardano-node to work for it is merely an interface on top of it.\nCan I use Ogmios in a remote setup? Yes. The easiest way is probably by using a reverse-proxy like NGINX to also promote the WebSocket connection to a secure connection. A more interesting question however is: should you? Ogmios is an interface for the so-called local client protocols which are, by design, intended to be used in a local setup: where Ogmios and cardano-node are on the same host. It would be ill-advised to expose the server to many clients without any restriction as each client can drain a quite large amount of resources from the local node. Rather, Ogmios ought to be used in a backend stack for a service which requires an access to the blockchain.\nWhy do Ogmios returns JSON with integers larger than MAX_SAFE_INTEGER? JSON does support large integers by design. The default JavaScript JSON parser does not however. Thus, it is not a problem which lies on the server-side, but rather on \u0026ldquo;naive\u0026rdquo; JavaScript clients. For more details, have a look at this architectural decision record which explains how we handle large integers in the TypeScript client.\nIs Ogmios production ready? Ogmios is an open-source project which is being worked on in small steps when time allows. Its development started in 2020 and it has undergone several updates and iterations. We\u0026rsquo;ve got a mad passion for software quality and we put extensive efforts into making Ogmios of the highest quality. The server follows a well-known architecture and abides by battle-tested Haskell coding practices. As it should, Ogmios is of course deeply tested at several levels via continuous integration1.\nTests for the server include property-based testing of the core protocols2 3, property-based testing of the entire JSON interface validated against a JSON-schema specification4. Note that property tests all use generators which comes directly from the ouroboros-network and cardano-ledger-specs to ensure that Ogmios is always up-to-date with the Cardano eco-system. There are also various5 unit6 tests7 to cover basic functionalities.\nOn the other hand, the TypeScript client is used to perform end-to-end tests with tests running against the Cardano testnet8. The tests are executed both in a Node.js and browser context and the synchronization with the network is done via a Github action which leverages Ogmios' server.\nBeside, Ogmios also comes with structured logging and monitoring out of the box. Putting any monitoring solution on top like Prometheus is trivial.\nFinally, if you ventured through this page and user-guide, you have also noticed that the project is well-documented. And this includes the API reference, the ChangeLog as well as the architectural decisions going over rationales for decisions we made along the way.\nThus, is Ogmios production-ready? Probably, yes. At least, this is as good as it gets for an open-source project. We\u0026rsquo;ve been incorporating feedback from various users over the past year which has been great so far. For the rest, everything is open-source licensed under MPL-2.0 and you\u0026rsquo;re the best judge.\nAre there any projects using it? We\u0026rsquo;ve heard of a handful happy users! And it keeps growing\u0026hellip;\n https://ccwallet.io/ https://www.sundaeswap.finance/ https://github.com/input-output-hk/cardano-graphql https://www.f2lb.org/ https://gimbalabs.com/dandelionapis/ogmios-api  There are also projects still in preparation which looked into Ogmios as a lightweight alternative to cardano-db-sync for it better suited their need.\nAre you using Ogmios for a project? Let us know on Github!\n "},{"uri":"https://ogmios.dev/","title":"Overview","tags":[],"description":"","content":"Ogmios Ogmios is a lightweight bridge interface for cardano-node. It offers a WebSockets API that enables local clients to speak Ouroboros' mini-protocols via JSON/RPC.\n Need more information? Have a look at the Frequently Asked Questions!\n"},{"uri":"https://ogmios.dev/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"https://ogmios.dev/tags/","title":"Tags","tags":[],"description":"","content":""}]