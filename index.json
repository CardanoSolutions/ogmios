[{"uri":"https://ktorz.github.io/cardano-ogmios/getting-started/","title":"Getting Started","tags":[],"description":"","content":"Getting Started Find in this section information about building and running Ogmios. This will cover installation from both sources and docker 🐳, as well as details about options and configuration for running Ogmios.\n"},{"uri":"https://ktorz.github.io/cardano-ogmios/deployment/aws/","title":"AWS","tags":[],"description":"","content":"Pre-Requisites   Make sure to have an AWS account, and an AWS_ACCESS_KEY_ID \u0026amp; AWS_SECRET_ACCESS_KEY.\n  Make sure to grant AmazonEC2FullAccess to your AWS user.\n  You\u0026rsquo;ll need to create a security group which allows inbound TCP connections. See also: Working With Security Groups.\n  Install docker-machine\n  Create an SSH key/pair $ ssh-keygen -t rsa -b 4096 -C \u0026quot;your_email@example.com\u0026quot; -f aws_rsa $ eval \u0026quot;$(ssh-agent -s)\u0026quot; $ ssh-add ~/.ssh/aws_rsa Create The Docker Machine AWS_ACCESS_KEY_ID=\u0026lt;YOUR_ACCESS_KEY_ID\u0026gt; AWS_SECRET_ACCESS_KEY=\u0026lt;YOUR_SECRET_KEY\u0026gt; docker-machine create -d amazonec2 \\  --amazonec2-access-key $AWS_ACCESS_KEY_ID \\  --amazonec2-secret-key $AWS_SECRET_ACCESS_KEY \\  --amazonec2-region eu-west-3 \\  --amazonec2-instance-type \u0026#34;t2.medium\u0026#34; \\  --amazonec2-ssh-keypath ~/.ssh/aws_rsa \\  aws-ogmios Push The Stack First, configure your shell and activate your docker-machine:\n$ eval $(docker-machine env aws-ogmios) Then, simply push the stack using docker-compose:\n$ COMPOSE_TLS_VERSION=TLSv1_2 docker-compose up -d  Compose may use a wrong TLS version for pulling layers from dockerhub. Hence the ENV var.\n 🎉 Enjoy $ docker-machine ls NAME ACTIVE DRIVER STATE URL SWARM DOCKER ERRORS aws-ogmios * amazonec2 Running tcp://xx.xxx.xxx.xxx:xxxx v19.03.8 (Optional) Adding TLS with a registered domain   Install nginx.\n    Configure a new server as /etc/nginx/sites-enabled/domain.extension   ```nginx server { server_name DOMAIN.EXTENSION; listen 80; location ^~ /.well-known/acme-challenge/ { try_files $uri /dev/null =404; } } ```    👆 Make sure to replace \u0026lsquo;DOMAIN.EXTENSION\u0026rsquo; with your actual registered domain.\n  Reload your nginx configuration with: sudo systemctl reload nginx.service.\n  Install certbot and let certbot configure your nginx server (sudo certbot --nginx).\n  Once done, edit your nginx configuration one more time\u0026hellip;\n    Remove (no longer needed after certbot has successfully configured the server)    ```nginx location ^~ /.well-known/acme-challenge/ { try_files $uri /dev/null =404; } ```        And add the following clause to enable routing all traffic (including WebSockets) to ogmios    ```nginx location ~* / { proxy_pass http://localhost:1337; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \u0026quot;Upgrade\u0026quot;; proxy_set_header Host $host; } ```        The final configuration should look like this:\nserver { server_name ogmios.dev; location ~* / { proxy_pass http://localhost:1337; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \u0026#34;Upgrade\u0026#34;; proxy_set_header Host $host; } listen 443 ssl; # managed by Certbot  ssl_certificate /etc/letsencrypt/live/ogmios.dev/fullchain.pem; # managed by Certbot  ssl_certificate_key /etc/letsencrypt/live/ogmios.dev/privkey.pem; # managed by Certbot  include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot  ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot } server { server_name ogmios.dev; listen 80; if ($host = ogmios.dev) { return 301 https://$host$request_uri; } # managed by Certbot  return 404; # managed by Certbot } "},{"uri":"https://ktorz.github.io/cardano-ogmios/getting-started/docker/","title":"Docker","tags":[],"description":"","content":"🐳 The easiest way to get started is to use docker. This guide won\u0026rsquo;t cover installing docker, so make sure you have the docker daemon installed and running. Since Ogmios requires the presence of a Cardano node, we\u0026rsquo;ll be using docker-compose to orchestrate both services. A compose file is available on the Ogmios repository, get it via:\n$ wget https://raw.githubusercontent.com/KtorZ/cardano-ogmios/master/docker-compose.yml -O docker-compose.yml Then, starts the components stack using:\n$ docker-compose up 👆This will run and connect together:\n A Cardano node, connected to mainnet. An Ogmios server using the latest Dockerhub build, listening to localhost on port :1337.  To build the Ogmios image from sources, pass the --build flag. This is useful if you need a different version than the latest one available on Dockerhub.\nConfiguration The compose file allows for minimal (albeit useful) configuration parameters via environment variables:\n   Variable Description Values Default     NETWORK Which Cardano network to connect to. This impacts both Ogmios and the underlying Cardano node. mainnet, testnet mainnet   OGMIOS_PORT Which ports to listen to (both for WebSockets and health endpoints) Any valid port number. 1337    Ogmios doesn\u0026rsquo;t use any form of persistent storage, but cardano-node does. The mainnet and testnet databases are not compatible, so it is recommended to instrument docker-compose to use different namespaces for different networks (so that you can switch from one another without risking any database conflicts). Compose can do this easily by passing an extra flag: --project-name.\n For example, for running cardano-node + ogmios on the testnet, listening to tcp/1338, do:\n$ NETWORK=testnet OGMIOS_PORT=1338 docker-compose --project-name cardano-ogmios-testnet up "},{"uri":"https://ktorz.github.io/cardano-ogmios/mini-protocols/local-chain-sync/","title":"Local Chain Sync","tags":[],"description":"","content":"*-----------* | Intersect |◀══════════════════════════════╗ *-----------* FindIntersect ║ │ ║ │ *---------* │ Intersect.{Found,NotFound} | | └───────────────────────────────╼| | | Idle | ╔═══════════════════════════════════| | ║ RequestNext | |⇦ START ║ *---------* ▼ ╿ *------* Roll.{Backward,Forward} │ | Next |────────────────────────────────────┘ *------*  Overview Clients that wish to synchronise blocks from the Cardano chain can use the Local Chain Sync protocol.\nThe protocol is stateful, which means that each connection between clients and Ogmios has a state: a cursor locating a point on the chain. Typically, a client will start by looking for an intersection between its own local chain and the one from the node / Ogmios. Then, it\u0026rsquo;ll simply request the next action to take: either rolling forward and adding new blocks, or rolling backward.\nHow To Use 🚧 Coming Soon: JavaScript Examples with Ogmios 🚧\n"},{"uri":"https://ktorz.github.io/cardano-ogmios/getting-started/building/","title":"Building","tags":[],"description":"","content":" You may skip this section if you\u0026rsquo;re using Docker 🐳.\n Pre-requisites Ogmios is built using the great Haskell build tool stack. You\u0026rsquo;ll also need git to clone the source code, that is:\n git 2.11.* stack 2.*.*  Ogmios in itself is a rather small project, yet it\u0026rsquo;s using library directly from the ouroboros-network, cardano-ledger-specs and cardano-node projects. This is handy for re-using existing logic, but comes at the cost of several system dependencies that are required for building everything. Some may already be installed on your system, but the complete list is:\n libsodium-dev 1.0.* libgmp-dev 6.1.* libssl-dev 1.1.* libpcre3-dev 2.8.* libsystemd-dev zlib1g-dev 1.2.*  🔨 Ogmios Clone the git repository from Github:\n$ git clone git@github.com:KtorZ/cardano-ogmios.git \u0026amp;\u0026amp; cd cardano-ogmios Then, use Stack to compile the project source code from the repository root:\n$ stack build ogmios The first time, this may take a while as Stack needs to setup a compilation environment and to download a lot of dependencies. Subsequent executions are much faster.\nFrom there, you can run Ogmios via stack using the exec command:\n$ stack exec -- ogmios --help Alternatively, you can instrument Stack to copy the compiled executable elsewhere so that you can run Ogmios all by itself:\n$ stack install ogmios $ ogmios --help 📚 Documentation API Reference Install json-schema-for-humans using pip3:\n$ pip3 install json-schema-for-humans And then, run:\n$ cd docs \u0026amp;\u0026amp; generate-schema-doc --config no_link_to_reused_ref ../ogmios.wsp.json index.html "},{"uri":"https://ktorz.github.io/cardano-ogmios/mini-protocols/local-tx-submission/","title":"Local Tx Submission","tags":[],"description":"","content":"Overview *----------* | Busy |◀══════════════════════════════╗ *----------* SubmitTx ║ │ ║ │ *---------* │ | | │ | | │ SubmitTxResponse | Idle | └───────────────────────────────╼| | | |⇦ START *---------*  Transaction submission is pretty simple \u0026amp; works by submitting an already serialized and signed transaction as one single message.\nIn case of success, Ogmios / the node returns an empty response. Otherwise, it returns an error with some details about what went wrong. Clients must thereby know how to construct valid transactions.\n🚧 Coming Soon: JavaScript Examples with Ogmios 🚧\n"},{"uri":"https://ktorz.github.io/cardano-ogmios/mini-protocols/","title":"Ouroboros Mini-Protocols","tags":[],"description":"","content":"Ouroboros Mini-Protocols In this section, we\u0026rsquo;ll give practical insights about interacting with the Ouroboros mini-protocols. Each sub-section will focus on one particular protocol, give an overview and give examples in JavaScript using Ogmios.\n"},{"uri":"https://ktorz.github.io/cardano-ogmios/deployment/","title":"Deployment","tags":[],"description":"","content":"Deployment Find in this section information about deployment Ogmios with various service providers.\n"},{"uri":"https://ktorz.github.io/cardano-ogmios/mini-protocols/local-state-query/","title":"Local State Query","tags":[],"description":"","content":"Overview 🚧 Coming Soon 🚧\n"},{"uri":"https://ktorz.github.io/cardano-ogmios/getting-started/testing/","title":"Testing","tags":[],"description":"","content":" You may skip this section if you\u0026rsquo;re not interested in contributing to Ogmios.\n 🔧 Unit Tests First, make sure to pull and update git submodules:\n$ git submodule update --init Then, simply use stack as follows:\n$ stack test ogmios:unit 💨 Smoke Tests Run the whole components stack using docker-compose as follows:\n$ docker-compose up To tear down, press CTRL+C and then run:\n$ docker-compose down "},{"uri":"https://ktorz.github.io/cardano-ogmios/api-reference/","title":"API Reference","tags":[],"description":"","content":"🚧 Coming Soon 🚧\n"},{"uri":"https://ktorz.github.io/cardano-ogmios/getting-started/json-wsp/","title":"JSON-WSP","tags":[],"description":"","content":"Overview Ogmios' interface is built on top of JSON-WSP which is a tiny standard to give some structure to the various messages that can be exchanged with Ogmios. The standard specifies a top-level JSON envelope by which messages must abide, as well as a semantic for some of the fields. In particular, there are 4 types of messages possible in JSON-WSP:\n descriptions requests responses faults (which are a special kind of responses).  We won\u0026rsquo;t be covering the JSON-WSP standard in this guide but gives a few extra insights about how it relates to Ogmios and some good takes from it. Each request in Ogmios yields exactly one response, might it be a normal response or a fault. Furthermore, requests which relate to a particular protocol are guaranteed to yield responses in the same order.\nRequests Requests messages are sent by client applications (you) to Ogmios. Requests have 3 fields of interest: methodname, args and mirror. The methodname identifies the request itself and translates to a corresponding message of one of the 3 Ouroboros mini-protocols. Possible values for the methodname are described in section 3 - Ouroboros mini-protocols and the complete reference is available in section 4 - API Reference.\nHere is an example of valid request message:\n{ \u0026#34;type\u0026#34;: \u0026#34;jsonwsp/request\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0\u0026#34;, \u0026#34;servicename\u0026#34;: \u0026#34;ogmios\u0026#34;, \u0026#34;methodname\u0026#34;: \u0026#34;FindIntersect\u0026#34;, \u0026#34;args\u0026#34;: { \u0026#34;points\u0026#34;: [ \u0026#34;origin\u0026#34; ] }, \u0026#34;mirror\u0026#34;: { \u0026#34;step\u0026#34;: \u0026#34;INIT\u0026#34; } } As you can see, the methodname specifies the method FindIntersect which relates to the local chain-sync Ouroboros mini-protocol. This particular request expects one argument named points, which contains a list of points we want to intersect with (don\u0026rsquo;t panic, this is explained in further details in the next section!). Another interesting, albeit optional, field is the mirror field. This is completely free-form and will be spit back identically by Ogmios in the response. This can be useful to keep track of states on the client application or pass in extra context to each request/response. Be careful though that anything you send for a request will come back in the response; send something big, get something big.\nResponses Let\u0026rsquo;s start with a possible response to the request above:\n{ \u0026quot;type\u0026quot;: \u0026quot;jsonwsp/response\u0026quot;, \u0026quot;version\u0026quot;: \u0026quot;1.0\u0026quot;, \u0026quot;servicename\u0026quot;: \u0026quot;ogmios\u0026quot;, \u0026quot;methodname\u0026quot;: \u0026quot;FindIntersect\u0026quot;, \u0026quot;result\u0026quot;: { \u0026quot;IntersectionFound\u0026quot;: { \u0026quot;point\u0026quot;: \u0026quot;origin\u0026quot;, \u0026quot;tip\u0026quot;: { \u0026quot;hash\u0026quot;: \u0026quot;d184f428159290bf3558b4d1d139e6a07ec6589738c28a0925a7ab776bde4d62\u0026quot;, \u0026quot;blockNo\u0026quot;: 4870185, \u0026quot;slot\u0026quot;: 12176171 } } }, \u0026quot;reflection\u0026quot;: { \u0026quot;step\u0026quot;: \u0026quot;INIT\u0026quot; } } The response kindly indicates which requests it corresponds to and has the same methodname as the matching request. It also gives a result under a specific field. Responses can have various results which are fully specified in section 4. - API Reference. Also, notice the reflection field which reflects exactly the mirror field that was set for the request.\nOgmios' responses may correspond to possible errors that are part of the Ouroboros mini-protocols. For example, if you submit an invalid transaction, you\u0026rsquo;ll get back a message of type jsonwsp/response because it is a valid message in the context of the mini-protocols. Yet, Ogmios will yield a message of type jsonwsp/fault if you submit an invalid Ogmios message (for instance, an unknown request constructor, or something that is not a valid JSON-WSP message).\n "},{"uri":"https://ktorz.github.io/cardano-ogmios/","title":"Overview","tags":[],"description":"","content":"Overview Ogmios is a translation service written in Haskell running on top of cardano-node. It offers a JSON-WSP interface through WebSockets and enables clients to speak Ouroboros' mini-protocols via remote procedure calls over JSON. Ogmios is very lightweight too and can be deployed alongside relays to create entry points on the Cardano network for various type of applications (e.g. wallets, explorers, chatbots, dashboards\u0026hellip;).\nMotivation All programs offer more or less elaborated interfaces for either user or program interactions. That is, most user-facing programs include a graphical user interface (a.k.a GUI) where users can send signals via buttons and switches, and receive visual or auditive feedback from the program. Some programs are also meant to be used by other programs and are typically called services; such services offer application programming interfaces in various forms to enable other programs (or services) to interact. The nodes from Cardano belong to the second category, yet the offer a rather exotic interface: ad-hoc protocols designed in-house by IOHK to be extremely efficient and secure.\nIn order to deal with a Cardano node, one has therefore to speak one of these so-called Ouroboros mini-protocols. This can be an impediment to mass adoption for the only existing implementation of such protocols is written in Haskell. Ogmios is an attempt to lower down that entry barrier by translating the interface to a set of technology that is well-known on the Web. In essence, it is very much like putting a power socket adaptor on the wall in order to branch a device; Cardano node is the device, Ogmios is the socket adaptor.\nOgmios is thereby very lightweight and doesn\u0026rsquo;t do anything on its own. It is running next to a Cardano node and act as an intermediary for another client application. Ogmios emulates the Ouroboros mini-protocols through WebSockets and translates the binary on-chain data into JSON; both WebSockets and JSON are widespread over the Web and in many other applications so much that they offer the ideal mainstream interface that I hope will help getting more and more application developers to build with Cardano!\nAbout me My name is Matthias (a.k.a KtorZ) and I currently work with the engineering teams of IOHK to build Cardano. My main area of focus within the Cardano project is basically anything that deals with a Cardano node, which means a lot of things! From a very young age, I\u0026rsquo;ve been enjoying designing and writing programs. Ogmios is yet another instance of this which I started as a proof-of-concept on my free-time, and rapidly became one of my most sophisticated side-project.\n"},{"uri":"https://ktorz.github.io/cardano-ogmios/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"https://ktorz.github.io/cardano-ogmios/tags/","title":"Tags","tags":[],"description":"","content":""}]