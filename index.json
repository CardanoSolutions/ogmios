[{"uri":"https://ogmios.dev/getting-started/","title":"Getting started","tags":[],"description":"","content":"Getting started Find in this section information about building and running Ogmios. This will cover installation from both sources and docker üê≥, as well as details about options and configuration for running Ogmios.\n"},{"uri":"https://ogmios.dev/mini-protocols/local-chain-sync/","title":"Chain synchronization","tags":[],"description":"","content":"START ‚áì ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ Idle ‚îÇ‚áí DONE ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚îÇ findIntersection ‚îÇ ‚îÇ ‚îÇ findIntersection ‚îÇ ‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ ‚ñº ‚îÇ ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îÇ Initialized ‚îÇ‚óÄ‚îÄ‚îÄ‚ïØ ‚îî‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚ñ≤ nextBlock ‚îÇ ‚îÇ ‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ   Overview Clients that wish to synchronise blocks from the Cardano chain can use the chain synchronization mini-protocol.\nThe protocol is stateful, which means that each connection between clients and Ogmios has a state: a cursor locating a point on the chain. Typically, a client will start by looking for an intersection between its own local chain and the one from the node / Ogmios. Then, it\u0026rsquo;ll simply request the next action to take: either rolling forward and adding new blocks, or rolling backward.\nHow To Use When a connection is opened with Ogmios, it automatically starts a chain synchronization session with the underlying cardano-node. There\u0026rsquo;s an implicit state maintained by the node which one can imagine as a cursor, pointing to a point on the Cardano chain. Initially, this cursor starts at a special point called: origin (as in, the origin of the chain). After each request, the node will move the cursor either forward or backward and remembers its location for the next request. To move the cursor, the protocols gives two mechanisms: nextBlock and findIntersection.\n____ ____ ____ ____ ____ ____ / /\\ / /\\ / /\\ / /\\ / /\\ / /\\ o === /____/ \\ === /____/ \\ === /____/ \\ === /____/ \\ === /____/ \\ === /____/ \\ == ... \\ \\ / \\ \\ / \\ \\ / \\ \\ / \\ \\ / \\ \\ / \\____\\/ \\____\\/ \\____\\/ \\____\\/ \\____\\/ \\____\\/ ^ | | origin \n Requesting next blocks Clients may ask for the next block where \u0026lsquo;next\u0026rsquo; refers directly to that implicit cursor. This translates to a message with nextBlock as a method name. This request does not accept any arguments (i.e. `params).\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;nextBlock\u0026#34; } As a response, Ogmios will send back a response which can instruct you either to roll forward or to roll backward. Rolling forward is pretty straightforward and is the main type of response one can expect; such response will include the next block, which itself includes a header, transactions, certificates, metadata and all sort of information.\nRolling backward however may occur when, since the last request, the underlying node decided to switch to a different fork of the chain to the extent that the previous cursor is no longer pointing to a block that exists on the chain. The node therefore asks (kindly) to roll backward to a previously known point that is the earliest ancestor that is common between the client\u0026rsquo;s own chain locally and the one that was just adopted by the node.\n____ ____ / /\\ / /\\ /____/ \\ === /____/ \\ (node's chain) \\ \\ / \\ \\ / / \\____\\/ \\____\\/ / ____ ____ / ____ ____ / /\\ / /\\ / / /\\ / /\\ === /____/ \\ === /____/ \\ =.= /____/ \\ === /____/ \\ (local chain) \\ \\ / \\ \\ / ^ \\ \\ / \\ \\ / \\____\\/ \\____\\/ | \\____\\/ \\____\\/ |  | common chain prefix | | point of rollback   When rolling backward, the node will not provide a block but instead, a point which is made of a block header hash and a slot.\nAs a client, it is therefore crucial to be able to rollback to a previous point of the chain. In practice, Ouroboros guarantees that forks cannot be longer than a certain length. This maximum length is called k in the Ouroboros protocol, and also known as the security parameter.\n Pipelining Ogmios will do its best to pipeline requests to the Cardano node. Yet unlike WebSocket, the chain synchronization protocol only allows for finite pipelining. Said differently, Ogmios cannot pipeline an arbitrary and potentially infinite number of requests and will actually starts collecting responses if too many requests are pipelined. Pipelining with WebSocket is however straightforward for most clients permit sending many requests at once and handle responses using callbacks on event handlers.\nTo leverage pipelining using the WebSocket, you will need send multiple requests at once and have your client handler send new requests for each response. Behind the scene, the server will translate that to explicit pipelining with the cardano-node and maximize the bandwith utilization. Note that you also probably want to send requests for the next message before you even start processing the last received message. This permits the server to start working on fetching and sending you the next result while you process the current one.\nconst nextBlock = JSON.stringify({ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;nextBlock\u0026#34;, }); client.on(\u0026#39;open\u0026#39;, () =\u0026gt; { // Burst the server\u0026#39;s queue with a few requests.  for (let i = 0; i \u0026lt; 100; i += 1) { client.send(nextBlock); } }); client.on(\u0026#39;message\u0026#39;, msg =\u0026gt; { client.send(nextBlock); // Ask for next request immediately  doSomething(msg); })  How many requests to pipeline depends on your application and machine resources. If you\u0026rsquo;re pipelining many requests in a client application, make sure to also take times to collect and handle responses because there will be no extra benefits coming from too much pipelining. A good rule of thumb on most standard machines is to pipeline 50-100 requests.\n Finding an intersection On the first connection with the node, clients will likely synchronize from the origin. Yet, on subsequent connections one may want to resume syncing to a point that is much more recent than the origin. Ideally, one would like to carry on exactly at the point where the chain was left yet as we just saw, this is not always possible. The chain synchronization protocol gives however clients a way to find a common intersection between a client\u0026rsquo;s current version of the chain and whatever version the node has. This is via the findIntersection method. This method accepts one argument which is a list of header hashes (or the special keyword \u0026quot;origin\u0026quot;).\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;findIntersection\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;points\u0026#34;: [ { \u0026#34;slot\u0026#34;: 39916796, \u0026#34;hash\u0026#34;: \u0026#34;e72579ff89dc9ed325b723a33624b596c08141c7bd573ecfff56a1f7229e4d09\u0026#34; }, { \u0026#34;slot\u0026#34;: 23068793, \u0026#34;hash\u0026#34;: \u0026#34;69c44ac1dda2ec74646e4223bc804d9126f719b1c245dadc2ad65e8de1b276d7\u0026#34; }, \u0026#34;origin\u0026#34; ] } } If an intersection is found, great, the node will set the cursor to that point and let you know. If not, the cursor will remain where it was and the failure will also be broadcast. As we\u0026rsquo;ve seen in the previous section, a node may switch to longer forks based quite arbitrarily. Hence, a good list of intersections candidates is preferably dense near the tip of the chain, and goes far back in the past (k is typically not enough).\nFor example, imagine the following scenario:\n Local chain: [P01,P02,P03,..,P98,P99A,P100A] Node\u0026rsquo;s chain: [P01,P02,P03,..,P98,P99B,P100B]  As a client, providing any point before or at P98 will result in finding an intersection. Yet, if one only provides [P99A, P100A], the node will not be able to figure out where to continue the protocol and will remain at the origin.\nThe order of the list matters! The node will intersect with the best match, considering that the preferred points are first in the list. If one provides origin as a first point, an intersection is guaranteed to always find a match, and always at origin (and that is quite useless!).\n Points of interest For several applications, it may be quite useful to know the last point of each era; This allows to start syncing blocks from the beginning of a particular era. For instance, after seeking an intersection with the last point of the Shelley, nextBlock would yield the first block of the Allegra era. Handy!\nMainnet Preview Preprod     Era Bound Block Number Absolute Slot Number Block Header Hash     Last Byron block 4490510  4492799 f8084c61b6a238acec985b59310b6ecec49c0ab8352249afd7268da5cff2a457   Last Shelley block 5086523  16588737 4e9bbbb67e3ae262133d94c3da5bffce7b1127fc436e7433b87668dba34c354a   Last Allegra block 5406746  23068793 69c44ac1dda2ec74646e4223bc804d9126f719b1c245dadc2ad65e8de1b276d7   Last Mary block 6236059  39916796 e72579ff89dc9ed325b723a33624b596c08141c7bd573ecfff56a1f7229e4d09   Last Alonzo block 7791698  72316796 c58a24ba8203e7629422a24d9dc68ce2ed495420bf40d9dab124373655161a20   Last Babbage block N/A N/A N/A        Era Bound Block Number Absolute Slot Number Block Header Hash     Last Byron block N/A N/A N/A   Last Shelley block N/A N/A N/A   Last Allegra block N/A N/A N/A   Last Mary block N/A N/A N/A   Last Alonzo block 13011  259180 0ad91d3bbe350b1cfa05b13dba5263c47c5eca4f97b3a3105eba96416785a487   Last Babbage block N/A N/A N/A        Era Bound Block Number Absolute Slot Number Block Header Hash     Last Byron block 45  84242 45899e8002b27df291e09188bfe3aeb5397ac03546a7d0ead93aa2500860f1af   Last Shelley block 21644  518360 f9d8b6c77fedd60c3caf5de0ce63a0aeb9d1753269c9c07503d9aa09d5144481   Last Allegra block 43242  950340 74c03af754bcde9cd242c5a168689edcab1756a3f7ae4d5dca1a31d86839c7b1   Last Mary block 64902  1382348 af5fddc7d16a349e1a2af8ba89f4f5d3273955a13095b3709ef6e3db576a0b33   Last Alonzo block 172497  3542390 f93e682d5b91a94d8660e748aef229c19cb285bfb9830db48941d6a78183d81f   Last Babbage block N/A N/A N/A       Remember also that \u0026quot;origin\u0026quot; is a special point whichs refers to the beginning of the blockchain; An intersection with \u0026quot;origin\u0026quot; will always be found.\n Full example Let\u0026rsquo;s see a full example that is synchronizing the first 14 blocks of the Shelley chain and printing them to the console.\nconst WebSocket = require(\u0026#39;ws\u0026#39;); const client = new WebSocket(\u0026#34;ws://localhost:1337\u0026#34;); function rpc(method, params, id) { client.send(JSON.stringify({ jsonrpc: \u0026#34;2.0\u0026#34;, method, params, id })); } client.once(\u0026#39;open\u0026#39;, () =\u0026gt; { const lastByronBlock = { slot: 4492799, hash: \u0026#34;f8084c61b6a238acec985b59310b6ecec49c0ab8352249afd7268da5cff2a457\u0026#34; }; rpc(\u0026#34;findIntersection\u0026#34;, { points: [lastByronBlock] }, \u0026#34;find-intersection\u0026#34;); }); client.on(\u0026#39;message\u0026#39;, function(msg) { const response = JSON.parse(msg); switch (response.id) { case \u0026#34;find-intersection\u0026#34;: if (!response.result.intersection) { throw \u0026#34;Whoops? Last Byron block disappeared?\u0026#34; } rpc(\u0026#34;nextBlock\u0026#34;, {}, 14); break; default: if (response.result.direction === \u0026#34;forward\u0026#34;) { console.log(response.result); } if (response.id \u0026gt; 0) { rpc(\u0026#34;nextBlock\u0026#34;, {}, response.id - 1); } else { client.close(); } break; } }); A few important takes from this excerpt:\n  The node streams blocks that are after the intersection point. Thus to get the first 14 Shelley blocks, one needs to set the intersection at the last Byron block!\n  After successfully finding an intersection, the node will always ask to roll backward to that intersection point. This is because it is possible to provide many points when looking for an intersection and the protocol makes sure that both the node and the client are in sync. This allows clients applications to be somewhat \u0026ldquo;dumb\u0026rdquo; and blindly follow instructions from the node.\n  In this schema, we are sending each request one-by-one, using the id field as counter. An alternative could have been:\nswitch (response.id) { case \u0026#34;find-intersection\u0026#34;: if (!response.result.intersection) { throw \u0026#34;Whoops? Last Byron block disappeared?\u0026#34; } for (let i = 14; i \u0026gt; 0; i += 1) { rpc(\u0026#34;nextBlock\u0026#34;); } break; ... } We need not to wait for replies to send requests and can collect all responses at a later stage!\n  "},{"uri":"https://ogmios.dev/getting-started/docker/","title":"Docker","tags":[],"description":"","content":"üê≥ Overview The easiest way to get started with Ogmios is to use docker. This guide won\u0026rsquo;t cover installing docker, so make sure you have the Docker daemon installed and running.\nOgmios docker images come in two flavours: cardano-node-ogmios and ogmios. The former is used to run a single container that bundles both a Cardano-node and an Ogmios server running side-by-side. It is likely the easiest way to get started. The latter is a standalone Ogmios server, and you\u0026rsquo;ll need to run that container in orchestration with a cardano-node; this is made relatively easy with Docker compose.\nImages are uploaded to Dockerhub and are tagged using release versions combined with the supported network name, or with :latest if you\u0026rsquo;re living on the edge. If using the mainnet image you can omit the network name.\n   image repository tags     cardano-node-ogmios cardanosolutions/cardano-node-ogmios latestlatest-{NETWORK}v*.*.*_{CARDANO_NODE_VERSION}v*.*.*_{CARDANO_NODE_VERSION}-{NETWORK}   ogmios cardanosolutions/ogmios latestlatest-{NETWORK}v*.*.*v*.*.*-{NETWORK}    Supported NETWORK names:\n mainnet preview preprod  cardano-node-ogmios (easiest) Running Assuming you\u0026rsquo;ve pulled or build the image (otherwise, see below), you can start a cardano-node with an ogmios server in one single command:\n$ docker run -it \\ --name cardano-node-ogmios \\ -p 1337:1337 \\ -v cardano-node-ogmios-mainnet-db:/db \\ cardanosolutions/cardano-node-ogmios:latest Let\u0026rsquo;s explore a bit the various options:\n  -it is a shorthand for two options -i \u0026amp; -t to enable some interactive support with the container. This is necessary to pass OS signals (e.g. SIGINT from CTRL-C) from the host to the container.\n  --name gives a name to the container, to easily identify it later in commands such as docker container ps.\n  -p instruments docker to bind ports of the container to host. The image exposes 4 ports that can be bound to any (available) port of the host system. Here\u0026rsquo;s the complete list of TCP ports exposed by the image:\n   Port Number Description     1337 Ogmios port, for both the WebSocket and the HTTP server.   3000 cardano-node\u0026rsquo;s relay port   12788 cardano-node\u0026rsquo;s EKG port   12798 cardano-node\u0026rsquo;s Prometheus port      -v mounts a shared volume with the container on your host machine, either via bind mounts or named volumes.\n   Mount Point Description     db Persist the cardano-node\u0026rsquo;s database to avoid re-syncing the chain whenever a new container is run. This is done on every version upgrade and is recommended for most use-cases. Make sure to use different names for different networks as the data aren\u0026rsquo;t compatible between them!   ipc Bind /ipc to get access to the cardano-node\u0026rsquo;s local socket if you use the image in a multi-container stack with an external Haskell client.      Find more about run options in the docker user documentation.\nBuilding To build the image yourself, we encourage you to leverage the existing build-cache layers from the registry. Building the entire image from scratch can take up to an hour! You can\n$ docker buildx build \\ --cache-from cardanosolutions/cardano-node-ogmios:latest \\ --tag cardanosolutions/cardano-node-ogmios:latest \\ https://github.com/cardanosolutions/ogmios.git Optionally specify a network name, other than mainnet, using a build argument:\n--build-arg NETWORK=preview  Note that you can explicitly specify the target build when building the multi-stage docker image using --target cardano-node-ogmios. This is the default behaviour.\n Ogmios standalone (more advanced) Running (bare hands) Assuming that you have a cardano-node running, with its domain socket (node.socket) available under ./ipc, you may start a standalone Ogmios container as follows:\n$ docker run --rm \\ --name ogmios \\ -p 1337:1337 \\ -v ./ipc:/ipc \\ cardanosolutions/ogmios:latest \\ --node-socket /ipc/node.socket \\ --node-config /config/cardano-node/config.json \\ --host 0.0.0.0 Note that the --host argument is necessary to bind the server from within the container. Notice also how configuration files are available from within the image under /config.\nRunning (docker-compose) Alternatively, you may use Docker\u0026rsquo;s compose to run either Ogmios standalone, or an orchestration of cardano-node and Ogmios talking to each other. Compose is a handy tool to orchestrate multiple services packaged as containers. It works from a compose file which is available in the project repository, get it via:\n$ git clone --depth 1 git@github.com:cardanosolutions/ogmios.git $ cd cardano-ogmios Then, starts the components stack using:\n$ docker-compose up üëÜThis will run and connect:\n A Cardano node, connected to mainnet. An Ogmios server using the latest Dockerhub build, listening to localhost on port: 1337.  Once finish, tear the stack down using:\n$ docker-compose down Configuration The compose file allows for minimal (albeit useful) configuration parameters via environment variables:\n   Variable Description Values Default     NETWORK Which Cardano network to connect to. This impacts both Ogmios and the underlying Cardano node. mainnet, preview, preprod mainnet   OGMIOS_PORT Which ports to listen to (both for WebSockets and health endpoints) Any valid port number. 1337    Ogmios doesn\u0026rsquo;t use any form of persistent storage, but cardano-node does. The mainnet, preview and preprod databases are not compatible, so it is recommended to instrument docker-compose to use different namespaces for different networks (so that you can switch from one another without risking any database conflicts). Compose can do this easily by passing an extra flag: --project-name.\n For example, for running cardano-node + ogmios on the preprod network, listening to tcp/1338, do:\n$ NETWORK=preprod OGMIOS_PORT=1338 docker-compose --project-name cardano-ogmios-preprod up Building To build the Ogmios image from sources, pass the --build flag to compose. This is useful if you need a different version than the latest one available on Dockerhub. Alternatively, you can resort to building the image directly from the Dockerfile. Note that the same Dockerfile is used to produced both the ogmios image and the cardano-node-ogmios image using multi-stage docker builds. To build only the ogmios image, you\u0026rsquo;ll have to explicitly specify the build target using the --target ogmios option. So in brief:\n$ docker buildx build \\ --cache-from cardanosolutions/ogmios:latest \\ --tag cardanosolutions/ogmios:latest \\ --target ogmios \\ https://github.com/cardanosolutions/ogmios.git "},{"uri":"https://ogmios.dev/getting-started/building/","title":"Building","tags":[],"description":"","content":" You may skip this section if you\u0026rsquo;re using Docker üê≥.\n Pre-requisites (Server) Ogmios is built using the great Haskell build tool cabal. You\u0026rsquo;ll also need git to clone the source code, that is:\n git 2.11.* cabal 3.6.*.* and higher  Ogmios in itself is a rather small project, yet it\u0026rsquo;s using library directly from the ouroboros-network, cardano-ledger-specs and cardano-node projects. This is handy for re-using existing logic, but comes at the cost of several system dependencies that are required for building everything. Some may already be installed on your system, but the complete list is:\n libsodium-dev 1.0.* libgmp-dev 6.1.* libssl-dev 1.1.* libpcre3-dev 2.8.* libsystemd-dev zlib1g-dev 1.2.* A custom revision of bitcoin-core\u0026rsquo;s secp256k1, with Schnorr signature support enabled: git clone https://github.com/bitcoin-core/secp256k1.git cd secp256k1 git reset --hard ac83be33d0956faf6b7f61a60ab524ef7d6a473a ./autogen.sh ./configure --prefix=/usr --enable-module-schnorrsig --enable-experimental make make check sudo make install   üî® Server Clone the git repository from Github:\n$ git clone --depth 1 --recursive --shallow-submodules git@github.com:cardanosolutions/ogmios.git $ cd cardano-ogmios/server Then, use cabal to compile the project source code from the server directory:\n$ cabal build all The first time, this may take a while as cabal needs to setup a compilation environment and to download a lot of dependencies. Subsequent executions are much faster.\nFrom there, you can run Ogmios via cabal using the run command:\n$ cabal run ogmios:exe:ogmios -- --help Alternatively, you can instrument cabal to copy the compiled executable elsewhere so that you can run Ogmios all by itself:\n$ cabal install ogmios:exe:ogmios --install-method=copy --overwrite-policy=always $ ogmios --help üî® TypeScript Client Clone the git repository from Github:\n$ git clone --depth 1 --recursive --shallow-submodules git@github.com:cardanosolutions/ogmios.git $ cd cardano-ogmios/clients/TypeScript Then, use Yarn to install dependencies and compile the project source code from the client/TypeScript directory:\n$ yarn install \\ \u0026amp;\u0026amp; yarn build üìö Documentation The documentation can be generated from the TypeScript client workbench. Follow the instruction in the README to setup the TypeScript workspace, and then run:\n$ yarn docs This will generate documentation for the API and the TypeScript clients in /docs/static to be served by the static website generator Hugo.\nAlternatively, you can also look at our User-Guide Github Workflow to see how its done.\n"},{"uri":"https://ogmios.dev/mini-protocols/local-state-query/","title":"Ledger state queries","tags":[],"description":"","content":"queryLedgerState/* START queryNetwork/* ‚áì ‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ releaseLedgerState ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îê ‚îÇ ‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ Idle ‚îÇ‚óÄ‚îÄ‚îÄ‚ïØ ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚îÇ ‚îÇ ‚îÇ acquireLedgerState ‚îÇ ‚îÇ ‚îÇ ‚îÇ (re)acquireLedgerState ‚îÇ ‚ñº ‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ Acquired ‚îÇ‚óÄ‚îÄ‚îÄ‚ïØ ‚îî‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚ñ≤ queryLedgerState/* ‚îÇ ‚îÇ queryNetwork/* ‚îÇ ‚îÇ ‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ   Overview The state query protocol is likely the most versatile of the three Ouroboros mini-protocols. As a matter of fact, it allows for querying various types of information directly from the ledger. In essence, it is like a very simpler request/response pattern where the types of questions one can ask are specified by the protocols. Those questions include: information about the chain tip, information about stake pools but also the balance of a particular address.\nIn order to run a question by the ledger, one must first acquire a particular position on the chain, so that the node can reliably answer a few questions on a chosen, frozen state while continuing maintaining more recent version of the ledger on the side. It is important to note that:\n  The node cannot acquire any arbitrary state. One can only rewind up to a certain point.\n  Should a client keep a state acquired for too long, it is likely to become unreachable at some point, forcing clients to re-acquire.\n  How to use Ogmios uses a simplified version of the above state-machine. Or more exactly, it exposes a simplified version and handles some of the complexity behind the scene for you. As clients, Ogmios will give you method to acquire a state, query that state and release the state. A typical sequence would be to start by acquiring a state on a given point and then make a few queries, and then release. The release step is optional although it is a bit more polite to say goodbye at the end of a conversation.\nIt is also possible to submit queries directly without acquiring. As a consequence, Ogmios will acquire the tip of the chain, run the query and release it for you. This is the easiest way to send queries if you don\u0026rsquo;t care about capturing a particular state. Note however that this may create race conditions if you send multiple queries via this method. Indeed, the tip is changing quite often on the network, and two subsequent queries may actually run on two different points of the chain. While this is generally safe for most queries, it may also put your application in an unexpected state when crossing epoch boundaries or hard-forks.\nAcquiring a state The acquireLedgerState method expects one argument named point. The point has the same format as points in the chain synchronization protocol. That is, they can be block header hashes or the special keyword \u0026quot;origin\u0026quot; (though there\u0026rsquo;s very little chance that one will be able to acquire the origin!).\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;acquireLedgerState\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;point\u0026#34;: { \u0026#34;slot\u0026#34;: 1234, \u0026#34;hash\u0026#34;: \u0026#34;9e871633f7aa356ef11cdcabb6fdd6d8f4b00bc919c57aed71a91af8f86df590\u0026#34; } } } One thing that doesn\u0026rsquo;t strike as obvious is that, as clients, you need points to query any information. There are many ways to get those hashes but in the context of Ogmios, the most logical way is via the chain synchronization protocol.\nYou can acquire multiple times, the last one will prevail. If you need to re-acquire, simply send another acquire request.\n You can skip acquiring a state should you want to run a query on the current state of the chain. This is good for one-off queries, but if you need to chain multiple queries together it is highly recommended to acquire a state first to preserve data-consistency between queries!\n Querying There are many queries that can be sent to the ledger, and the list is growing days after days as the Cardano team implements new ones. With Ogmios, all queries follow the same pattern and are identified by a method. There exists two types of queries: ledger-state queries and network queries. The former is performed on the ledger state and are era-dependent. The latter are always available (even when the node is synchronizing) and are era-independent. In both cases, queries are constructed in a similar fashion:\n queryLedgerState/*, where * has to be replaced with an actual ledger-state query name (see below); queryNetwork/*, where * has to be replaced with an actual network query name (see below)  For example, to query the ongoing epoch of the ledger:\n{ \u0026quot;jsonrpc\u0026quot;: \u0026quot;2.0\u0026quot;, \u0026quot;method\u0026quot;: \u0026quot;queryLedgerState/epoch\u0026quot;, } Network At the moment of writing this guide, the following queries are available:\n   queryNetwork Information     blockHeight The chain\u0026rsquo;s highest block number.   genesisConfiguration Get the genesis configuration of a specific era.   startTime The chain\u0026rsquo;s start time (UTC).   tip The network\u0026rsquo;s current tip.    Ledger-state    queryLedgerState Information     epoch The current epoch of the ledger.   eraStart The information regarding the beginning of the current ledger era.   eraSummaries Era bounds and slot parameters details, required for proper slotting arithmetic.   liveStakeDistribution Distribution of the stake across all known stake pools, relative to the total stake in the network.   projectedRewards The projected rewards of an account in a context where the top stake pools are fully saturated. This projection gives, in principle, a ranking of stake pools that maximizes delegator rewards.   protocolParameters The current protocol parameters.   proposedProtocolParameters The last update proposal w.r.t. protocol parameters, if any.   rewardAccountSummaries Current delegation settings and rewards of chosen reward accounts.   rewardsProvenance Get details about rewards calculation for the ongoing epoch.   stakePools The list of all pool identifiers currently registered and active.   stakePoolParameters Stake pool parameters submitted with registration certificates.   tip The current tip the ledger is at. Said differently, the slot number and header hash of the last block that has been processed by the ledger.   utxo Current UTXO, possibly filtered by output reference.    To know more about arguments and results of each query, have a look at the API reference.\n Simplified example In this example, we\u0026rsquo;ll consider a simple direct query on the network tip to fetch the latest protocol parameters. The next section gives a more elaborate example which shows how to acquire a specific point on chain.\nconst WebSocket = require(\u0026#39;ws\u0026#39;); const client = new WebSocket(\u0026#34;ws://localhost:1337\u0026#34;); function rpc(method, params = {}, id) { client.send(JSON.stringify({ jsonrpc: \u0026#34;2.0\u0026#34;, method, params, id })); } client.once(\u0026#39;open\u0026#39;, () =\u0026gt; { rpc(\u0026#34;queryLedgerState/protocolParameters\u0026#34;); }); client.on(\u0026#39;message\u0026#39;, function(msg) { const response = JSON.parse(msg); console.log(JSON.stringify(response.result.protocolParameters, null, 4)); client.close(); }); This little excerpt outputs the most recent protocol parameters in a nice JSON:\n{ \u0026#34;poolDeposit\u0026#34;: 500000000, \u0026#34;protocolVersion\u0026#34;: { \u0026#34;minor\u0026#34;: 0, \u0026#34;major\u0026#34;: 3 }, \u0026#34;minUtxoValue\u0026#34;: 1000000, \u0026#34;minFeeConstant\u0026#34;: 155381, \u0026#34;maxTxSize\u0026#34;: 16384, \u0026#34;minPoolCost\u0026#34;: 340000000, \u0026#34;maxBlockBodySize\u0026#34;: 65536, \u0026#34;extraEntropy\u0026#34;: \u0026#34;neutral\u0026#34;, \u0026#34;minFeeCoefficient\u0026#34;: 44, \u0026#34;poolInfluence\u0026#34;: \u0026#34;3/10\u0026#34;, \u0026#34;maxBlockHeaderSize\u0026#34;: 1100, \u0026#34;stakeKeyDeposit\u0026#34;: 2000000, \u0026#34;decentralizationParameter\u0026#34;: \u0026#34;1/5\u0026#34;, \u0026#34;desiredNumberOfPools\u0026#34;: 500, \u0026#34;poolRetirementEpochBound\u0026#34;: 18, \u0026#34;monetaryExpansion\u0026#34;: \u0026#34;3/1000\u0026#34;, \u0026#34;treasuryExpansion\u0026#34;: \u0026#34;1/5\u0026#34; } Full example Let\u0026rsquo;s see a full example getting the stake distribution of all stake pools of the Cardano mainnet. In the example, we\u0026rsquo;ll also use a network query to find the current chain tip, and then try to acquire it for subsequent queries.\nconst WebSocket = require(\u0026#39;ws\u0026#39;); const client = new WebSocket(\u0026#34;ws://localhost:1337\u0026#34;); function rpc(method, params = {}, id) { client.send(JSON.stringify({ jsonrpc: \u0026#34;2.0\u0026#34;, method, params, id })); } client.once(\u0026#39;open\u0026#39;, () =\u0026gt; { rpc(\u0026#34;queryNetwork/tip\u0026#34;, {}, \u0026#34;get-network-tip\u0026#34;) }); client.on(\u0026#39;message\u0026#39;, function(msg) { const response = JSON.parse(msg); switch (response.id) { case \u0026#34;get-network-tip\u0026#34;: const point = response.result.tip; rpc(\u0026#34;acquireLedgerState\u0026#34;, { point }, \u0026#34;acquire-network-tip\u0026#34;); break; case \u0026#34;acquire-network-tip\u0026#34;: rpc(\u0026#34;queryLedgerState/liveStakeDistribution\u0026#34;); break; default: console.log(response.result.liveStakeDistribution); client.close(); break; } }); Here\u0026rsquo;s a walk-though describing what happens when running the above script:\n  An initial request ask the network tip. That is guaranteed to succeed and is a little trick in order to access the ledger tip easily. As a response, Ogmios replies with:\n  Got network tip   { \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;tip\u0026#34;: { \u0026#34;hash\u0026#34;: \u0026#34;dbafebb0146b2ec45186dfba6c287ad69c83d3fd9a186b39d99ab955631539e0\u0026#34;, \u0026#34;slot\u0026#34;: 12526684 } }, \u0026#34;id\u0026#34;: \u0026#34;get-network-tip\u0026#34; }      Using the tip from the previous response, we can now safely aquire a state on that particular tip which we know exists and is not too old. Ogmios replies successfully with:\n  Acquired ledger state   { \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;acquired\u0026#34;: \u0026#34;ledgerState\u0026#34;, \u0026#34;point\u0026#34;: { \u0026#34;hash\u0026#34;: \u0026#34;dbafebb0146b2ec45186dfba6c287ad69c83d3fd9a186b39d99ab955631539e0\u0026#34;, \u0026#34;slot\u0026#34;: 12526684 } }, \u0026#34;id\u0026#34;: \u0026#34;acquire-network-tip\u0026#34; }      Now in a position to make an actual query, we do it and ask for the stake distribution across all stake pools. The (truncated) response from the server looks like:\n  Query response   { \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;liveStakeDistribution\u0026#34;: { \u0026#34;pool1w3s6gk83y2g3670emy3yfjw9myz3u4whph7peah653rmsfegyj3\u0026#34;: { \u0026#34;stake\u0026#34;: 0, \u0026#34;vrf\u0026#34;: \u0026#34;29c1a293c550beea756bc0c01416bacd7030ae8992e13ca242d4d6c2aebaac0d\u0026#34; }, \u0026#34;pool1n5shd9xdt4s2gm27fxcnuejaqhhmpepn6chw2c82kqnuzdtpsem\u0026#34;: { \u0026#34;stake\u0026#34;: 0.00003058882418046271, \u0026#34;vrf\u0026#34;: \u0026#34;7e363eb8bfd8fef018da4c397d6a6ec25998363434e92276e40ee6c706da3ae5\u0026#34; }, \u0026#34;...\u0026#34; } } }      Be aware that it is possible for an acquire request to fail even if (and in particular if) made immediately after finding the ledger tip. In Ouroboros Praos frequent small rollbacks of the chain are not rare and the few last blocks of the chain can be a bit volatile. A real application may require more elaborate error handling than the toy example above.\n Example queries Network blockHeight { \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;queryNetwork/blockHeight\u0026#34; } genesisConfiguration { \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;queryNetwork/genesisConfiguration\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;era\u0026#34;: \u0026#34;shelley\u0026#34; } } { \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;queryNetwork/genesisConfiguration\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;era\u0026#34;: \u0026#34;alonzo\u0026#34; } } startTime { \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;queryNetwork/startTime\u0026#34; } tip { \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;queryNetwork/tip\u0026#34; } Ledger-state epoch { \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;queryLedgerState/epoch\u0026#34; } eraStart { \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;queryLedgerState/eraStart\u0026#34; } eraSummaries { \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;queryLedgerState/eraSummaries\u0026#34; } liveStakeDistribution { \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;queryLedgerState/liveStakeDistribution\u0026#34; } projectedRewards { \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;queryLedgerState/projectedRewards\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;stake\u0026#34;: [ 1000000 ] } } { \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;queryLedgerState/projectedRewards\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;keys\u0026#34;: [ \u0026#34;7c16240714ea0e12b41a914f2945784ac494bb19573f0ca61a08afa8\u0026#34;, \u0026#34;stake_vkh10stzgpc5ag8p9dq6j98jj3tcftzffwce2ulsefs6pzh6s39tk6l\u0026#34; ] } } { \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;queryLedgerState/projectedRewards\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;scripts\u0026#34;: [ \u0026#34;7c16240714ea0e12b41a914f2945784ac494bb19573f0ca61a08afa8\u0026#34;, \u0026#34;script10stzgpc5ag8p9dq6j98jj3tcftzffwce2ulsefs6pzh6snywdma\u0026#34; ] } } protocolParameters { \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;queryLedgerState/protocolParameters\u0026#34; } currentProtocolParameters { \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;queryLedgerState/currentProtocolParameters\u0026#34; } rewardAccountSummaries { \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;queryLedgerState/rewardAccountSummaries\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;keys\u0026#34;: [ \u0026#34;7c16240714ea0e12b41a914f2945784ac494bb19573f0ca61a08afa8\u0026#34;, \u0026#34;stake_vkh10stzgpc5ag8p9dq6j98jj3tcftzffwce2ulsefs6pzh6s39tk6l\u0026#34; ] } } { \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;queryLedgerState/rewardAccountSummaries\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;scripts\u0026#34;: [ \u0026#34;7c16240714ea0e12b41a914f2945784ac494bb19573f0ca61a08afa8\u0026#34;, \u0026#34;script10stzgpc5ag8p9dq6j98jj3tcftzffwce2ulsefs6pzh6snywdma\u0026#34; ] } } rewardsProvenance { \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;queryLedgerState/rewardsProvenance\u0026#34; } stakePools { \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;queryLedgerState/stakePools\u0026#34; } stakePoolParameters { \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;queryLedgerState/stakePoolParameters\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;stakePools\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;pool1pk2wzarn9mu64eel89dtg3g8h75c84jsy0q349glpsewgd7sdls\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;4acf2773917c7b547c576a7ff110d2ba5733c1f1ca9cdc659aea3a56\u0026#34; } ] } } tip { \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;queryLedgerState/tip\u0026#34; } utxo { \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;queryLedgerState/utxo\u0026#34; } { \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;queryLedgerState/utxo\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;outputReferences\u0026#34;: [ { \u0026#34;transaction\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;ee155ace9c40292074cb6aff8c9ccdd273c81648ff1149ef36bcea6ebb8a3e25\u0026#34; }, \u0026#34;output\u0026#34;: { \u0026#34;index\u0026#34;: 2 } } ] } } "},{"uri":"https://ogmios.dev/mini-protocols/","title":"Mini-Protocols","tags":[],"description":"","content":"Mini-Protocols In this section, we\u0026rsquo;ll give practical insights about interacting with the Ouroboros mini-protocols. Each sub-section will focus on one particular protocol, give an overview and give examples in JavaScript using Ogmios.\n"},{"uri":"https://ogmios.dev/clients/","title":"Clients","tags":[],"description":"","content":"Clients There exists a variety of clients for Ogmios. Initially, the TypeScript client was developed alongside the server as a proof-of-concept. Over time, amazing community members have developed new clients in their favorite languages:\n TypeScript Go Kotlin Java  In this manual, we cover some usage of the TypeScript client. For other clients, please refer to their respective projects and maintainers.\n"},{"uri":"https://ogmios.dev/getting-started/testing/","title":"Testing","tags":[],"description":"","content":" You may skip this section if you\u0026rsquo;re not interested in contributing to Ogmios.\n üîß Unit Tests First, make sure to pull and update git submodules:\n$ git submodule update --init Then, simply use cabal as follows:\n$ cabal test all üí® Smoke Tests Run the whole components stack using docker-compose as follows:\n$ docker-compose up Assuming the default configuration, Ogmios should be listening on :1337. Make sure that cardano-node is up-and-running and has finished its bootstraping phase (Ogmios should no longer print any warnings about HealthFailedToConnect). Then, open your favorite browser and visit http://localhost:1337/tests.html.\nTo tear down, press CTRL+C and then run:\n$ docker-compose down "},{"uri":"https://ogmios.dev/mini-protocols/local-tx-submission/","title":"Transaction submission","tags":[],"description":"","content":"submitTransaction ‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ START ‚îÇ ‚îÇ ‚áì ‚îÇ ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ Idle ‚îÇ‚óÄ‚îÄ‚îÄ‚îÄ‚ïØ ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚ñ≤ ‚îÇ ‚îÇ ‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ evaluateTransaction   Overview Transaction submission is pretty simple \u0026amp; works by submitting an already serialized and signed transaction as one single message.\nIn case of success, Ogmios / the node returns an empty response. Otherwise, it returns an error with some details about what went wrong. Clients must thereby know how to construct valid transactions.\nDisclaimer The transaction submission protocol is the simplest one in appearance. It nevertheless requires a quite extensive knowledge of the on-chain data-types used by Cardano. Indeed, the protocol in itself is straightforward so long as you already know how to produce and sign a transaction.\nThis guide doesn\u0026rsquo;t cover the creation and serialization of Cardano transactions. This is a rather vast topic and there is a handful of tools out there to help on the matter already, in particular:\n  Lucid, a TypeScript / Deno package for building transaction and managing credentials. It has direct integration into Ogmios.\n  Mesh.js, a JavaScript library providing numerous tools to easily build powerful dApps on the Cardano blockchain.\n  cardano-cli which offers another command-line interface for constructing and signing transactions.\n  In any case, one can always refer to the source CDDL specifications to know how to construct and serialize Cardano transactions.\nProviding a more user-friendly interface with regards to transactions in Ogmios is still under consideration. Yet, since in order to handle and sign transactions, one needs some knowledge about the on-chain binary format anyway, I\u0026rsquo;ve made the (effortless) choice to only treat with already serialized blobs in Ogmios. I am open to suggestions about how this could be made better, drop me a message on Github if you have ideas!\n Submitting transactions Sending a transaction through the Cardano network requires one message using the method SubmitTx, and with a single mandatory arguments with bytes, representing a serialized signed transactions with its full witness.\nNote that JSON does not support embedding raw bytes in objects. Bytes needs therefore to be base16-encoded.\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;submitTransaction\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;transaction\u0026#34;: { \u0026#34;cbor\u0026#34;: { \u0026#34;\u0026lt;base16\u0026gt;\u0026#34; } } } } The response will indicate either a success or a failure. In case of failure, Ogmios will return a list of failures reported by the underlying node. Note that, if the transaction fails to parse, Ogmios will reply with a generic error.\nTransactions in Cardano are rather complicated and there are a lot of possible validation errors that can be returned. Be sure to have a look at the API reference for an exhaustive list.\nEvaluating transactions Starting from 5.2.0, Ogmios supports a modified version of the transaction submission protocol that allows to evaluate the execution units of scripts present in a given transaction, without actually submitting the transaction. This is useful for DApp developers who wants a quick-and-easy way to measure script execution costs.\nThe API is purposely similar to the submitTransaction method, with a few semantic changes:\n The transaction needs not to be fully authenticated. Key witnesses may be omitted unless they are relevant to the evaluation of scripts themselves! The transaction needs not to be balanced; indeed, the evaluation does not perform a full execution of all the ledger rules. So while the transaction must be well-formed, it may be invalid with regards to phase-1 validations. Execution budgets assigned to redeemers are expected to be set to zero since the goal of this endpoint is to figure out these very execution budgets.  From there, the endpoint works similarly to the submission:\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;evaluateTransaction\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;transaction\u0026#34;: { \u0026#34;cbor\u0026#34;: \u0026#34;\u0026lt;base16\u0026gt;\u0026#34; } } } Successful responses include a map of redeemer pointers with the corresponding execution units. A redeemer pointer is a key composed of two parts: a redeemer entity tag and a 0-based index related to that entity. There exists 4 kinds of redeemer entities: spend (for transaction inputs), certificate (for transaction certificates), mint (for transaction monetary policies) and withdrawal (for transaction\u0026rsquo;s rewards withdrawals). The index therefore refers to the position of the script-locked entity within the set of entities in the transaction.\nFor example spend:0 points to the first transaction input; mint:2 would point to the 3rd policy referenced in the minting map\u0026hellip; and so forth. Here below is a JSON example of an evaluation result:\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;budgets\u0026#34;: { \u0026#34;spend:0\u0026#34;: { \u0026#34;memory\u0026#34;: 1700, \u0026#34;cpu\u0026#34;: 476468 } } } } See the full API reference for details about possible errors returned from this endpoint.\nIf you\u0026rsquo;re using typed Plutus validators (if you don\u0026rsquo;t know what that is, then it is most likely what you\u0026rsquo;re using), keep in mind that adding or removing elements to and off your transaction will change its execution cost. Indeed, the creation of the script context passed down to on-chain validators is done as part of the on-chain validator execution. Thus, larger contexts require more execution units!  This is the case for instance when you add a change output to a transaction or, a script integrity hash. A generally good way to approach this problem is to either: 1. make sure that the transaction you evaluate is as close as possible to the final transaction; that is, create dummy change outputs and script integrity hash before evaluating and fill-in their actual value once evaluated;2. keep some safe margin from the evaluated execution units; Execution units are relatively cheap on Cardano so, an extra 5 or 10% isn\u0026rsquo;t much and saves you in most cases a lot of hassle to cope with small differences.\n Additional UTXO Set In order to construct the validator script context, Ogmios needs to resolve transaction inputs from the Cardano blockchain. In case where a submitted transaction refers to non-existing inputs, the evaluation will fail with an UnknownInputs error. This can be an obstacle during development or, in scenarios where transactions are being prepared ahead of UTXO.\nIn such scenarios, Ogmios gives way to provide an additional UTXO set to be used during evaluation. Note that it will still try to resolve inputs that are known, but will use the provided UTXO set as a complement for those that are unknown or yet-to-know.\nThe structure of the additional UTXO set is the same as UTXO sets returned in other part of the Ogmios' API; that is, an array of [OutputReference, Output] tuples.\n For example:\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;evaluateTransaction\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;transaction\u0026#34;: { \u0026#34;cbor\u0026#34;: \u0026#34;\u0026lt;base16\u0026gt;\u0026#34;, }, \u0026#34;additionalUtxoSet\u0026#34;: [ [ { \u0026#34;transaction\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;97b2af6dfc6a4825e934146f424cdd6ede43ff98c355d2ae3aa95b0f70b63949\u0026#34; }, \u0026#34;output\u0026#34;: { \u0026#34;index\u0026#34;: 3 } }, { \u0026#34;address\u0026#34;: \u0026#34;addr_test1qp9zjnc775anpndl0jh3w7vyy25syfezf70d\u0026#34;, \u0026#34;value\u0026#34;: { \u0026#34;lovelace\u0026#34;: 10000000 } } ] ] } } Full Example For what it\u0026rsquo;s worth, here\u0026rsquo;s an example of a transaction submission to the Cardano mainnet via Ogmios. This transaction is using dummy data and will obviously fail. It is however structurally valid, so useful to test if an integration works correctly.\nconst WebSocket = require(\u0026#39;ws\u0026#39;); const client = new WebSocket(\u0026#34;ws://localhost:1337\u0026#34;); function rpc(method, params) { client.send(JSON.stringify({ jsonrpc: \u0026#34;2.0\u0026#34;, method, params })); } client.once(\u0026#39;open\u0026#39;, () =\u0026gt; { const cbor = \u0026#34;83a4008182582000000000000000000000000000000000000000000000000000\u0026#34;+ \u0026#34;0000000000000000018282583901010101010101010101010101010101010101\u0026#34;+ \u0026#34;0101010101010101010101010101010101010101010101010101010101010101\u0026#34;+ \u0026#34;0101010101011a001e8480825839010202020202020202020202020202020202\u0026#34;+ \u0026#34;0202020202020202020202020202020202020202020202020202020202020202\u0026#34;+ \u0026#34;020202020202021a0078175c021a0001faa403191e46a1008182582001000000\u0026#34;+ \u0026#34;000000000000000000000000000000000000000000000000000000005840d7af\u0026#34;+ \u0026#34;60ae33d2af351411c1445c79590526990bfa73cbb3732b54ef322daa142e6884\u0026#34;+ \u0026#34;023410f8be3c16e9bd52076f2bb36bf38dfe034a9f04658e9f56197ab80ff6\u0026#34;; rpc(\u0026#34;submitTransaction\u0026#34;, { transaction: { cbor } }); }); client.on(\u0026#39;message\u0026#39;, function(msg) { const response = JSON.parse(msg); console.log(response); client.close(); }); "},{"uri":"https://ogmios.dev/api/","title":"API Reference","tags":[],"description":"","content":""},{"uri":"https://ogmios.dev/mini-protocols/local-tx-monitor/","title":"Mempool monitoring","tags":[],"description":"","content":"START ‚áì releaseMempool ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ Idle ‚îÇ‚áí DONE ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚îÇ ‚îÇ ‚îÇ acquireMempool ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ (re)acquireMempool ‚îÇ ‚îÇ ‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ ‚îÇ ‚ñº ‚îÇ ‚îÇ ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ Acquired ‚îÇ‚óÄ‚îÄ‚îÄ‚ïØ ‚îî‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚ñ≤ nextTransaction ‚îÇ ‚îÇ hasTransaction ‚îÇ ‚îÇ sizeOfMempool ‚îÇ ‚îÇ ‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ   Overview To inspect the node\u0026rsquo;s local mempool, one may rely on the mempool monitoring mini-protocol. This protocol provides way to list all transactions sitting in the mempool, but also, to query the size of the mempool, the number of transactions currently in the mempool as well as the current capacity (based on network parameters).\nAs for the other mini-protocols, the mempool monitoring is a stateful protocol with explicit state acquisition driven by the client. That is, clients must first acquire a mempool snapshot for running queries over it. Once acquired, queries are guaranteed to be consistent. In particular, nextTransaction will never yield twice the same transaction for the same snapshot and sizeOfMempool will remain constant.\nacquireMempool is a blocking call. The server will only reply once a \u0026ldquo;new\u0026rdquo; snapshot is available. \u0026ldquo;New\u0026rdquo; means different from the currently acquired snapshot. Seemingly, the first acquireMempool is instantaneous. This allows for clients to passively wait for changes without active polling. A typical pattern of usage would be to acquire a snapshot, list all transactions from the mempool via nextTransaction and then, block on acquireMempool for a change; then repeat.\nHow To Use First, client must always acquire a snapshot and hold onto it for subsequent queries. To list all queries, one must call nextTransaction repeatedly until it yields null. So for instance, if the mempool currently contains three transactions t0, t1 and t2, one can list all transactions from the mempool via the following sequence (schematically):\n 1. acquireMempool ‚Üí acquireMempoolResponse 2. nextTransaction ‚Üí nextTransactionResponse t0 3. nextTransaction ‚Üí nextTransactionResponse t1 4. nextTransaction ‚Üí nextTransactionResponse t2 5. nextTransaction ‚Üí nextTransactionResponse null  Another option is simply to query for a specific transaction via hasTransaction, which yields True or False depending on whether the transaction is currently in the mempool or not.\n 1. acquireMempool ‚Üí acquireMempoolResponse 2. hasTransaction t0 ‚Üí hasTransactionResponse True 3. hasTransaction t1 ‚Üí hasTransactionResponse True 4. hasTransaction t5 ‚Üí hasTransactionResponse False  At any moment, it is also possible to interleave a sizeOfMempool query to get the acquired snapshot\u0026rsquo;s size (in bytes), number of transactions and capacity (in bytes).\nThe capacity refers to the maximum size of the mempool. It is currently defined as twice the network block size and can be adjusted via protocol updates.\n Retrieve Full Transactions Since 5.3.0, Ogmios can also return full transactions as a result of nextTransaction. This must be however explicitly requested from clients by providing an extra (optional) argument to each nextTransaction request:\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;nextTransaction\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;fields\u0026#34;: \u0026#34;all\u0026#34; } } \u0026quot;fields\u0026quot; accept only one value (\u0026quot;all\u0026quot;) and can be omitted. When present, the result from the response will contain a full transaction. When omitted, result will only contains a transaction id.\nImportant Notes Some important notes to keep in mind regarding the management of the mempool:\nAbout Transaction Locality This protocol gives access to transactions that are submitted locally, by the connected client via the transaction submission protocol. In case of block producing nodes (i.e. stake pools), transactions pulled from peers may also be available.\nAbout Transaction Observability The protocol does not guarantee observability of all transactions passing through the mempool. There\u0026rsquo;s an inherent race condition between the client acquiring snapshots and the node managing it internally. Thus, while a client is holding a snapshot, it may still submit transactions through the transaction submission protocol, which may be accepted, processed and included in the ledger before the client next\u0026rsquo;s acquireMempool. So, it is possible for clients to miss transactions passing through the mempool should they be concurrently submitting them.\nAbout Transaction Status Furthermore, while the presence of a transaction in the mempool qualifies it as pending, the absence of transactions in the mempool does not guarantee their inclusion in the ledger (transaction may be discarded from the mempool for various reasons). In particular, a valid transaction may leave the mempool to be included in a block which later result in a lost fork (e.g. because of a lost slot battle) and may never end up in the ledger. The node does not automatically re-insert transactions into the mempool.\nFull Example const WebSocket = require(\u0026#39;ws\u0026#39;); const client = new WebSocket(\u0026#34;ws://localhost:1337\u0026#34;); // Helper function function rpc(method, params) { client.send(JSON.stringify({ jsonrpc: \u0026#34;2.0\u0026#34;, method, params })); } client.on(\u0026#39;message\u0026#39;, e =\u0026gt; { const next = JSON.parse(e).result; if (next.transaction === null) { client.close(); } else { console.log(next.transaction); rpc(\u0026#34;nextTransaction\u0026#34;); } }); client.once(\u0026#39;open\u0026#39;, () =\u0026gt; { rpc(\u0026#34;acquireMempool\u0026#34;); }); API Reference The complete description of the mempool monitoring requests and responses can be found in the API reference.\nPlus, test vectors are available on the repository for testing, debugging and to serve as examples.\n"},{"uri":"https://ogmios.dev/getting-started/monitoring/","title":"Monitoring","tags":[],"description":"","content":"Dashboard Ogmios offers a simple dashboard through HTTP with a real-time visualization of some of the server runtime metrics. If you\u0026rsquo;ve Ogmios up-and-running on the default port, visit http://localhost:1337 to view Ogmios' dashboard.\nHealth / Metrics Behind the scene, the dashboard is powered by metrics served over HTTP as JSON by the server. Reach /health (e.g. http://localhost:1337/health to get real-time information about your running server, including runtime metrics.\n$ curl -H 'Accept: application/json' http://localhost:1337/health { \u0026#34;metrics\u0026#34;: { \u0026#34;totalUnrouted\u0026#34;: 1, \u0026#34;totalMessages\u0026#34;: 30029, \u0026#34;runtimeStats\u0026#34;: { \u0026#34;gcCpuTime\u0026#34;: 1233009354, \u0026#34;cpuTime\u0026#34;: 81064672549, \u0026#34;maxHeapSize\u0026#34;: 41630, \u0026#34;currentHeapSize\u0026#34;: 1014 }, \u0026#34;totalConnections\u0026#34;: 10, \u0026#34;sessionDurations\u0026#34;: { \u0026#34;max\u0026#34;: 57385, \u0026#34;mean\u0026#34;: 7057, \u0026#34;min\u0026#34;: 0 }, \u0026#34;activeConnections\u0026#34;: 0 }, \u0026#34;startTime\u0026#34;: \u0026#34;2021-03-15T16:16:41.470782977Z\u0026#34;, \u0026#34;lastTipUpdate\u0026#34;: \u0026#34;2021-03-15T16:28:36.853115034Z\u0026#34;, \u0026#34;lastKnownTip\u0026#34;: { \u0026#34;hash\u0026#34;: \u0026#34;c29428f386c701c1d1ba1fd259d4be78921ee9ee6c174eac898245ceb55e8061\u0026#34;, \u0026#34;blockNo\u0026#34;: 5034297, \u0026#34;slot\u0026#34;: 15520688 }, \u0026#34;networkSynchronization\u0026#34;: 0.99, \u0026#34;currentEra\u0026#34;: \u0026#34;Mary\u0026#34;, \u0026#34;connectionStatus\u0026#34;: \u0026#34;disconnected\u0026#34;, \u0026#34;currentEpoch\u0026#34;: 164, \u0026#34;slotInEpoch\u0026#34;: 324543 } All information are computed at runtime and not preserved between restarts (at least not yet). The health response includes:\n   field description     connectionStatus A string \u0026quot;connected\u0026quot; or \u0026quot;disconnected\u0026quot; indicating whether Ogmios' server is correctly communicating with its underlying node.   startTime UTC timestamp at which the server was started.   lastTipUpdate UTC timestamp when lastKnownTip was last updated (can be null)   lastKnownTip Last known chain tip received from the node (can be null)   networkSynchronization A (nullable) percentage indicator of how far the server/node is from the network tip. 1 means it is synchronized.   currentEra The (nullable) current Cardano era of the underlying node. Useful for state-queries and debugging.   currentEpoch The (nullable) current epoch number known of the underlying node.   slotInEpoch The (nullable) relative slot number within the current epoch.   metrics.activeConnections Number of WebSocket connections currently established with the server.   metrics.totalConnections Total number of WebSocket connections established with the server since it\u0026rsquo;s started.   metrics.sessionDurations Some time measures (min, max, mean) of the duration of each sessions, in milliseconds.   metrics.totalMessages Total number of messages received from all / any WebSocket connections.   metrics.totalUnrouted Total number of invalid messages not routed to one of the mini-protocols, received from all / any WebSocket connections.   metrics.runtimeStats.gcCpuTime Time spent by the garbage collector cleaning up previously allocated data objects, in nano-seconds.   metrics.runtimeStats.cpuTime Time spent by the CPU doing work (at the last GC), in nano-seconds.   metrics.runtimeStats.maxHeapSize Maximum live data allocated in the heap, in kilo-bytes.   metrics.runtimeStats.currentHeapSize Current live data allocated in the heap, in kilo-bytes.    All dates / timestamps are given as ISO-8601 date-time strings.\n Runtime metrics (i.e. runtimeStats) are only available when the server is started with the +T runtime flag. This is the case by default, but can be manually turned on and off using the +RTS / -RTS options. For example ogmios --node-socket /path/to/socket +RTS -T -RTS will run Ogmios with runtime stats activated.\n Prometheus Metrics Ogmios also provides Prometheus metrics directly at http://localhost:1337/metrics.\nThe Connected connection status is encoded as ogmios_connected 1 while disconnected as ogmios_connected 0.\n$ curl http://localhost:1337/metrics # TYPE ogmios_active_connections gauge ogmios_active_connections 0.0 # TYPE ogmios_connected gauge ogmios_connected 1.0 # TYPE ogmios_cpu_time counter ogmios_cpu_time 3841629783 # TYPE ogmios_current_epoch counter ogmios_current_epoch 363 # TYPE ogmios_current_heap_size gauge ogmios_current_heap_size 390.0 # TYPE ogmios_gc_cpu_time counter ogmios_gc_cpu_time 3142668337 # TYPE ogmios_max_heap_size gauge ogmios_max_heap_size 433.0 # TYPE ogmios_network_synchronization gauge ogmios_network_synchronization 0.99999 # TYPE ogmios_session_duration_max gauge ogmios_session_duration_max 0.0 # TYPE ogmios_session_duration_mean gauge ogmios_session_duration_mean 0.0 # TYPE ogmios_session_duration_min gauge ogmios_session_duration_min 0.0 # TYPE ogmios_slot_in_epoch counter ogmios_slot_in_epoch 150361 # TYPE ogmios_tip_block counter ogmios_tip_block 7756720 # TYPE ogmios_tip_slot counter ogmios_tip_slot 71603161 # TYPE ogmios_total_connections counter ogmios_total_connections 0 # TYPE ogmios_total_messages counter ogmios_total_messages 0 # TYPE ogmios_total_unrouted counter ogmios_total_unrouted 0 "},{"uri":"https://ogmios.dev/getting-started/basics/","title":"Basics","tags":[],"description":"","content":"JSON-RPC Ogmios' interface is built on top of JSON-RPC 2.0 which is a tiny standard to give some structure to the various messages that can be exchanged with Ogmios. The standard specifies a top-level JSON envelope by which messages must abide, as well as a semantic for some of the fields. It well suited for request/response types of protocols, such as any of the Ouroboros mini-protocols spoken by Ogmios.\nWe won\u0026rsquo;t be covering the JSON-RPC standard in this guide but gives a few extra insights about how it relates to Ogmios and some good takes from it. The standard is however relatively small so we encourage you to spare 5 minutes and quickly go through it when you find an opportunity.\nEach request in Ogmios yields exactly one response, might it be a success response or an error response. Furthermore, requests which relate to a particular protocol are guaranteed to yield responses in the same order.\nRequests Requests messages are sent by client applications (you) to Ogmios. Requests have 3 fields of interest: method, params and id. The method identifies the request itself and translates to a corresponding message of one of the 3 Ouroboros mini-protocols. Possible values for method are described in section 3 - Ouroboros mini-protocols and the complete reference is available in section 4 - API Reference. The params specify extra parameters that apply to the given method.\nHere is an example of valid request message:\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;findIntersection\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;points\u0026#34;: [ \u0026#34;origin\u0026#34; ] }, \u0026#34;id\u0026#34;: \u0026#34;init-1234-5678\u0026#34; } As you can see, the method specifies the method findIntersection which relates to the chain synchronization protocol. This particular request expects one argument named points, which contains a list of points we want to intersect with (don\u0026rsquo;t panic, this is explained in further details in the next section!). Another interesting, albeit optional, field is the id field. This is completely free-form and will be spit back identically by Ogmios in the response exactly as provided. This can be useful to keep track of states on the client application or pass in extra context to each request/response. Be careful though that anything you send for a request will come back in the response; send something big, get something big.\nResponses Let\u0026rsquo;s start with a possible response to the request above:\n{ \u0026quot;jsonrpc\u0026quot;: \u0026quot;1.0\u0026quot;, \u0026quot;result\u0026quot;: { \u0026quot;intersection\u0026quot;: \u0026quot;origin\u0026quot;, \u0026quot;tip\u0026quot;: { \u0026quot;hash\u0026quot;: \u0026quot;d184f428159290bf3558b4d1d139e6a07ec6589738c28a0925a7ab776bde4d62\u0026quot;, \u0026quot;blockNo\u0026quot;: 4870185, \u0026quot;slot\u0026quot;: 12176171 } }, \u0026quot;id\u0026quot;: \u0026quot;init-1234-5678\u0026quot; } The response kindly indicates which requests it corresponds to and has the same method as the matching request. It also gives a result under a specific field. Responses can have various results which are fully specified in section 4. - API Reference. Also, notice the id field in the reponse which reflects exactly the id field that was set for the request.\nOgmios' responses may correspond to possible errors that are part of the Ouroboros mini-protocols. For example, if you submit an invalid transaction, you\u0026rsquo;ll get back a success response with a result because it is a valid message in the context of the mini-protocols. Yet, Ogmios will yield an error message (with an error field) if you submit an invalid Ogmios message (for instance, an unknown request constructor, or something that is not a valid JSON-RPC message).\n WebSocket vs HTTP Ogmios defaults transport protocol is WebSocket. Yet some mini-protocols (e.g. the transaction submission or the ledger state query) can also work over HTTP under some circumstances.\nWebSocket The WebSocket protocol is full-duplex, which means that Ogmios and clients can send messages to each other all at the same time. That is very convenient for clients who can pipeline many requests at once and process responses later on as they arrive.\nTherefore, to send a message to ogmios, you only need a WebSocket client! For example, using the well-established ws Node.js package and assuming a local instance of Ogmios started through Docker, you can interact with Ogmios as simply as:\nconst WebSocket = require(\u0026#39;ws\u0026#39;); const client = new WebSocket(\u0026#34;ws://localhost:1337\u0026#34;); client.once(\u0026#39;open\u0026#39;, () =\u0026gt; { const request = { \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method: \u0026#34;findIntersection\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;points\u0026#34;: [ \u0026#34;origin\u0026#34; ] } }; client.send(JSON.stringify(request)); }); client.on(\u0026#39;message\u0026#39;, function(msg) { const response = JSON.parse(msg); // do something with \u0026#39;response\u0026#39; }); HTTP Some requests may also simply be sent over HTTP as POST requests, using the same JSON payload as data. This works well for (part of) the protocols that are stateless. For example, a one-off transaction submission is likely easier to send as an HTTP request than via an asynchronous WebSocket. Similarly, local state queries that are presented later in this user manual are likely candidate too, provided that you need not to hook on a particular point on chain. For example:\nconst fetch = require(\u0026#39;fetch\u0026#39;); fetch(\u0026#34;http://localhost:1337\u0026#34;, { method: \u0026#34;POST\u0026#34;, data: { \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method: \u0026#34;submitTransaction\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;transaction\u0026#34;: \u0026#34;...\u0026#34; } } }).then(async response =\u0026gt; { const json = await response.json(); // do something with \u0026#39;response\u0026#39; }); That\u0026#39;s all for the basics. The rest isn\u0026#39;t really specific to Ogmios, but is about the Ouroboros mini-protocols themselves. See the next sections for a deep dive! "},{"uri":"https://ogmios.dev/changelog/","title":"Changelog","tags":[],"description":"","content":"[6.0.0] - UNRELEASED Added   Ogmios now accept queries via HTTP (POST). Request bodies are the same as those passed to the websocket and so are responses. In fact, most Ogmios queries follow a simple request/response pattern and are therefore well-suited to be run over HTTP. While there\u0026rsquo;s an obvious performance trade-off (especially for the local-chain-sync protocol), it is a reasonable approach for many queries (e.g. the local-state-query protocol).\n Note The HTTP server and the WebSocket server are both mounted on the same port. So, it suffices to route HTTP requests through /. The JSON payload is the same.\n   Ability to retrieve any genesis configuration (Byron, Shelley or Alonzo) via the local-state-query protocol.\n  A new command inspect transaction to help with debugging the deserialization of transaction.\n  Changed   ‚ö†Ô∏è BREAKING-CHANGE ‚ö†Ô∏è Many major changes in the interface. A complete migration guide is available in ADR-017, yet please refer to the API reference for details and exhaustiveness.\n Note There are still many test vectors available for every element of the Ogmios API. Use them!\n   Removed   ‚ö†Ô∏è BREAKING-CHANGE ‚ö†Ô∏è Compact mode is no more. Responses are more compact by default already and it is no longer possible to ask for a compact mode.\n  ‚ö†Ô∏è BREAKING-CHANGE ‚ö†Ô∏è Ogmios no longer returns null or empty fields. Where a field\u0026rsquo;s value would be null prior to v6.0.0, Ogmios now simply omit the field altogether. This is also true for most responses that return empty lists as well. All-in-all, please refer to the documentation / JSON-schema in case of doubts (fields that may be omitted are no longer marked as required).\n  ‚ö†Ô∏è BREAKING-CHANGE ‚ö†Ô∏è Ogmios no longer supports submitting transactions using { \u0026quot;bytes\u0026quot;: \u0026quot;...\u0026quot; } as parameters; One must now specify the transaction as { \u0026quot;transaction\u0026quot;: { \u0026quot;cbor\u0026quot;: \u0026quot;...\u0026quot; } }. Since v5.2.0 (when the submission protocol was extended), Ogmios supported two notations for transaction submission (using either bytes or submit) as a backward-compatible mechanism. It now supports only one new format.\n    [5.6.0] - 2023-02-02 Added   Add a new helper function unsafeMetatumAsJSON which converts a detailed metadata schema into plain JavaScript, whenever possible. For example:\n{ \u0026quot;list\u0026quot;: [ { \u0026quot;string\u0026quot;: \u0026quot;foo\u0026quot; }, { \u0026quot;int\u0026quot;: 42 } ] } ‚Üí [\u0026quot;foo\u0026quot;, 42]\nThis should work for any CIP-0025 metadata, and a few other formats. Yet it is unsound in the general case since not every on-chain metadata can actually be represented as JavaScript objects.\n  Changed   Now targets ES2020.\n  Fixed a bug in the JSON parser where coins quantities from all eras prior to Mary would be parsed as Number instead of BigInt.\n  Removed N/A\n  [5.5.8] - 2023-01-25 Added N/A\nChanged   Bump internal packages to match cardano-node@1.35.4 dependencies set.\n  Bundle the docker image with more recent versions of the cardano-configurations.\n  Fix TxMonitorClient\u0026rsquo;s nextTx wrongly throwing an error when called with no argument. The signature of that method has also been reworked slightly to provide better usage at call-site.\n  Add missing required constraints in the JSON schema for Byron witness representation that caused TypeScript types to be generated as optional.\n  Removed N/A\n  [5.5.7] - 2022-10-27 Added   delegationAndRewards and nonMyopicMemberRewards queries now both accept credentials in the form of bech32 strings as parameters, with the following expected prefixes and semantic (according to CIP-0005:\n stake (resp. stake_test on test networks) for stake addresses stake_vkh for stake key hash digests script for stake script hash digests  See also #277.\n  Allow additionalUtxoSet to be passed as argument in the repl.\n  Changed  Fixed additionalUtxoSet being ignored in the TxSubmissionClient of the TypeScript client.  Removed N/A\n  [5.5.6] - 2022-10-21 Added   Prometheus metrics exported at /metrics endpoint\n  Schema definitions are now included in the üìò API reference. This makes it a little easier to find a specific schema without having to drill into a messages definitions.\n  Changed   Fixed network synchronization reporting 0.99999 even when fully synchronized. There was sometimes a possible discrepancy between the ledger internal clock and Ogmios' clock, causing a few seconds of drift time.\n  Fixed a couple of data-types with fields parsed as number instead of bigint. See #274\n Warning This is technically an internal breaking-change, however it actually comes as a bug fix since this does not change the announced interface in the TypeScript schema (which was correctly indicated \u0026lsquo;bigint\u0026rsquo;). Still, this may cause issues with those using number where there will now be bigint.\n   Fixed browser detection for the IsomorphicWebSocket abstraction. See #273\n  Removed N/A\n  [5.5.5] - 2022-08-19 Added   Support for the TxMonitor mini-protocol in the REPL.\n  Link to a new Java client for Ogmios.\n  Changed  Fixed parsing of ScriptFailures coming out of the evaluateTx command. Before this patch, the client would simply throw undefined when such an error was encountered. They are now properly transcribed as EvaluateTxError.  Removed  testnet has been removed from the target networks by the Docker workflow; which means that until further notice, there will be no more Docker images pushed for testnet. However, support for preprod and preview environment has been added.    [5.5.4] - 2022-08-11 Added  Missing JSON specification (and therefore, documentation) for collectErrors. See #244.  Changed   Slot lengths are now encoded as floating numbers (double precision) instead of integers (still representing a number of seconds). However, to maintain backward-compatibility, integers value are encoded without decimal, as they used to. #245\n  Blocks' properties (header, headerHash, body) are no longer marked as optional in the JSON specification (and consequently, in the TypeScript SDK). #238\n  Removed N/A\n  [5.5.3] - 2022-07-31 Added N/A\nChanged   Bumped cardano-node\u0026rsquo;s version (continuous integration \u0026amp; docker image) to 1.35.2.\n  ‚ö†Ô∏è Fixed Plutus' data / datum serialization function. See 3f614c3c for details. As a consequence, some datums (either inline or in the witness set) that have been reported in the past (since v5.5.0) may have been wrong. Note that the datum hashes were however correct, so it is possible to identify the \u0026ldquo;corrupted\u0026rdquo; ones by trying to re-hash (blake2b-256) them and see whether they match their associated hash digest.\n  Changed the Docker image tagging\u0026rsquo;s scheme of cardano-node-ogmios to now include the cardano-node\u0026rsquo;s version. This allows to more easily bundle more recent version of cardano-node with old versions of Ogmios without the need to make a whole new release. This is in effect from v5.5.2 and onwards.\n   image repository tags     cardano-node-ogmios cardanosolutions/cardano-node-ogmios latestlatest-{NETWORK}v*.*.*_{CARDANO_NODE_VERSION}v*.*.*_{CARDANO_NODE_VERSION}-{NETWORK}   ogmios cardanosolutions/ogmios latestlatest-{NETWORK}v*.*.*v*.*.*-{NETWORK}      Fixed incongruous error message from the command-line when failing to parse protocol parameters from genesis files. The error reporting has been slightly improved to give a more fine-grained error per invalid parameter. See #242.\n  Removed N/A\n  [5.5.2] - 2022-07-11 Added N/A\nChanged   Bumped cardano-node\u0026rsquo;s version (continuous integration \u0026amp; docker image) to 1.35.1.\n  Remove superfluous string concatenation in UnknownResultError\u0026rsquo;s message. See #236.\n  Removed N/A\n  [5.5.1] - 2022-07-05 Added  New isBabbageProtocolParameters helper function, and extended support of the existing ones to Babbage. See #234.  Changed  Fixed Health endpoint wrongly reporting \u0026lsquo;Alonzo\u0026rsquo; while in the \u0026lsquo;Babbage era\u0026rsquo;. See #233.  Removed N/A\n  [5.5.0] - 2022-06-29 Added  Added Vasil/Babbage support, including:  A new block type babbage with:  New (optional) transaction fields references, collateralReturn, totalCollateral; New (optional) transaction output\u0026rsquo;s fields datum and script;   A new plutus:v2 script language;   New transaction error submission failures in the Babbage era:  mirNegativeTransfer: return when attempting to perform a negative MIR transfer from a reward pot to another; totalCollateralMismatch: returned when totalCollateral is set but does not match what is actually computed by the ledger (i.e. sum of collateral inputs minus collateral return); malformedReferenceScripts: returned when the script specified in an output isn\u0026rsquo;t actually a well-formed Plutus script; malformedScriptWitnesses, occurs when a script witness specified in the transaction does not properly deserialize to a Plutus script.   New script evaluation failures in the Babbage era:  corruptCostModelForLanguage: An artifact from a distant past. This is unused but somehow still present in the ledger internal definitions. Should be removed eventually.   New server evaluation failures:  NotEnoughSynced: Happens when attempting to evaluate execution units on a node that isn\u0026rsquo;t enough synchronized. This is, if the node is still in an era prior to Alonzo, evaluation of execution units won\u0026rsquo;t be possible. CannotCreateEvaluationContext: Happens when the ledger fails to create an evaluation context from a given transaction. This is mostly due to the transaction being malformed (e.g. wrong redeemer pointer, missing UTxO).    See the üìò API reference for more details.\nChanged   Updated cardano-configurations to include the vasil-dev network and switch to cardano-world as a source instead of Hydra artifacts \u0026ndash; now being deprecated.\n  Partially fixed an issue causing websocket connection to be terminated by the server when p2p is enabled on the underlying node. Ogmios now has a workaround which makes the issue less likely, but the real fix belongs in the upstream networking stack. See #230, #208.\n  The missingRequiredScripts error now contains an extra field resolved that is a map of (pointer ‚Üí script hash) that have been correctly resolved by said pointers.\n  The introduction of the Babbage era comes with some minor (albeit possibly breaking) changes and deprecations:\n  ‚ö†Ô∏è datums, redeemerData and plutus:v1 scripts are no longer encoded as base64 strings, but are encoded as base16 strings. The data payload remains however identical. This change is meant for more compatibility across the API since those data-types can now also be submitted to the server when evaluating execution units for transactions. Using base64 for input data here is a bit awkward since most existing interfaces in the ecosystem favor base16;\n  ‚ö†Ô∏è When passing transaction outputs to the server (e.g. when providing an additional UTxO for script evaluation), datum hashes in output must now be specified as datumHash (instead of datum). However, the server does a best-effort for the sake of backward compatibility and should still work if provided with a valid hash under datum. However, after the Vasil hard-fork, it\u0026rsquo;ll be possible to also pass inline-datums using datum, while datum hash digest are expected to be specified as datumHash. Said differently, existing applications relying on this functionality will keep working without a change on this release, but applications willing to make use of the new inline-datum functionality coming in Vasil must abide by the new notation;\n  ‚ö†Ô∏è Similarly, Alonzo transaction outputs will now contain a datumHash field, carrying the datum hash digest. However, they will also contain a datum field with the exact same value for backward compatibility reason. In Babbage however, transaction outputs will carry either datum or datumHash depending on the case; and datum will only contain inline datums;\n  ‚ö†Ô∏è The outputTooSmall errors from transaction submission will slightly change format for transactions submitted during the Babbage era. Instead of an array of outputs, it is an array of objects with output and minimumRequiredValue fields;\n  ‚ö†Ô∏è A slightly modified block header: leaderValue and nounce fields are gone and replaced by a single inputVrf field;\n  ‚ö†Ô∏è Few protocol parameters changes:\n  A new protocol parameter coinsPerUTxOByte comes to replace coinsPerUtxoWord with a slightly different semantic. coinsPerUTxOByte is meant to compute the minimum Lovelace requirement on transaction outputs, and is simply a coefficient in a linear function of the serialized (CBOR) output:\nminUTxOValue(output) = |serialise(output)| * coinsPerUTxOByte   The decentralizationParameter no longer exists. The block production is forever decentralized :tada:!\n  The extraEntropy no longer exists.\n      See the üìò API reference for more details.\nRemoved   UnknownInputs and UncomputableSlotArithmetic errors have been removed from the top-level possible cases of EvaluationFailure. Instead, those errors are now comprised in the CannotCreateEvaluationContext case.\n  The corruptCostModelForLanguage error has been removed from the top-level possible cases of ScriptFailure. This one was effectively dead-code that couldn\u0026rsquo;t be reached and was there for completeness. The code has now been removed upstream.\n    [5.4.0] - 2022-05-22 Added  TypeScript client for the \u0026lsquo;TxMonitor\u0026rsquo; mini-protocol. Documentation available at https://ogmios.dev/typescript-client/tx-monitor/.  Changed   The server now returns slightly better faults when detecting a misuse of the TxMonitor protocol (e.g. when sending a HasTx before an AwaitAcquire).\n  The server now fails with an explicit error when given a Request containing a reflection field; reflection are only used in responses, while requests use mirror. See #217.\n    [5.3.0] - 2022-05-07 Added   In the Local-Tx-Monitor protocol, NextTx can now take an (optional) extra argument { \u0026quot;fields\u0026quot;: \u0026quot;all\u0026quot; } to instrument the server in returning not only a transaction id in NextTxResponse, but a full transaction object. See #190.\n  Transaction JSON objects from all eras now contains an extra field raw, which represents the raw serialized transaction (CBOR) as a base64-encoded text string. This is the case of the chain-sync protocol, but also for the tx-monitor protocol. The field is however absent in the ogmios.v1:compact mode. See #190.\n  Transaction JSON objects from the Alonzo era now contains an extra field inputSource which a string set to either inputs or collaterals. This captures the fact that since the introduction of Plutus scripts in Alonzo, some transactions may be recorded as failed transactions in the ledger. Those transactions do not successfully spend their inputs but instead, consume their collaterals as an input source to compensate block validators for their work.\n  Changed   The complete API reference for the server is available in a new form at: https://ogmios.dev/api/. This should make the various protocol messages easier to explore and provide a less awkward visualization of the server API than the previous TypeScript documentation. The old TypeScript documentation remains however available at: https://ogmios.dev/typescript/api/.\n  Upgrade internal dependencies to cardano-node@1.34.1\n  Fixed the supervisor script for the cardano-node-ogmios Docker image, which would wrongly ignore signals sent from the Docker daemon (e.g. docker container stop ...). See #168\n  The tx-submission client now only creates a single event listener to interact with the server. This solves the Node.js warning \u0026ldquo;possible memory leak detected\u0026rdquo; when firing many submission requests at once (and going beyond the internal default maxNumberOfListeners set by node.js on event emitters). See #197.\n  The options passed to the WebSocket constructors are now ignored on the browser, since they aren\u0026rsquo;t supported and were causing the constructor to \u0026ldquo;crash\u0026rdquo;. See #194.\n  ‚ö†Ô∏è Some schema type interface renaming:\n Tx ‚Üí TxByron BlockBodyShelley ‚Üí TxShelley BlockBodyAllegra ‚Üí TxAllegra BlockBodyMary ‚Üí TxMary BlockBodyAlonzo ‚Üí TxAlonzo    Removed N/A\n  [5.2.0] - 2022-02-15 Added  Extended the local-tx-submission protocol with a new EvaluateTx query which evaluates execution units of scripts present in a transaction. This effectively piggybacks on the Alonzo\u0026rsquo;s tools from the cardano-ledger while providing a more user-friendly interface regarding network parameters. The API offers well-detailed errors and an interface similar to the SubmitTx. See discussion on #172.     New rewardsProvenance' query coming as a replacement for the now-deprecated rewardsProvenance query. See discussion on #171.      Support for the new evaluateTx query in the TxSubmissionClient \u0026amp; repl.\n  Support for the new rewardsProvenance' query as rewardsProvenanceNew in the StateQueryClient \u0026amp; repl.\n  Changed  Added transaction id as part of the successful response to a SubmitTx. While this is technically a breaking-change, it was introduced in a backward-compatible way. Existing applications using the existing SubmitTx query will see no change and will keep receiving successes as \u0026quot;SubmitSuccessful\u0026quot; text responses. However, queries which pass transactions using the submit field (instead of the currently expected bytes field) will receive, on success, an augmented response which contains a transaction id \u0026quot;SubmitSuccessful\u0026quot;: { \u0026quot;txId\u0026quot;: \u0026quot;...\u0026quot; }. See discussion on #174.     Improved error reporting for the SubmitTx protocol which should gives a little clearer errors for ill-formed transactions.     ‚ö†Ô∏è Renamed client\u0026rsquo;s TxSubmission/errors.ts into TxSubmission/submissionErrors.ts. Similarly, the submission are also now nested under a submissionErrors field in the TxSubmission top-level object.  Removed N/A\n  [5.1.0] - 2022-01-24 Added  New LocalTxMonitor support in Ogmios. See The user guide for more details.    ‚ö†Ô∏è This new protocol is NOT enabled in cardano-node@1.33.*. Until its inclusion in a next release, a custom build of cardano-node is required to include a more recent version of ouroboros-network which adds support for that protocol to the Ouroboros' mini-protocols; namely: 32af9168.\n  A version of cardano-node@1.33.0 patched with the necessary commits can be found at CardanoSolutions/cardano-node@1.33.0+local-tx-monitor.\n   New fields in the health object:  connectionStatus ‚Üí \u0026quot;connected\u0026quot; or \u0026quot;disconnected\u0026quot;, to reflect status with the node. #154 currentEpoch ‚Üí which returns the current known epoch of the linked node #164 slotInEpoch ‚Üí which returns the relative number of slots elapsed in the current epoch #164       New ogmios health-check command, useful to perform simple health check on a running server. For example, to monitor a container via Docker health check mechanism: HEALTHCHECK --interval=10s --timeout=5s --retries=1 CMD /bin/ogmios health-check Bumped internal dependencies to Cardano\u0026rsquo;s 1.33.* eco-system.  Changed  networkSynchronization and currentEra can be null when the server isn\u0026rsquo;t connected to a node. #154 The Metrics trace is now correctly tagged with MetricsRuntimeStatsDisabled. Fixed an issue with the Docker monitoring scripts of cardano-node-ogmios, causing issues on restart. #159 Relax upper-bound constraint on required node.js engine. This should make it possible to install the TypeScript packages on more recent versions on node.js than the one specified on the repository.  Removed N/A\n  [5.0.0] - 2021-12-20 Added   New state-query systemStart to access the blockchain start time (UTC).\n  New state-query chainTip to access the blockchain current tip (may slightly differ from the ledgerTip which may be behind catching up).\n     New state-query blockHeight to access the blockchain current highest block number (or \u0026quot;origin\u0026quot; if the chain is just starting).     New state-query eraSummaries to access all era bounds and slotting parameters details, required for proper slot arithmetic.     Log-levels can now be configured per-component. For example, one can decrease the min severity for the health component while keeping the state-query logs at another.     Logs can now be shutdown completely via the special keyword off.     Static binaries for Linux are now produced by the Nix build and uploaded as build artifacts for the corresponding Github workflow (i.e. Nix).     Add support for systemStart, chainTip, blockHeight \u0026amp; eraSummaries in the client and repl.  Changed üè¢ Server  ‚ö†Ô∏è RelativeTime is no-longer serialised as a string (with s as suffix) but, as an integer representing the number of seconds.      ‚ö†Ô∏è Serialised Plutus scripts are now labelled either plutus:v1 or plutus:v2 (instead of plutus).\n  ‚ö†Ô∏è Some breaking changes in the SubmitTx errors returned by the server for the sake of consistency. All submission errors are now returned as singleton objects within an array. The key of each object indicates the type of error and the value gives additional details about the errors. This is also true for era-mismatch errors. Some errors used to be returned as plain strings, they are now wrapped as singleton object with null as a value; this is the case for:\n invalidMetadata mirNegativeTransferNotCurrentlyAllowed mirProducesNegativeUpdate mirTransferNotCurrentlyAllowed missingAtLeastOneInputUtxo missingCollateralInputs triesToForgeAda validationTagMismatch wrongCertificateType        Upgraded internal dependencies to Cardano eco-system 1.31.0\n  ‚ö†Ô∏è Lovelace is now a native BigInt.\n      ‚ö†Ô∏è getServerHealth\u0026rsquo;s connection argument is now wrapped into an object, mapped to the field connection. (see #135)\n  ‚ö†Ô∏è Replaced schema definitions for Hash16 and Hash64 with more precise type definitions. For hashes, definitions now follows a convention Digest[ALGORITHM]::PRE-IMAGE where ALGORITHM and PRE-IMAGE points to the corresponding has algorithm used to hash the PRE-IMAGE. The length of the digest is given by minLength and maxLength JSON-schema constraints. Consequently, TypeScript types / interfaces generated from the JSON-schema definitions have been altered.\n  Removed   ‚ö†Ô∏è Log level severities critical, alert and emergency have been removed. error is now the highest severity.\n  ‚ö†Ô∏è The Nix setup has been highly simplified, resulting in removal of the NixOS services configuration and probably some other stuff.\n    [4.2.1] - 2021-11-16 Added   N / A\nChanged  Fixed configuration parsing which would wrongly use Shelley\u0026rsquo;s slots per epoch instead of Byron\u0026rsquo;s. This had an impact on the reported slot number in the chain-sync protocol, where slot numbers would be wrongly offset by 432000 per epoch after the first epoch.  Removed N/A\n[4.2.0] - 2021-11-05 Added   Enabled Alonzo transaction in the submission protocol (oversight from previous releases). Doing so, explicit compiler warnings have been added to the relevant code to avoid overseeing this in the next upgrade.\n  Added query response and requests to logs trace, large responses are truncated (e.g. querying the entire UTXO or, informations about all stake pools).\n      Gracefully handled shutdown and process cleanup on SIGTERM.\n  Documented Mary last point to the points of interests for the chain-sync protocol.\n      Bumped cardano-node\u0026rsquo;s integration to 1.31.0\n  The State-Query client can now release acquired points to perform queries against the most recent tip (which was also the default when creating a client with no point).\n  Changed  Some internal rework and cleanup; mostly chasing dangling promises by avoiding attaching even handlers when not needed.  Removed N/A\n  [4.1.0] - 2021-09-08 Added   Generate and store test vectors for various JSON requests and responses. This should ease integration for many clients who seek for good coverage of the server inputs/outputs.\n  Documented example state queries in the user-guide.\n  The ConnectionConfig has an additional, optional, configuration parameter maxPayload to configure the maximum allowed message size in bytes. The default is chosen quite large as the utxo query can result in large payloads.\n  New helpers isByronEpochBoundaryBlock and isByronStandardBlock.\n  Changed  The StateQueryClient now wraps every query in a try/catch to cope with malformed queries leading to client fault results from the server. Type definitions for QueryResponse[poolIds] and QueryResponse[poolParameters] are no longer marked as \u0026ldquo;optional\u0026rdquo;. Fixed bug #125 where empty results of delegationAndRewards would cause the client to throw an exception. Handled some floating promises.  Removed N/A\n  [4.0.0] - 2021-09-06 Added  Integrated with the Cardano eco-system corresponding to cardano-node@1.29.0 (Alonzo!) \u0026amp; latest testnet(s).     New alonzo block type, with various additions related to Alonzo.      New state-queries:\n   Query Description     poolIds The list of all pool identifiers currently registered and active.   poolParameters Stake pool parameters submitted with registration certificates.   poolsRanking Retrieve stake pools ranking (a.k.a desirabilities).   rewardsProvenance Get details about rewards calculation for the ongoing epoch.      Added missing properties in Byron\u0026rsquo;s protocol parameters update. Somehow, an additionalProperties: true had slipped through and caused the tests to pass with an incomplete schema.\n  Nested logs are now also structured, in particular those coming from the Handshake or TxSubmission protocols. Before, any message from these layers where actually plain strings with unintelligible gibberish. Now, the submitted transaction payload is shown encoded as hexadecimals and errors are also serialized to json using the same model / codec as the one used for websockets. The handshake is also more verbose now clearly showing what version is being requested and what the node replies / select. All in all, better logs.\n  The Dockerfile now includes a build definition for building cardano-node and ogmios into the same image, which is the default and suggested mode of operation. To build an image with only Ogmios, use the build --target ogmios. Docker Hub now hosts two image repositories: cardanosolutions/cardano-node-ogmios and cardanosolutions/ogmios.\n  Docker Hub images are now tagged with a network suffix (e.g. -mainnet). In the case of mainnet, the -mainnet suffix is optional, and points to the same build as the defaults.\n  A new repository for hosting Cardano configurations of various services was created and is now used in Ogmios. Configuration for cardano-node (and therefore Ogmios) or, network genesis can be found in input-output-hk/cardano-configurations. Configurations are updated automatically by a nightly job to be always up-to-date. They can be pulled into projects as git submodules.\n  New possible errors from the transaction submission (stemming from the Alonzo integration):\n collateralHasNonAdaAssets collateralIsScript collateralTooSmall collectErrors datumsMismatch executionUnitsTooLarge extraDataMismatch extraRedeemers mirNegativeTransferNotCurrentlyAllowed mirProducesNegativeUpdate mirTransferNotCurrentlyAllowed missingDatumHashesForInputs missingRequiredDatums missingRequiredRedeemers missingRequiredSignatures outsideForecast poolMetadataHashTooBig tooManyCollateralInputs unspendableDatums unspendableScriptInputs validationTagMismatch    Compatibility with aforementioned server additions.\n  The ChainSyncClient now implements an in-memory queue to ensure requestNext responses are processed sequentially when there are async operations in the message handlers. This behaviour can be bypassed where sequential processsing is not required, by setting the new construction option sequential to false.\n  The StateQueryClient can now re-acquire new points at will, useful for long-running clients for which previously acquired points may expire.\n  The TypeScript client is now fully documented!\n  Changed   ‚ö†Ô∏è The utxo query can now accept a list TxIn as argument, and still supports list of Address. Note that lists can\u0026rsquo;t be heterogeneous and it\u0026rsquo;s not possible to mix TxIn and Address.\n  ‚ö†Ô∏è Asset quantities and transaction metadata\u0026rsquo;s integers are now parsed as native BigInt.\n  The memory and steps JSON representations for prices are no longer coins, but ratio (represented as strings in the API).\n  The moveInstantaneousRewards certificates have a new optional field value and not only a rewards map as before. When value is present, it signifies that rewards are moved to the other pot.\n  Auxiliary data\u0026rsquo;s scriptPreImages in Allegra \u0026amp; Mary has been replaced with a field scripts which has one field native. The value of native corresponds to what used to be the value of scriptPreImages. In Alonzo, scripts may also have another field plutus with a serialized Plutus script.\n  Transactions witnesses' address has been renamed into signatures, and the structure of the object has been changed to be a map from public keys to signatures (instead of an object with two field key \u0026amp; signature).\n  Transactions witnesses' script has been renamed into scripts.\n  Transaction submission errors' networkMismatch now returns an invalidEntities list of object in the form of { \u0026quot;type\u0026quot;: ..., \u0026quot;entity\u0026quot;: } where type is a text tag designating the type of entity for which there is a network identifier mismatch. Values can be address, rewardAccount and since Alonzo transactionBody. The entity field contains some details specific to the type of entity. Before, it used to be two distinct fields invalidAddresses and invalidRewardAccounts.\n  Empty transaction metadata are no longer materialized by an object with two null fields ({ \u0026quot;hash\u0026quot;: null, \u0026quot;body\u0026quot;: null }). Empty transaction metadata are now equal to null.\n  map metadatum in transactions' metadata are no longer materialized as a list of list of singleton objects: [[{ \u0026quot;k\u0026quot;: ... }, { \u0026quot;v\u0026quot;: ... }], ...] but instead, as a list of object with two fields k and v: [{ \u0026quot;k\u0026quot;: ..., \u0026quot;v\u0026quot;: ...}, ...]. This was an oversight from the encoder which was never intended to end up that way but happened to slip in because the schema for metadatum was not specified / documented (and therefore, also escaped testing). This is now documented properly.\n  The TxOut (and thus Utxo) model definitions have been unified and harmonized across all eras. That is, pre-Mary eras now also wrap Ada values in an object with a field \u0026quot;coins\u0026quot;: .... This reduces the discrepancy between eras for there\u0026rsquo;s now a single TxOut representation valid across all eras. Some fields are however optional and only present in some eras (e.g. datum starting from Alonzo)\n  ‚ö†Ô∏è State queries (resp. the StateQueryClient) now automatically runs queries against the last known tip if no explicit point is provided. It used to acquire a point on the first query which would eventually become too old. The behavior is now equivalent to acquiring a new point on every query!\n  ‚ö†Ô∏è SubmitTx no-longer returns Byron errors. Consequently, submit errors are no longer scoped under errors.byron or errors.shelley but simply errors.\n  ‚ö†Ô∏è Fixed proposedProtocolParameters query. All fields are actually required AND, more importantly, it can now return either Shelley protocol parameters or, Alonzo protocol parameters.\n  The ChainSyncClientMessageHandlers methods now must return a promise.\n  Various reworks and renaming of the TypeScript types\n AssetQuantity is now a native bigint Metadatum\u0026rsquo;s Int are now native bigint Type DelegationsAndRewards renamed into DelegationsAndRewardsByAccounts Type DelegationsAndRewards1 renamed into DelegationsAndRewards Type NonMyopicMemberRewards1 renamed into NonMyopicMemberRewards Type TxTooLarge1 renamed into TxTooLarge Type FeeTooSmall1 renamed into FeeTooSmall Type NetworkMismatch1 renamed into NetworkMismatch Type Proposal renamed into UpdateProposalShelley Types Utxo1, Utxo2, UtxoMary have been unified into a single Utxo type. Refer to server breaking changes for details. Type Tip \u0026amp; Point renamed into TipOrOrigin and PointOrOrigin. As a consequence, Tip1 and Point1 are now simply Tip and Point. Many types NullX merged into a single Null type Query types have been renamed from ledgerTip1 to GetLedgerTip and so forth for all queries.    Removed   datumsMismatch, a previously introduced error from the transaction submission has been removed / replaced.\n  SubmitTx can no longer return SubmitTxError[Byron]. All the child error types have been removed accordingly, namely:\n UtxoValidationError TxValidationError LovelaceError    ChainSyncClient no longer exposes a requestNext function. Instead you must invoke the callback provided as the second argument in each of rollBackward and rollForward handlers.\n  ChainSyncClient no longer exposes JSON-WSP reflection as there would be unexpected results given the first n messages would all share the same reflected value.\n    [3.2.0] - 2021-05-09 Added  New TypeScript client! The client comes in three packages:  An interactive REPL to play with Ogmios using the command-line. A generator to derive TypeScript type definitions from the JSON schema. The actual client library providing nice wrapper around the various protocol, in a typed way. The TypeScript client also includes a new battery of automated integration tests against the testnet.   Support for WebSocket sub-protocols, with currently one support sub-protocol: ogmios.compact.v1. When enabled, Ogmios will omit fields such as witnesses, proofs and signatures from responses to make responses smaller. Provide missing documentation / JSON-schema for:  JSON-WSP faults Allegra \u0026amp; Mary SubmitTx failures:   Allegra:\n expiredUtxo is replaced by outsideOfValidityInterval new error triesToForgeAda  Mary:\n valueNotConserved.consumed is now a Value (instead of a DeltaCoin) valueNotConserved.produced is now a Value (instead of a DeltaCoin) outputTooSmall items are now of type TxOut[Mary] new error tooManyAssetsInOutput       Continuous integration job checking for code style and lint on the server source code. The /health endpoint now returns two additional pieces of information:  A networkSynchronization percentage to indicate how far Ogmios / the node is from the network. A currentEra value to indicate the corresponding Cardano era Ogmios / the node is currently running in.   Nix support for building Ogmios (this also include a cabal.project to enable cabal support as well).  Changed  Rework Docker setup to not require an external snapshot image. Everything is now built in a single Dockerfile, but cache from DockerHub can be leveraged to reduce overall build time when building from scratch. Fixed typo in the JSON-schema w.r.t to the \u0026lsquo;Acquire\u0026rsquo; request (points ‚Üí point), and introduce more automated test to catch this kind of errors more easily.  Removed √∏\n  [3.1.0] - 2021-04-04 Added  Extend the local-state query protocol with support for \u0026lsquo;GetCompactGenesis\u0026rsquo;. Extend the local-state query protocol with support for \u0026lsquo;GetFilteredDelegationsAndRewards\u0026rsquo;. Add missing mint field to transaction\u0026rsquo;s body (added since mary). The documentation is now hosted on https://ogmios.dev.  Changed  Use \u0026lsquo;contentEncoding\u0026rsquo; over \u0026lsquo;format\u0026rsquo; in appropriate part of the JSON schema. Fix various errors in the JSON-schema definition \u0026amp; extend test suite coverage in consequence. Implement a \u0026lsquo;fast-bech32\u0026rsquo; encoding library, to speed-up Ogmios serialization of blocks beyond the Shelley era. Use faster (and recommended) JSON encoding techniques to speed up overall JSON serialization. Improve generated documentation from JSON schema by:  Providing titles to \u0026lsquo;oneOf\u0026rsquo; items Adding descriptions to top-level definitions Adding examples to top-level definitions   Customized API reference\u0026rsquo;s stylesheet to enhance readability. Upgrade dependency and code to work with GHC-8.10.4 (from GHC 8.6.5) Handle more gracefully unknown exceptions (avoid infinite fast loop of retries on errors). Handle more gracefully network mismatches (e.g. connecting Ogmios in testnet mode to a mainnet network) Repository reorganization:  \u0026lsquo;ogmios-server\u0026rsquo; renamed into \u0026lsquo;server\u0026rsquo; move Haskell-specific dotfiles and configuration files under \u0026lsquo;server\u0026rsquo; move \u0026lsquo;modules\u0026rsquo; under \u0026lsquo;server\u0026rsquo; move \u0026lsquo;Dockerfile\u0026rsquo; and \u0026lsquo;snapshot.Dockerfile\u0026rsquo; under \u0026lsquo;server\u0026rsquo;    Removed  Support for GHC-8.6.5 The docker image no longer shows git revision / version on \u0026lsquo;\u0026ndash;version\u0026rsquo;    [3.0.0] \u0026ndash; 2021-02-26 Added  Support for the Allegra era on the chain-sync, tx submission and state query protocols. Support for the Mary era on the chain-sync, tx submission and state query protocols. Support for multi-era state queries, or said differently, Ogmios can survive a hard-fork without being restarted or re-compiled. Allow clients to also make state queries based on the node\u0026rsquo;s tip (instead of passing an explicit point to acquire). Interactive dashboard leveraging Ogmios health\u0026rsquo;s endpoint and local state query protocol to show metrics in real-time. Automated smoke sanity tests executed on a running instance, running queries and chain-syncs across all eras. Various internal optimization, in particular with rewards to the chain-sync protocol (~14.000 blocks/s in Byron, ~2500 block/s in Shelley and beyond). Additional metrics for monitoring: current heap size, total messages, total unrouted messages and start time. Configurable HTTP server timeout from the command-line, with sensible defaults.  Changed  Improve error responses to invalid clients' requests (instead of generic error messages). Fixed various typos and clumsy wording in the user manual. Reworked internal architecture as a Three-Layer Haskell Cake. Changed internal dependencies for base16 and base64 encoding for better performances. Upgraded internal dependencies to the Cardano eco-system working with cardano-node@1.25.1 Improved error handling of the Ogmios server, in particular in case of connections lost with the underlying node. The server now returns an explicit client error when interleaving \u0026lsquo;FindIntersect\u0026rsquo; messages in-between pipelined \u0026lsquo;RequestNext\u0026rsquo;. Revised default compilation flags .  Removed N/A\n  [2.0.0-beta] \u0026ndash; 2020-10-31 Added  Support for the Shelley chain in the local-chain-sync protocol. Support for the local-state-query protocol. Health / Heartbeat endpoint for monitoring. Runtime and application metrics measured and served on endpoint (/health). Ogmios now includes an HTTP static server hosting both the WSP definition and, a /benchmark.html to run some quick benchmark / smoke test. Added additional configuration options via command-line or environment. Revised user manual with detailed step-by-step examples.  Changed  Several JSON fields renamed to increase consistency between Shelley and Byron. Improved logging, more messages and with more context. Improved error handling with regards to connection of websocket clients.  Removed N/A\nChanged N/A\n  [1.0.0-beta] \u0026ndash; 2020-04-04 Added   Initial release and support for:\n Chain Synchronization (no pipelining between cardano-node \u0026amp; ogmios) Local Transaction Submission    JSON-WSP version 1.0, full support with reflection.\n  Full docker stack via docker-compose.\n  Basic command-line and logging.\n  Changed N/A\nRemoved N/A\n"},{"uri":"https://ogmios.dev/faq/","title":"F.A.Q","tags":[],"description":"","content":"Can you explain Ogmios in one three sentences? Ogmios is a lightweight bridge interface for cardano-node. It offers a WebSockets API that enables local clients to speak Ouroboros' mini-protocols via JSON/RPC. Ogmios is a fast and lightweight solution that can be deployed alongside relays to create entry points on the Cardano network for various types of applications (e.g. wallets, explorers, chatbots, dashboards‚Ä¶)\nCan you explain Ogmios to me like I\u0026rsquo;m five? To understand what Ogmios is, you must first understand where it fits in Cardano landscape. Cardano is a network of programs (a.k.a nodes) connected to each other and exchanging messages to run the Cardano blockchain. A Cardano node has an interface that allows for other programs to interact with it (very much like buttons on a remote to control the TV). However, that interface relies on novel communication methods, that were designed in-house by the networking team at IOG. To this day, the only tooling that fully implement those unique communication methods is written in Haskell* (as if all the buttons on the remote control were in Chinese, but you only speak French). So to interact with a Cardano node, one has no other choice than to write a Haskell program, which is a bummer for many application developers.\nThis is where Ogmios comes into play. Ogmios is written in Haskell, so it can speak with Cardano nodes just fine. But it also translates all the interfaces provided by the node using communication methods that are more common and accessible to the vast majority of developers (namely, WebSockets \u0026amp; JSON). Ogmios is a sort of translator; instead of speaking to a Cardano node directly, applications can speak to Ogmios using a language they know, and Ogmios translates it to the node and back to the applications.\n (*) Since 2022, Pallas now provides most of the primitives also in Rust.\n Where does the name come from? Ogmios is a celtic deity of eloquence, language and learning. This relates to the way this project helps users communicate with Cardano. And while it doesn‚Äôt translate languages, it translates protocols to protocols.\nWhy do I care? Well, it depends. In essence, Ogmios doesn\u0026rsquo;t do much more than what the node itself does. It\u0026rsquo;s pretty much as low-level as things can get with the Cardano network. For many applications, this is too low in the abstraction layer and they would be better off using higher-level services like cardano-graphql, Rosetta, or Blockfrost.\nHowever, building such services demands to be able to interact with the blockchain using a more direct interface. This interface can be Ogmios. Currently, the choices given to services like these are limited: talk directly to the node using the Haskell client library, or use cardano-db-sync which is a component that talks to the node and dumps blockchain data in a PostgreSQL database. For those who don\u0026rsquo;t write Haskell, the choice is even more limited; down to a single option. Plus, like any solution, it comes with trade-offs. Deploying a cardano-db-sync instance can be quite heavy, requires extra space, and already forces applications to operate in some specific ways. Ogmios gives a lightweight alternative that is also much closer to what the node offers. It would be possible for example to re-implement cardano-db-sync in a different programming language using Ogmios.\nSo in the end, if you\u0026rsquo;re writing a DApp or an application that needs to interact with the Cardano blockchain only at a high level using pre-defined abstractions, then you probably don\u0026rsquo;t care. However, if you\u0026rsquo;re doing some low-level work, and need to access every bit of the protocol or, if you\u0026rsquo;re building a service on top of Cardano for which the blockchain itself is the right level of abstraction, then Ogmios is most likely a good fit for you.\nCan I build X using Ogmios? The short answer is: if you can build X with a Cardano node, then yes. Ogmios is as capable as the client interface for Cardano nodes. Can I build a wallet with Ogmios? Yes. Can I build an explorer with Ogmios? Yes. Can I build a smart-contract application backend with Ogmios? Yes. Anything available on-chain is available through Ogmios which has so far also transitioned through the 4 eras of Cardano. Ogmios' first release was a bit before the Shelley hard-fork, and its development followed the on-chain upgrades and protocol updates.\nWhat\u0026rsquo;s the overhead from running Ogmios? Almost none. Ogmios runs within a handful of megabytes of memory and its CPU usage is very much driven by whatever application you\u0026rsquo;ll be connecting to it. That is if your application is syncing the entire blockchain and sending thousands of messages per second to the underlying node, then of course your CPU will get pretty busy; not from Ogmios itself, however, but mostly from the underlying node and your client. In between, Ogmios acts as a bridge and passes messages around. Once a message has been passed, Ogmios forgets about it. That makes the memory footprint of Ogmios quite low, and its resource usages tightly linked to whatever application consumes data from it.\nWe secretly keep a hope that someday, many operators will deploy Ogmios alongside their relays. Enabling many application developers to interact with the Cardano blockchain seamlessly by connecting to a relay close to them.\nIs there any client for Ogmios? As a matter of fact, there is. A TypeScript client library and REPL is available on the same repository. This client is also a first-class citizen within this user-guide so make sure to check out the TypeScript Client section.\nSince then, there has been other clients built by the community:\n Kogmios (Kotlin) Ogmigo (Go)  Besides, it goes without saying that as an open-source project Ogmios welcomes contributions; especially on the client library and/or around tools built on top. Should you be working on a new client, let us know, we\u0026rsquo;re happy to help.\nDoes Ogmios require the PAB (Plutus Application Backend) to work? No it does not. The PAB is an application framework which provides DApp developers with an extra interface for running smart-contracts on Cardano; Ogmios is not a DApp, nor does it require any DApp functionality. Ogmios does however require a full cardano-node to work for it is merely an interface on top of it.\nCan I use Ogmios in a remote setup? Yes. The easiest way is probably by using a reverse-proxy like NGINX to also promote the WebSocket connection to a secure connection. A more interesting question however is: should you? Ogmios is an interface for the so-called local client protocols which are, by design, intended to be used in a local setup: where Ogmios and cardano-node are on the same host. It would be ill-advised to expose the server to many clients without any restriction as each client can drain a quite large amount of resources from the local node. This is however totally acceptable in a controlled environment, where for example, your own stack would leverage a single Ogmios instance to power few remote services.\nWhy do Ogmios returns JSON with integers larger than MAX_SAFE_INTEGER? JSON does support large integers by design. The default JavaScript JSON parser does not however. Thus, it is not a problem which lies on the server-side, but rather on \u0026ldquo;naive\u0026rdquo; JavaScript clients. For more details, have a look at this architectural decision record which explains how we handle large integers in the TypeScript client.\nIs Ogmios production ready? Ogmios is an open-source project which is being worked on in small steps when time allows. Its development started in 2020 and it has undergone several updates and iterations. We\u0026rsquo;ve got a mad passion for software quality and we put extensive efforts into making Ogmios of the highest quality. The server follows a well-known architecture and abides by battle-tested Haskell coding practices. As it should, Ogmios is of course deeply tested at several levels via continuous integration1.\nTests for the server include property-based testing of the core protocols2 3, property-based testing of the entire JSON interface validated against a JSON-schema specification4. Note that property tests all use generators which comes directly from the ouroboros-network and cardano-ledger-specs to ensure that Ogmios is always up-to-date with the Cardano eco-system. There are also various5 unit6 tests7 to cover basic functionalities.\nOn the other hand, the TypeScript client is used to perform end-to-end tests with tests running against the Cardano testnet8. The tests are executed both in a Node.js and browser context and the synchronization with the network is done via a Github action which leverages Ogmios' server.\nBeside, Ogmios also comes with structured logging and monitoring out of the box. Putting any monitoring solution on top like Prometheus is trivial.\nFinally, if you ventured through this page and user-guide, you have also noticed that the project is well-documented. And this includes the API reference, the ChangeLog as well as the architectural decisions going over rationales for decisions we made along the way.\nThus, is Ogmios production-ready? Yes. At least, this is as good as it gets for an open-source project. We\u0026rsquo;ve been incorporating feedback from various users over the past year which has been great so far. For the rest, everything is open-source licensed under MPL-2.0 and you\u0026rsquo;re the best judge.\nAre there any projects/companies using it? We\u0026rsquo;ve heard of a handful happy users! And it keeps growing! To name a few\u0026hellip;:\n https://blockfrost.io/ https://eternl.io/ https://www.sundaeswap.finance/ https://jpeg.store/ https://spacebudz.io/ https://www.tangocrypto.com/ https://projectnewm.io/ https://github.com/input-output-hk/cardano-graphql https://mlabs.city/ https://gimbalabs.com/ https://www.f2lb.org/  Are you using Ogmios for a project? Let us know on Github!\n "},{"uri":"https://ogmios.dev/","title":"Overview","tags":[],"description":"","content":"Ogmios Ogmios is a lightweight bridge interface for cardano-node. It offers a WebSockets API that enables local clients to speak Ouroboros' mini-protocols via JSON/RPC.\n Need more information? Have a look at the Frequently Asked Questions!\n"},{"uri":"https://ogmios.dev/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"https://ogmios.dev/tags/","title":"Tags","tags":[],"description":"","content":""}]