[{"uri":"https://ktorz.github.io/cardano-ogmios/getting-started/","title":"Getting Started","tags":[],"description":"","content":"Getting Started Find in this section information about building and running Ogmios. This will cover installation from both sources and docker üê≥, as well as details about options and configuration for running Ogmios.\n"},{"uri":"https://ktorz.github.io/cardano-ogmios/deployment/aws/","title":"AWS","tags":[],"description":"","content":"Pre-Requisites   Make sure to have an AWS account, and an AWS_ACCESS_KEY_ID \u0026amp; AWS_SECRET_ACCESS_KEY.\n  Make sure to grant AmazonEC2FullAccess to your AWS user.\n  You\u0026rsquo;ll need to create a security group which allows inbound TCP connections. See also: Working With Security Groups.\n  Install docker-machine\n  Create an SSH key/pair $ ssh-keygen -t rsa -b 4096 -C \u0026quot;your_email@example.com\u0026quot; -f aws_rsa $ eval \u0026quot;$(ssh-agent -s)\u0026quot; $ ssh-add ~/.ssh/aws_rsa Create The Docker Machine AWS_ACCESS_KEY_ID=\u0026lt;YOUR_ACCESS_KEY_ID\u0026gt; AWS_SECRET_ACCESS_KEY=\u0026lt;YOUR_SECRET_KEY\u0026gt; docker-machine create -d amazonec2 \\  --amazonec2-access-key $AWS_ACCESS_KEY_ID \\  --amazonec2-secret-key $AWS_SECRET_ACCESS_KEY \\  --amazonec2-region eu-west-3 \\  --amazonec2-instance-type \u0026#34;t2.medium\u0026#34; \\  --amazonec2-ssh-keypath ~/.ssh/aws_rsa \\  aws-ogmios Push The Stack First, configure your shell and activate your docker-machine:\n$ eval $(docker-machine env aws-ogmios) Then, simply push the stack using docker-compose:\n$ COMPOSE_TLS_VERSION=TLSv1_2 docker-compose up -d  Compose may use a wrong TLS version for pulling layers from dockerhub. Hence the ENV var.\n üéâ Enjoy $ docker-machine ls NAME ACTIVE DRIVER STATE URL SWARM DOCKER ERRORS aws-ogmios * amazonec2 Running tcp://xx.xxx.xxx.xxx:xxxx v19.03.8 (Optional) Adding TLS with a registered domain   Install nginx.\n    Configure a new server as /etc/nginx/sites-enabled/domain.extension   server { server_name DOMAIN.EXTENSION; listen 80; location ^~ /.well-known/acme-challenge/ { try_files $uri /dev/null =404; } }    üëÜ Make sure to replace \u0026lsquo;DOMAIN.EXTENSION\u0026rsquo; with your actual registered domain.\n  Reload your nginx configuration with: sudo systemctl reload nginx.service.\n  Install certbot and let certbot configure your nginx server (sudo certbot --nginx).\n  Once done, edit your nginx configuration one more time\u0026hellip;\n    Remove (no longer needed after certbot has successfully configured the server)   location ^~ /.well-known/acme-challenge/ { try_files $uri /dev/null =404; }        And add the following clause to enable routing all traffic (including WebSockets) to ogmios   location ~* / { proxy_pass http://localhost:1337; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \u0026#34;Upgrade\u0026#34;; proxy_set_header Host $host; }        The final configuration should look like this:\nserver { server_name ogmios.dev; location ~* / { proxy_pass http://localhost:1337; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \u0026#34;Upgrade\u0026#34;; proxy_set_header Host $host; } listen 443 ssl; # managed by Certbot  ssl_certificate /etc/letsencrypt/live/ogmios.dev/fullchain.pem; # managed by Certbot  ssl_certificate_key /etc/letsencrypt/live/ogmios.dev/privkey.pem; # managed by Certbot  include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot  ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot } server { server_name ogmios.dev; listen 80; if ($host = ogmios.dev) { return 301 https://$host$request_uri; } # managed by Certbot  return 404; # managed by Certbot } "},{"uri":"https://ktorz.github.io/cardano-ogmios/getting-started/docker/","title":"Docker","tags":[],"description":"","content":"üê≥ The easiest way to get started is to use docker. This guide won\u0026rsquo;t cover installing docker, so make sure you have the docker daemon installed and running. Since Ogmios requires the presence of a Cardano node, we\u0026rsquo;ll be using docker-compose to orchestrate both services. A compose file is available on the Ogmios repository, get it via:\n$ wget https://raw.githubusercontent.com/KtorZ/cardano-ogmios/master/docker-compose.yml -O docker-compose.yml Then, starts the components stack using:\n$ docker-compose up üëÜThis will run and connect together:\n A Cardano node, connected to mainnet. An Ogmios server using the latest Dockerhub build, listening to localhost on port :1337.  To build the Ogmios image from sources, pass the --build flag. This is useful if you need a different version than the latest one available on Dockerhub.\nConfiguration The compose file allows for minimal (albeit useful) configuration parameters via environment variables:\n   Variable Description Values Default     NETWORK Which Cardano network to connect to. This impacts both Ogmios and the underlying Cardano node. mainnet, testnet mainnet   OGMIOS_PORT Which ports to listen to (both for WebSockets and health endpoints) Any valid port number. 1337    Ogmios doesn\u0026rsquo;t use any form of persistent storage, but cardano-node does. The mainnet and testnet databases are not compatible, so it is recommended to instrument docker-compose to use different namespaces for different networks (so that you can switch from one another without risking any database conflicts). Compose can do this easily by passing an extra flag: --project-name.\n For example, for running cardano-node + ogmios on the testnet, listening to tcp/1338, do:\n$ NETWORK=testnet OGMIOS_PORT=1338 docker-compose --project-name cardano-ogmios-testnet up "},{"uri":"https://ktorz.github.io/cardano-ogmios/mini-protocols/local-chain-sync/","title":"Local Chain Sync","tags":[],"description":"","content":"*-----------* | Intersect |‚óÄ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó *-----------* FindIntersect ‚ïë ‚îÇ ‚ïë ‚îÇ *---------* ‚îÇ Intersect.{Found,NotFound} | | ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïº| | | Idle | ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê| | ‚ïë RequestNext | |‚á¶ START ‚ïë *---------* ‚ñº ‚ïø *------* Roll.{Backward,Forward} ‚îÇ | Next |‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò *------*  Overview Clients that wish to synchronise blocks from the Cardano chain can use the Local Chain Sync protocol.\nThe protocol is stateful, which means that each connection between clients and Ogmios has a state: a cursor locating a point on the chain. Typically, a client will start by looking for an intersection between its own local chain and the one from the node / Ogmios. Then, it\u0026rsquo;ll simply request the next action to take: either rolling forward and adding new blocks, or rolling backward.\nHow To Use When a connection is opened with Ogmios, it automatically starts a local chain-sync session with the underlying cardano-node. There\u0026rsquo;s an implicit state maintained by the node which one can imagine as a cursor, pointing to a point on the Cardano chain. Initially, this cursor starts at a special point called: origin (as in, the origin of the chain). After each request, the node will move the cursor either forward or backward and remembers its location for the next request. To move the cursor, the protocols gives two mechanisms: RequestNext and FindIntersect.\n* -- * -- * -- * -- * -- * .. Cardano chain ^ | | origin RequestNext Clients may ask for the next block where \u0026lsquo;next\u0026rsquo; refers directly to that implicit cursor. This translates to a message with RequestNext as a method name. This request does not accept any arguments.\n{ \u0026#34;type\u0026#34;: \u0026#34;jsonwsp/request\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0\u0026#34;, \u0026#34;servicename\u0026#34;: \u0026#34;ogmios\u0026#34;, \u0026#34;methodname\u0026#34;: \u0026#34;RequestNext\u0026#34;, \u0026#34;args\u0026#34;: {} } As a response, Ogmios will send back a response which can be either RollForward or RollBackward. Rolling forward is pretty straightforward and is the main type of response one can expect; such response will include the next block, which itself includes a header, transactions, certificates, metadata and all sort of information.\nRolling backward however may occur when, since the last request, the underlying node decided to switch to a different fork of the chain to the extent that the previous cursor is no longer pointing to a block that exists on the chain. The node therefore asks (kindly) to roll backward to a previously known point that is the earliest ancestor that is common between the client\u0026rsquo;s own chain locally and the one that was just adopted by the node.\n* -- * -- * -- * (node's chain) / common chain prefix * \u0026lt;------------------------\u0026gt; / * -- * -- * -- * -- * -- * -- * -- * -- * -- * (local chain) ^ | | Point of rollback When rolling backward, the node will not provide a block but instead, a point which is made of a block header hash and a slot.\nAs a client, it is therefore crucial to be able to rollback to a previous point of the chain. In practice, Ouroboros guarantees that forks cannot be longer than a certain length. This maximum length is called k in the Ouroboros protocol, and also known as the security parameter.\n FindIntersect On the first connection with the node, clients will likely synchronize from the origin. Yet, on subsequent connections one may want to resume syncing to a point that is much more recent than the origin. Ideally, one would like to carry on exactly at the point where the chain was left yet as we just saw, this is not always possible. The local chain-sync protocol gives however clients a way to find a common intersection between a client\u0026rsquo;s current version of the chain and whatever version the node has. This is via the FindIntersect message. This message accepts one argument which is a list of header hashes (or the special keyword \u0026quot;origin\u0026quot;).\n{ \u0026#34;type\u0026#34;: \u0026#34;jsonwsp/request\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0\u0026#34;, \u0026#34;servicename\u0026#34;: \u0026#34;ogmios\u0026#34;, \u0026#34;methodname\u0026#34;: \u0026#34;FindIntersect\u0026#34;, \u0026#34;args\u0026#34;: { \u0026#34;points\u0026#34;: [ \u0026#34;9e871633f7aa356ef11cdcabb6fdd6d8f4b00bc919c57aed71a91af8f86df590\u0026#34;, \u0026#34;d184f428159290bf3558b4d1d139e6a07ec6589738c28a0925a7ab776bde4d62\u0026#34;, \u0026#34;origin\u0026#34; ] }, } If an intersection is found, great, the node will set the cursor to that point and let you know. If not, the cursor will remain where it was and the failure will also be broadcast. As we\u0026rsquo;ve seen in the previous section, a node may switch to longer forks based quite arbitrarily. Hence, a good list of intersections candidates is preferably dense near the tip of the chain, and goes far back in the past (k is typically not enough).\nFor example, imagine the following scenario:\nP01 P02 P03 P04 P05 P98 P99A P100A Local chain: * -- * -- * -- * -- * ... * -- * -- * P01 P02 P03 P04 P05 P98 P99B P100B Node's chain: * -- * -- * -- * -- * ... * -- * -- * As a client, providing any point before or at P98 will result in finding an intersection. Yet, if one only provides [P99A, P100A], the node will not be able to figure out where to continue the protocol and will remain at the origin.\nThe order of the list matters! The node will intersect with the best match, considering that the preferred points are first in the list. If one provides origin as a first point, an intersection is guaranteed to always find a match, and always at origin (and that is quite useless!).\n Full Example Let\u0026rsquo;s see a full example that is synchronizing the first 14 blocks of the Shelley chain and printing them to the console.\nconst WebSocket = require(\u0026#39;ws\u0026#39;); const client = new WebSocket(\u0026#34;ws://localhost:1337\u0026#34;); function findIntersect(points) { client.send(JSON.stringify({ type: \u0026#34;jsonwsp/request\u0026#34;, version: \u0026#34;1.0\u0026#34;, servicename: \u0026#34;ogmios\u0026#34;, methodname: \u0026#34;FindIntersect\u0026#34;, args: { points } })); } function requestNext(mirror) { client.send(JSON.stringify({ type: \u0026#34;jsonwsp/request\u0026#34;, version: \u0026#34;1.0\u0026#34;, servicename: \u0026#34;ogmios\u0026#34;, methodname: \u0026#34;RequestNext\u0026#34;, mirror, })); } client.once(\u0026#39;open\u0026#39;, () =\u0026gt; { const lastByronBlock = { slot: 4492799, hash: \u0026#34;f8084c61b6a238acec985b59310b6ecec49c0ab8352249afd7268da5cff2a457\u0026#34; }; findIntersect([lastByronBlock]); }); client.on(\u0026#39;message\u0026#39;, function(msg) { const response = JSON.parse(msg); switch (response.methodname) { case \u0026#34;FindIntersect\u0026#34;: if (!response.result.IntersectionFound) { throw \u0026#34;Whoops? Last Byron block disappeared?\u0026#34; } requestNext({ n: 14 }); break; case \u0026#34;RequestNext\u0026#34;: if (response.result.RollForward) { console.log(response.result); } if (response.reflection.n \u0026gt; 0) { requestNext({ n: response.reflection.n - 1 }); } else { client.close(); } break; } }); A few important takes from this excerpt:\n  The node streams blocks that are after the intersection point. Thus to get the first 14 Shelley blocks, one needs to set the intersection at the last Byron block!\n  After successfully finding an intersection, the node will always ask to roll backward to that intersection point. This is because it is possible to provide many points when looking for an intersection and the protocol makes sure that both the node and the client are in sync. This allows clients applications to be somewhat \u0026ldquo;dumb\u0026rdquo; and blindly follow instructions from the node.\n  In this schema, we are sending each request one-by-one, using the mirror field as counter. An alternative could have been:\ncase \u0026#34;FindIntersect\u0026#34;: if (!response.result.IntersectionFound) { throw \u0026#34;Whoops? First Shelley block disappeared?\u0026#34; } for (let i = 14; i \u0026gt; 0; i += 1) { requestNext() } break; We need not to wait for replies to send requests and can collect all responses at a later stage!\n  Note that Ogmios will do its best to pipeline requests to the Cardano node. Nevertheless, unlike WebSocket the local chain-sync protocol only allows for finite pipelining. Said differently, Ogmios cannot pipeline an arbitrary and potentially infinite number of requests and will actually starts collecting responses if too many requests are pipelined. So, if you\u0026rsquo;re pipelining many requests in a client application, make sure to also take times to collect some responses because there will be no extra benefits coming from too much pipelining.\n "},{"uri":"https://ktorz.github.io/cardano-ogmios/getting-started/building/","title":"Building","tags":[],"description":"","content":" You may skip this section if you\u0026rsquo;re using Docker üê≥.\n Pre-requisites Ogmios is built using the great Haskell build tool stack. You\u0026rsquo;ll also need git to clone the source code, that is:\n git 2.11.* stack 2.*.*  Ogmios in itself is a rather small project, yet it\u0026rsquo;s using library directly from the ouroboros-network, cardano-ledger-specs and cardano-node projects. This is handy for re-using existing logic, but comes at the cost of several system dependencies that are required for building everything. Some may already be installed on your system, but the complete list is:\n libsodium-dev 1.0.* libgmp-dev 6.1.* libssl-dev 1.1.* libpcre3-dev 2.8.* libsystemd-dev zlib1g-dev 1.2.*  üî® Ogmios Clone the git repository from Github:\n$ git clone git@github.com:KtorZ/cardano-ogmios.git \u0026amp;\u0026amp; cd cardano-ogmios Then, use Stack to compile the project source code from the repository root:\n$ stack build ogmios The first time, this may take a while as Stack needs to setup a compilation environment and to download a lot of dependencies. Subsequent executions are much faster.\nFrom there, you can run Ogmios via stack using the exec command:\n$ stack exec -- ogmios --help Alternatively, you can instrument Stack to copy the compiled executable elsewhere so that you can run Ogmios all by itself:\n$ stack install ogmios $ ogmios --help üìö Documentation API Reference Install json-schema-for-humans using pip3:\n$ pip3 install json-schema-for-humans And then, run:\n$ cd docs \u0026amp;\u0026amp; generate-schema-doc --config no_link_to_reused_ref ../ogmios.wsp.json index.html "},{"uri":"https://ktorz.github.io/cardano-ogmios/mini-protocols/local-tx-submission/","title":"Local Tx Submission","tags":[],"description":"","content":"Overview *----------* | Busy |‚óÄ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó *----------* SubmitTx ‚ïë ‚îÇ ‚ïë ‚îÇ *---------* ‚îÇ | | ‚îÇ | | ‚îÇ SubmitTxResponse | Idle | ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïº| | | |‚á¶ START *---------*  Transaction submission is pretty simple \u0026amp; works by submitting an already serialized and signed transaction as one single message.\nIn case of success, Ogmios / the node returns an empty response. Otherwise, it returns an error with some details about what went wrong. Clients must thereby know how to construct valid transactions.\nüöß Coming Soon: JavaScript Examples with Ogmios üöß\n"},{"uri":"https://ktorz.github.io/cardano-ogmios/mini-protocols/","title":"Ouroboros Mini-Protocols","tags":[],"description":"","content":"Ouroboros Mini-Protocols In this section, we\u0026rsquo;ll give practical insights about interacting with the Ouroboros mini-protocols. Each sub-section will focus on one particular protocol, give an overview and give examples in JavaScript using Ogmios.\n"},{"uri":"https://ktorz.github.io/cardano-ogmios/deployment/","title":"Deployment","tags":[],"description":"","content":"Deployment Find in this section information about deployment Ogmios with various service providers.\n"},{"uri":"https://ktorz.github.io/cardano-ogmios/mini-protocols/local-state-query/","title":"Local State Query","tags":[],"description":"","content":"Overview üöß Coming Soon üöß\n"},{"uri":"https://ktorz.github.io/cardano-ogmios/getting-started/testing/","title":"Testing","tags":[],"description":"","content":" You may skip this section if you\u0026rsquo;re not interested in contributing to Ogmios.\n üîß Unit Tests First, make sure to pull and update git submodules:\n$ git submodule update --init Then, simply use stack as follows:\n$ stack test ogmios:unit üí® Smoke Tests Run the whole components stack using docker-compose as follows:\n$ docker-compose up To tear down, press CTRL+C and then run:\n$ docker-compose down "},{"uri":"https://ktorz.github.io/cardano-ogmios/api-reference/","title":"API Reference","tags":[],"description":"","content":"üöß Coming Soon üöß\n"},{"uri":"https://ktorz.github.io/cardano-ogmios/getting-started/basics/","title":"Basics","tags":[],"description":"","content":"JSON-WSP Ogmios' interface is built on top of JSON-WSP which is a tiny standard to give some structure to the various messages that can be exchanged with Ogmios. The standard specifies a top-level JSON envelope by which messages must abide, as well as a semantic for some of the fields. In particular, there are 4 types of messages possible in JSON-WSP:\n descriptions requests responses faults (which are a special kind of responses).  We won\u0026rsquo;t be covering the JSON-WSP standard in this guide but gives a few extra insights about how it relates to Ogmios and some good takes from it. Each request in Ogmios yields exactly one response, might it be a normal response or a fault. Furthermore, requests which relate to a particular protocol are guaranteed to yield responses in the same order.\nRequests Requests messages are sent by client applications (you) to Ogmios. Requests have 3 fields of interest: methodname, args and mirror. The methodname identifies the request itself and translates to a corresponding message of one of the 3 Ouroboros mini-protocols. Possible values for the methodname are described in section 3 - Ouroboros mini-protocols and the complete reference is available in section 4 - API Reference.\nHere is an example of valid request message:\n{ \u0026#34;type\u0026#34;: \u0026#34;jsonwsp/request\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0\u0026#34;, \u0026#34;servicename\u0026#34;: \u0026#34;ogmios\u0026#34;, \u0026#34;methodname\u0026#34;: \u0026#34;FindIntersect\u0026#34;, \u0026#34;args\u0026#34;: { \u0026#34;points\u0026#34;: [ \u0026#34;origin\u0026#34; ] }, \u0026#34;mirror\u0026#34;: { \u0026#34;step\u0026#34;: \u0026#34;INIT\u0026#34; } } As you can see, the methodname specifies the method FindIntersect which relates to the local chain-sync Ouroboros mini-protocol. This particular request expects one argument named points, which contains a list of points we want to intersect with (don\u0026rsquo;t panic, this is explained in further details in the next section!). Another interesting, albeit optional, field is the mirror field. This is completely free-form and will be spit back identically by Ogmios in the response. This can be useful to keep track of states on the client application or pass in extra context to each request/response. Be careful though that anything you send for a request will come back in the response; send something big, get something big.\nResponses Let\u0026rsquo;s start with a possible response to the request above:\n{ \u0026quot;type\u0026quot;: \u0026quot;jsonwsp/response\u0026quot;, \u0026quot;version\u0026quot;: \u0026quot;1.0\u0026quot;, \u0026quot;servicename\u0026quot;: \u0026quot;ogmios\u0026quot;, \u0026quot;methodname\u0026quot;: \u0026quot;FindIntersect\u0026quot;, \u0026quot;result\u0026quot;: { \u0026quot;IntersectionFound\u0026quot;: { \u0026quot;point\u0026quot;: \u0026quot;origin\u0026quot;, \u0026quot;tip\u0026quot;: { \u0026quot;hash\u0026quot;: \u0026quot;d184f428159290bf3558b4d1d139e6a07ec6589738c28a0925a7ab776bde4d62\u0026quot;, \u0026quot;blockNo\u0026quot;: 4870185, \u0026quot;slot\u0026quot;: 12176171 } } }, \u0026quot;reflection\u0026quot;: { \u0026quot;step\u0026quot;: \u0026quot;INIT\u0026quot; } } The response kindly indicates which requests it corresponds to and has the same methodname as the matching request. It also gives a result under a specific field. Responses can have various results which are fully specified in section 4. - API Reference. Also, notice the reflection field which reflects exactly the mirror field that was set for the request.\nOgmios' responses may correspond to possible errors that are part of the Ouroboros mini-protocols. For example, if you submit an invalid transaction, you\u0026rsquo;ll get back a message of type jsonwsp/response because it is a valid message in the context of the mini-protocols. Yet, Ogmios will yield a message of type jsonwsp/fault if you submit an invalid Ogmios message (for instance, an unknown request constructor, or something that is not a valid JSON-WSP message).\n WebSocket Ogmios uses WebSocket as a communication protocol. The WebSocket protocol is full-duplex, which means that Ogmios and clients can send messages to each other all at the same time. That is very convenient for clients who can pipeline many requests at once and process responses later on as they arrive.\nTherefore, to send a message to ogmios, you only need a WebSocket client! For example, using the well-established ws Node.js package and assuming a local instance of Ogmios started through Docker, you can interact with Ogmios as simply as:\nconst WebSocket = require(\u0026#39;ws\u0026#39;); const client = new WebSocket(\u0026#34;ws://localhost:1337\u0026#34;); client.once(\u0026#39;open\u0026#39;, () =\u0026gt; { const request = { \u0026#34;type\u0026#34;: \u0026#34;jsonwsp/request\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0\u0026#34;, \u0026#34;servicename\u0026#34;: \u0026#34;ogmios\u0026#34;, \u0026#34;methodname\u0026#34;: \u0026#34;FindIntersect\u0026#34;, \u0026#34;args\u0026#34;: { \u0026#34;points\u0026#34;: [ \u0026#34;origin\u0026#34; ] } }; client.send(JSON.stringify(request)); }); client.on(\u0026#39;message\u0026#39;, function(msg) { const response = JSON.parse(msg); // do something with \u0026#39;response\u0026#39; }); That\u0026rsquo;s all for the basics. The rest isn\u0026rsquo;t really specific to Ogmios, but is about the Ouroboros mini-protocols themselves. See the next sections for a deep dive!\n"},{"uri":"https://ktorz.github.io/cardano-ogmios/","title":"Overview","tags":[],"description":"","content":"Overview Ogmios is a translation service written in Haskell running on top of cardano-node. It offers a JSON-WSP interface through WebSockets and enables clients to speak Ouroboros' mini-protocols via remote procedure calls over JSON. Ogmios is very lightweight too and can be deployed alongside relays to create entry points on the Cardano network for various type of applications (e.g. wallets, explorers, chatbots, dashboards\u0026hellip;).\nMotivation All programs offer more or less elaborated interfaces for either user or program interactions. That is, most user-facing programs include a graphical user interface (a.k.a GUI) where users can send signals via buttons and switches, and receive visual or auditive feedback from the program. Some programs are also meant to be used by other programs and are typically called services; such services offer application programming interfaces in various forms to enable other programs (or services) to interact. The nodes from Cardano belong to the second category, yet the offer a rather exotic interface: ad-hoc protocols designed in-house by IOHK to be extremely efficient and secure.\nIn order to deal with a Cardano node, one has therefore to speak one of these so-called Ouroboros mini-protocols. This can be an impediment to mass adoption for the only existing implementation of such protocols is written in Haskell. Ogmios is an attempt to lower down that entry barrier by translating the interface to a set of technology that is well-known on the Web. In essence, it is very much like putting a power socket adaptor on the wall in order to branch a device; Cardano node is the device, Ogmios is the socket adaptor.\nOgmios is thereby very lightweight and doesn\u0026rsquo;t do anything on its own. It is running next to a Cardano node and act as an intermediary for another client application. Ogmios emulates the Ouroboros mini-protocols through WebSockets and translates the binary on-chain data into JSON; both WebSockets and JSON are widespread over the Web and in many other applications so much that they offer the ideal mainstream interface that I hope will help getting more and more application developers to build with Cardano!\nAbout me My name is Matthias (a.k.a KtorZ) and I currently work with the engineering teams of IOHK to build Cardano. My main area of focus within the Cardano project is basically anything that deals with a Cardano node, which means a lot of things! From a very young age, I\u0026rsquo;ve been enjoying designing and writing programs. Ogmios is yet another instance of this which I started as a proof-of-concept on my free-time, and rapidly became one of my most sophisticated side-project.\n"},{"uri":"https://ktorz.github.io/cardano-ogmios/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"https://ktorz.github.io/cardano-ogmios/tags/","title":"Tags","tags":[],"description":"","content":""}]